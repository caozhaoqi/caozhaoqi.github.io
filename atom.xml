<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhaoqi.Cao static blog</title>
  
  <subtitle>浅斟低唱</subtitle>
  <link href="https://caozhaoqi.github.io/atom.xml" rel="self"/>
  
  <link href="https://caozhaoqi.github.io/"/>
  <updated>2025-11-29T14:00:59.411Z</updated>
  <id>https://caozhaoqi.github.io/</id>
  
  <author>
    <name>Zhaoqi.Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/"/>
    <id>https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/</id>
    <published>2025-11-29T14:00:18.000Z</published>
    <updated>2025-11-29T14:00:59.411Z</updated>
    
    <content type="html"><![CDATA[<h1>[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</h1><blockquote><p><strong>摘要</strong>：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 <code>JD_Agent</code> 项目的里程碑式更新。我们引入了 <strong>Next.js</strong> 复刻 DeepSeek 的丝滑 UI，基于 <strong>SQLModel</strong> 实现了完整的用户鉴权与会话管理，并利用 <strong>RAG 技术</strong> 实现了“简历解析与长期记忆”功能，让 AI 真正拥有了“记住用户”的能力。</p></blockquote><hr><h2 id="1-项目演进：从-Script-到-Product">1. 项目演进：从 Script 到 Product</h2><p>在之前的版本中，我们的 <code>JD_Agent</code> 只是一个无状态的 API 接口：用户发 JD，AI 返回分析。<br>但一个真正的 AI 产品需要具备：</p><ol><li><strong>用户系统</strong>：数据隔离，每个人只能看自己的历史。</li><li><strong>交互体验</strong>：流式输出、Markdown 渲染、历史记录回溯。</li><li><strong>长期记忆</strong>：记住用户的简历背景，不需要每次 Prompt 都重复“我是 Python 开发…”。</li></ol><p>今天，我们完成了这次<strong>全栈重构</strong>。</p><hr><h2 id="2-技术栈全景">2. 技术栈全景</h2><ul><li><strong>Frontend</strong>: Next.js 14 (App Router) + Tailwind CSS + Lucide React</li><li><strong>Backend</strong>: FastAPI + Uvicorn</li><li><strong>Database</strong>: SQLModel (SQLite) + Alembic</li><li><strong>Auth</strong>: JWT (OAuth2PasswordBearer) + Passlib (Bcrypt)</li><li><strong>AI Core</strong>: LangChain + OpenAI/DeepSeek + FAISS (RAG)</li></ul><hr><h2 id="3-核心功能实现">3. 核心功能实现</h2><h3 id="3-1-完美复刻-DeepSeek-的交互界面">3.1 完美复刻 DeepSeek 的交互界面</h3><p>我们抛弃了简陋的 HTML，采用 <strong>Next.js + Tailwind</strong> 打造了现代化的 Chat UI。</p><ul><li><strong>布局攻坚</strong>：为了实现“顶部固定、侧边栏独立滚动、输入框底部悬浮且不遮挡内容”，我们采用了 <code>fixed inset-0</code> 锁死视口高度，并配合 <code>pb-[200px]</code> 的底部内边距策略。</li><li><strong>Markdown 渲染</strong>：后端返回的结构化 JSON 报告，在前端被动态组装成 Markdown，并通过 <code>react-markdown</code> 渲染出漂亮的排版。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端布局核心 Trick</span></span><br><span class="line">&lt;div className=<span class="string">&quot;fixed inset-0 flex ...&quot;</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 侧边栏 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;w-[260px] hidden md:flex ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;<span class="comment">/* 主聊天区 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;flex-1 flex flex-col h-full relative&quot;</span>&gt;</span><br><span class="line">     &#123;<span class="comment">/* 消息列表：底部留白防止被输入框遮挡 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;flex-1 overflow-y-auto pb-[200px]&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">     </span><br><span class="line">     &#123;<span class="comment">/* 悬浮输入框：背景渐变透明 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;absolute bottom-0 ... bg-gradient-to-t ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-长期记忆：简历解析与用户画像-LTM">3.2 长期记忆：简历解析与用户画像 (LTM)</h3><p>这是本次更新的<strong>灵魂功能</strong>。我们不希望 AI 聊完就忘，而是构建了一个<strong>长期记忆系统 (Long-Term Memory)</strong>。</p><p><strong>实现流程</strong>：</p><ol><li><strong>上传</strong>：用户上传 PDF/Word 简历。</li><li><strong>解析</strong>：后端使用 <code>pdfplumber</code> 提取纯文本。</li><li><strong>ETL</strong>：利用 LangChain 的 <code>resume_extractor</code> 链，从杂乱的简历中提取出<strong>结构化画像</strong>（如：<code>tech_stack: [&quot;Python&quot;, &quot;FastAPI&quot;]</code>, <code>experience: &quot;5年&quot;</code>）。</li><li><strong>存储</strong>：存入 <code>UserProfile</code> 数据库表。</li><li><strong>回想</strong>：下次用户发送 JD 时，系统自动读取 <code>UserProfile</code>，注入到 System Prompt 中。</li></ol><p><strong>后端代码片段 (Service Layer)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/interview_service.py</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request, db, user_id</span>):</span><br><span class="line">    <span class="comment"># 1. 读取长期记忆 (从数据库获取用户画像)</span></span><br><span class="line">    ltm_profile = get_user_profile_str(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 读取短期记忆 (从 ChatMessage 表获取最近对话)</span></span><br><span class="line">    chat_history = get_recent_chat_history(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 带着记忆去思考</span></span><br><span class="line">    task_tech = generate_tech_async(</span><br><span class="line">        ...,</span><br><span class="line">        user_profile=ltm_profile, <span class="comment"># &lt;--- 注入长期记忆</span></span><br><span class="line">        chat_history=chat_history <span class="comment"># &lt;--- 注入短期记忆</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="3-3-数据闭环：会话历史管理">3.3 数据闭环：会话历史管理</h3><p>为了实现侧边栏的“历史记录”功能，我们引入了 <strong>SQLModel</strong>。</p><ul><li><p><strong>表结构设计</strong>：</p><ul><li><code>User</code>: 存储用户名、加密密码。</li><li><code>ChatSession</code>: 代表一次对话（如“神州邦邦面试准备”）。</li><li><code>ChatMessage</code>: 存储具体的 User/Assistant 消息内容。</li></ul></li><li><p><strong>难点处理</strong>：Pydantic 对象无法直接存入数据库，我们在存库前将其序列化为 JSON 字符串，在读取时再反序列化，确保前端能拿到结构化的 <code>meta</code> 数据进行渲染。</p></li></ul><hr><h2 id="4-工程化踩坑实录">4. 工程化踩坑实录</h2><p>在开发过程中，我们解决了一系列真实的工程问题：</p><h3 id="坑位-1：Tailwind-CSS-样式失效">坑位 1：Tailwind CSS 样式失效</h3><ul><li><strong>现象</strong>：页面元素堆叠在左上角，样式全无。</li><li><strong>原因</strong>：Next.js 初始化时 <code>tailwind.config.js</code> 路径配置错误，且误装了不兼容的 Tailwind v4 版本。</li><li><strong>解决</strong>：降级至 <code>tailwindcss@3.4.17</code>，并手动修正 <code>content</code> 路径覆盖 <code>src/</code> 目录。</li></ul><h3 id="坑位-2：Bcrypt-版本冲突">坑位 2：Bcrypt 版本冲突</h3><ul><li><strong>现象</strong>：注册时报错 <code>AttributeError: module 'bcrypt' has no attribute '__about__'</code>。</li><li><strong>原因</strong>：<code>passlib</code> 库与最新版 <code>bcrypt 4.0+</code> 不兼容。</li><li><strong>解决</strong>：强制锁定版本 <code>pip install &quot;bcrypt==3.2.2&quot;</code>。</li></ul><h3 id="坑位-3：LangChain-参数丢失">坑位 3：LangChain 参数丢失</h3><ul><li><strong>现象</strong>：<code>KeyError: &quot;Input to ChatPromptTemplate is missing variables &#123;'user_profile'&#125;&quot;</code>。</li><li><strong>原因</strong>：在 Prompt 模板中定义了 <code>&#123;user_profile&#125;</code> 占位符，但在 Chain 调用 (<code>ainvoke</code>) 时忘记传入该参数。</li><li><strong>解决</strong>：在 Service 层获取记忆后，显式传递给 Chain。</li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p>通过今天的迭代，<code>JD_Agent</code> 已经具备了一个商业化 AI 产品的雏形：</p><ul><li><strong>好看</strong>：媲美 DeepSeek 的 UI。</li><li><strong>好用</strong>：支持简历一键解析，AI 越用越懂你。</li><li><strong>稳健</strong>：完整的鉴权与日志系统。</li></ul><p><strong>下一步计划</strong>：</p><ol><li><strong>多智能体模拟面试</strong>：引入两个 Agent 互相对话，用户旁观“模拟面试”过程（基于 SSE 流式输出）。</li><li><strong>语音交互</strong>：接入 TTS/ASR，实现真正的语音模拟面试。</li></ol><hr><p><em>技术改变生活，AI 赋能求职。如果你对这个项目感兴趣，欢迎关注我的 GitHub！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 &lt;c</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 RAG 与 Agent 协作的智能面试助手开发指南</title>
    <link href="https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/"/>
    <id>https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/</id>
    <published>2025-11-28T15:32:37.000Z</published>
    <updated>2025-11-28T15:34:27.317Z</updated>
    
    <content type="html"><![CDATA[<h1>实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南</h1><blockquote><p><strong>摘要</strong>：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记）进行回答？本文将拆解一个真实项目 <code>JD_Agent</code> 的实现过程。我们利用 <strong>FastAPI + LangChain</strong> 构建了一个智能体，它不仅能分析岗位 JD，还能通过 <strong>RAG 技术</strong> 检索我的本地 Markdown 博客，生成结合了我个人技术积累的专属面试指南。</p></blockquote><hr><h2 id="一、-为什么要做这个？（痛点与思路）">一、 为什么要做这个？（痛点与思路）</h2><p>在准备面试时，我们经常遇到两个问题：</p><ol><li><strong>JD 分析太累</strong>：每个岗位的技术栈不同，需要针对性复习。</li><li><strong>知识遗忘</strong>：明明以前写过关于 Docker 或 Redis 的博客笔记，但面试时一时想不起来细节。</li></ol><p><strong>我的解决方案</strong>：<br>构建一个 <strong>AI Agent</strong>。</p><ol><li>它能<strong>自动分析</strong>我投递的 JD（岗位描述），提取核心技术栈。</li><li>它拥有一个<strong>外挂大脑（知识库）</strong>，存储了我所有的博客文章。</li><li>在生成面试题时，它会<strong>优先参考</strong>我的博客内容，并告诉我：“这个问题你可以复习你写的这篇文章。”</li></ol><hr><h2 id="二、-核心原理：RAG-与-Agent-的协作">二、 核心原理：RAG 与 Agent 的协作</h2><p>在本项目中，我们采用了 <strong>RAG (Retrieval-Augmented Generation)</strong> 架构。</p><h3 id="1-什么是-RAG？">1. 什么是 RAG？</h3><p>如果把大模型（LLM）比作一个“超级学霸”，那 RAG 就是给了学霸一本“开卷考试的书”。</p><ul><li><strong>LLM</strong>：负责逻辑推理、语言组织。</li><li><strong>Knowledge Base</strong>：负责提供精准的、私有的事实数据（我的博客）。</li></ul><h3 id="2-协作流程图">2. 协作流程图</h3><p>整个系统的运作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User[用户输入 JD] --&gt;|1. 提交| Agent[智能体核心 (Service)]</span><br><span class="line">    </span><br><span class="line">    subgraph Analysis [阶段一: 意图识别]</span><br><span class="line">        Agent --&gt;|2. 解析 JD| Parser[LLM 解析器]</span><br><span class="line">        Parser --&gt;|提取关键词: Python, Docker| Keywords[技术栈列表]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Retrieval [阶段二: RAG 检索]</span><br><span class="line">        Keywords --&gt;|3. 查询向量库| VectorDB[(FAISS 向量库)]</span><br><span class="line">        VectorDB --&gt;|4. 返回博客片段 + 来源| Context[知识库上下文]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Generation [阶段三: 增强生成]</span><br><span class="line">        Context --&gt;|5. 注入 Prompt| Generator[LLM 生成器]</span><br><span class="line">        Generator --&gt;|6. 生成面试题 &amp; 引用来源| Output[最终报告]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="三、-关键技术实现">三、 关键技术实现</h2><h3 id="1-构建知识库-The-Embedding-Pipeline">1. 构建知识库 (The Embedding Pipeline)</h3><p>这是 RAG 的地基。我们需要把 Markdown 格式的博客文章转换成计算机能理解的“向量”。</p><p><strong>技术栈</strong>：<code>LangChain</code> + <code>BGE-Small-zh</code> + <code>FAISS</code></p><ul><li><strong>数据清洗 (ETL)</strong>：<br>使用 <code>MarkdownHeaderTextSplitter</code> 按章节切分文章，保证语义完整性。</li><li><strong>向量化 (Embedding)</strong>：<br>我们选用了 <strong>BAAI/bge-small-zh-v1.5</strong> 模型。它能将一段文字转换为 512 维的浮点数组。<blockquote><p><em>原理</em>：语义相近的句子（如“Docker容器”和“容器化部署”），在向量空间中的距离非常近。</p></blockquote></li><li><strong>存储结构</strong>：<br>存入 FAISS 的不仅是向量，还包含 <strong>Payload</strong>（原文）和 <strong>Metadata</strong>（元数据，如文件名）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：入库逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_index</span>():</span><br><span class="line">    <span class="comment"># 1. 加载博客 Markdown</span></span><br><span class="line">    docs = load_and_split_markdown(<span class="string">&quot;source/_posts&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化 BGE 模型 (使用国内镜像)</span></span><br><span class="line">    embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;BAAI/bge-small-zh-v1.5&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 向量化并存入 FAISS</span></span><br><span class="line">    vector_store = FAISS.from_documents(docs, embedding_model)</span><br><span class="line">    vector_store.save_local(<span class="string">&quot;blog_faiss_index&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-Agent-的大脑：异步编排-Orchestration">2. Agent 的大脑：异步编排 (Orchestration)</h3><p>为了让用户体验达到极致（快！），后端不能串行处理。我们利用 <strong>Python Asyncio</strong> 实现了并行任务流。</p><ul><li><strong>技术挑战</strong>：如何同时进行“公司背景调查”和“知识库检索”？</li><li><strong>解决方案</strong>：<code>asyncio.gather</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：并行编排</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 1. 先解析 JD (前置依赖)</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造查询：用 JD 里的技术栈去查博客</span></span><br><span class="line">    query = <span class="string">&quot; &quot;</span>.join(jd_meta.tech_stack)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 并行执行：(查博客) &amp; (查公司背景) &amp; (出通用题)</span></span><br><span class="line">    task_rag = kb_engine.search(query)</span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发等待结果</span></span><br><span class="line">    rag_result, company_info = <span class="keyword">await</span> asyncio.gather(task_rag, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将查到的博客内容注入 Prompt</span></span><br><span class="line">    final_report = <span class="keyword">await</span> generate_final_report(context=rag_result[<span class="string">&#x27;context&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="3-上下文注入-Context-Injection">3. 上下文注入 (Context Injection)</h3><p>这是让 AI “读懂”博客的关键一步。我们动态构建了 Prompt Template。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一个资深技术面试官。</span></span><br><span class="line"><span class="string">请根据以下【参考知识库】（这是用户的个人博客笔记）来生成面试题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">【参考知识库】：</span></span><br><span class="line"><span class="string">&#123;kb_context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请在生成题目时，明确指出用户在博客中对该知识点的理解。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、-遇到的坑与优化-Troubleshooting">四、 遇到的坑与优化 (Troubleshooting)</h2><p>在开发过程中，我们解决了几个典型的工程问题：</p><ol><li><p><strong>模型下载卡顿</strong>：</p><ul><li><em>问题</em>：HuggingFace 国内无法直连。</li><li><em>解决</em>：在代码顶部设置 <code>os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'</code> 强制走镜像。</li></ul></li><li><p><strong>Pydantic 数据校验错误</strong>：</p><ul><li><em>问题</em>：有时候 RAG 没查到数据，返回 <code>None</code>，导致接口报错。</li><li><em>解决</em>：在 Schema 定义中使用 <code>Optional[List[str]] = []</code>，增强系统的鲁棒性。</li></ul></li><li><p><strong>大模型“幻觉”</strong>：</p><ul><li><em>问题</em>：AI 编造博客里没有的内容。</li><li><em>解决</em>：在 Prompt 中加入约束——“仅依据参考知识库回答，如果知识库未提及，请忽略”。</li></ul></li></ol><hr><h2 id="五、-最终效果">五、 最终效果</h2><p>当用户输入一个包含 <strong>“Python, Docker”</strong> 的 JD 时：</p><ol><li><strong>后端</strong> 迅速定位到本地博客中的 <code>Docker部署笔记.md</code> 和 <code>Python并发编程.md</code>。</li><li><strong>AI</strong> 生成的面试指南中写道：<blockquote><p><strong>Q1: 请谈谈 Docker 的隔离机制？</strong><br><em>参考回答要点</em>：根据你的博客 <strong>《<a href="http://xn--Docker-gl3pp3z6v2awsl.md">Docker部署笔记.md</a>》</strong>，你曾总结过 Namespace 负责资源隔离，Cgroups 负责资源限制…</p></blockquote></li><li><strong>前端</strong> 界面底部会展示：<blockquote><p>📚 <strong>知识库引用</strong>：</p><ul><li>📄 <code>Docker部署笔记.md</code></li></ul></blockquote></li></ol><p>这不仅是一个面试题生成器，更是一个<strong>唤醒沉睡知识的第二大脑</strong>。</p><hr><h2 id="六、-总结">六、 总结</h2><p>本项目通过 <strong>FastAPI</strong> 构建高性能后端，<strong>LangChain</strong> 处理复杂的 LLM 逻辑，<strong>FAISS</strong> 实现毫秒级知识检索。它展示了 <strong>LLM Ops (大模型工程化)</strong> 的核心思路：<strong>不仅要会调 API，更要懂得如何管理数据流和上下文。</strong></p><p>如果你也想为自己的知识库装上 AI 引擎，欢迎参考我的 GitHub 仓库：[<a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a>]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 FastAPI + LangChain 的简单agent实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/26/agent-research-llm/"/>
    <id>https://caozhaoqi.github.io/2025/11/26/agent-research-llm/</id>
    <published>2025-11-26T13:26:13.000Z</published>
    <updated>2025-11-26T13:53:49.049Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GitHub 仓库</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在 AI Agent 开发中，如何平衡大模型的生成质量与接口的响应速度？本文将详细拆解 <code>jd_agent</code> 项目。这是一个基于岗位描述（JD）自动生成结构化面试指南的智能体。我们采用 <strong>FastAPI</strong> 作为后端，利用 <strong>LangChain</strong> 进行逻辑编排，并通过 <strong>Asyncio</strong> 实现并行推理，将任务耗时从 30s+ 优化至 10s 级。此外，本文还记录了从 OpenAI 迁移至 DeepSeek 的实战经验及工程踩坑记录。</p></blockquote><hr><h2 id="1-项目背景与痛点">1. 项目背景与痛点</h2><p>在求职过程中，针对每个岗位进行深度准备（分析技术栈、预测面试题、调研公司背景）是非常耗时的。<br>传统的 ChatGPT 交互方式虽然可行，但存在以下问题：</p><ul><li><strong>Prompt 重复劳动</strong>：每次都要输入一大段 Prompt。</li><li><strong>输出非结构化</strong>：生成的文本难以直接用于后续的数据存储或前端展示。</li><li><strong>响应缓慢</strong>：分析 JD、出技术题、出 HR 题、背调公司，如果串行执行，等待时间极长。</li></ul><p>本项目旨在通过<strong>工程化</strong>手段解决上述问题，构建一个<strong>可扩展、高并发、结构化输出</strong>的 AI Agent 后端。</p><hr><h2 id="2-技术架构设计-System-Architecture">2. 技术架构设计 (System Architecture)</h2><p>为了保证系统的可维护性和扩展性，本项目采用了<strong>分层架构 (Layered Architecture)</strong>。</p><h3 id="2-1-架构分层图">2.1 架构分层图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    Client[前端/客户端] --&gt;|HTTP/SSE| API[API Interface Layer]</span><br><span class="line">    </span><br><span class="line">    subgraph Backend [FastAPI Backend]</span><br><span class="line">        API --&gt; Service[Service Layer (Orchestration)]</span><br><span class="line">        </span><br><span class="line">        subgraph Parallel_Execution [异步并行执行区]</span><br><span class="line">            Task_A[JD Meta Parser]</span><br><span class="line">            Task_B[Tech Question Generator]</span><br><span class="line">            Task_C[Company Research Agent]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        Service --&gt; Task_A</span><br><span class="line">        Task_A --&gt; Task_B</span><br><span class="line">        Task_A --&gt; Task_C</span><br><span class="line">        </span><br><span class="line">        Task_B &amp; Task_C --&gt; Task_D[HR Question Generator]</span><br><span class="line">        </span><br><span class="line">        Task_B --&gt; Chains[LangChain Logic]</span><br><span class="line">        Task_C --&gt; Chains</span><br><span class="line">        </span><br><span class="line">        Chains --&gt; LLM_Factory[LLM Factory (OpenAI/DeepSeek)]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    Service --&gt;|Structured JSON| Client</span><br></pre></td></tr></table></figure><h3 id="2-2-核心组件">2.2 核心组件</h3><ul><li><strong>Web 框架</strong>: <code>FastAPI</code> (利用其原生异步特性处理 IO 密集型任务)。</li><li><strong>LLM 编排</strong>: <code>LangChain</code> (管理 Prompt、Chain 和 OutputParser)。</li><li><strong>数据验证</strong>: <code>Pydantic</code> (强制 LLM 输出符合 Schema 的 JSON)。</li><li><strong>并发控制</strong>: <code>Python Asyncio</code> (实现多 Chain 并行调用)。</li><li><strong>模型层</strong>: 支持 <code>OpenAI</code> 协议，实测完美兼容 <code>DeepSeek-V3</code>。</li></ul><hr><h2 id="3-核心实现细节-Implementation-Details">3. 核心实现细节 (Implementation Details)</h2><h3 id="3-1-强制结构化输出-Structured-Output">3.1 强制结构化输出 (Structured Output)</h3><p>大模型天生喜欢“聊天”，为了让它输出 JSON，我们摒弃了不稳定的正则表达式，转而使用 LangChain 的 <code>PydanticOutputParser</code>。</p><p><strong>Schema 定义 (<code>schemas/interview.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterviewReport</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    meta: JDMetaData</span><br><span class="line">    tech_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    hr_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    <span class="comment"># 使用 Optional 处理非必填项，增强鲁棒性</span></span><br><span class="line">    system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>Chain 实现 (<code>chains/tech_gen.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parser = PydanticOutputParser(pydantic_object=QuestionList)</span><br><span class="line">prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    请严格按照 JSON 格式输出:</span></span><br><span class="line"><span class="string">    &#123;format_instructions&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 注入 Pydantic 生成的 Schema 指令</span></span><br><span class="line">chain = prompt | llm | parser</span><br></pre></td></tr></table></figure><h3 id="3-2-异步并发编排-Asyncio-Optimization">3.2 异步并发编排 (Asyncio Optimization)</h3><p>这是本项目性能提升的关键。</p><ul><li><strong>串行模式</strong>：解析 JD (5s) -&gt; 查公司 (10s) -&gt; 出技术题 (10s) -&gt; 出 HR 题 (5s) = <strong>30s+</strong></li><li><strong>并行模式</strong>：解析 JD (5s) -&gt; [查公司 | 出技术题] (同时进行, 取最大值 10s) -&gt; 出 HR 题 = <strong>约 15s</strong></li></ul><p><strong>Service 层实现 (<code>services/interview_service.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request: JDRequest</span>):</span><br><span class="line">    <span class="comment"># 1. 前置依赖：必须先解析 JD</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造并行任务 (Fire tasks)</span></span><br><span class="line">    <span class="comment"># 技术题不依赖公司背景</span></span><br><span class="line">    task_tech = generate_tech_async(jd_meta.tech_stack, jd_meta.years_required)</span><br><span class="line">    <span class="comment"># 公司背调是网络 IO 密集型</span></span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 核心：并发等待</span></span><br><span class="line">    tech_qs, company_info = <span class="keyword">await</span> asyncio.gather(task_tech, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 后置依赖：HR 题依赖公司背景</span></span><br><span class="line">    hr_qs = <span class="keyword">await</span> generate_hr_async(jd_meta.soft_skills, company_info)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InterviewReport(...)</span><br></pre></td></tr></table></figure><h3 id="3-3-兼容多模型的-LLM-工厂">3.3 兼容多模型的 LLM 工厂</h3><p>为了在开发阶段节省成本（使用 DeepSeek），在生产阶段追求稳定（使用 OpenAI），我们设计了工厂模式。</p><p><strong>配置解耦 (<code>core/config.py</code>):</strong><br>通过 <code>.env</code> 文件动态切换底座，无需修改业务代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span></span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span> <span class="comment"># 默认指向 DeepSeek</span></span><br><span class="line">    MODEL_NAME: <span class="built_in">str</span> = <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-工程化踩坑与解决方案-Troubleshooting">4. 工程化踩坑与解决方案 (Troubleshooting)</h2><p>在开发过程中，我们遇到了数个真实的工程挑战，以下是排查记录。</p><h3 id="坑位-1：API-余额与鉴权混淆-429-vs-402">坑位 1：API 余额与鉴权混淆 (429 vs 402)</h3><ul><li><strong>现象</strong>: 程序崩溃，报错 <code>openai.RateLimitError: Error code: 429</code> 或 <code>402 Payment Required</code>。</li><li><strong>分析</strong>:<ul><li><code>429</code> 通常指速率限制，但 OpenAI 在余额不足时也会报这个错（<code>insufficient_quota</code>）。</li><li><code>402</code> 是明确的余额为零。</li></ul></li><li><strong>解决</strong>:<ul><li>不要死磕代码逻辑。</li><li>切换至 <strong>DeepSeek</strong>（充值 10 元人民币可用很久）或 <strong>SiliconFlow</strong>（免费额度）。</li><li>修改 <code>.env</code> 即可解决。</li></ul></li></ul><h3 id="坑位-2：Pydantic-字段校验异常">坑位 2：Pydantic 字段校验异常</h3><ul><li><strong>现象</strong>: <code>ValidationError: system_design_question Input should be a valid dictionary</code>。</li><li><strong>分析</strong>: 业务逻辑中某些情况下未生成系统设计题，返回了 <code>None</code>，但 Schema 定义默认为必填。</li><li><strong>解决</strong>: 使用 <code>Optional</code> 类型提示。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line">system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-3：SSL-证书警告-Mac-环境">坑位 3：SSL 证书警告 (Mac 环境)</h3><ul><li><strong>现象</strong>: <code>NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+</code></li><li><strong>分析</strong>: macOS 自带的 LibreSSL 版本过低，与新版 <code>urllib3</code> 不兼容。</li><li><strong>解决</strong>: 降级 urllib3 或使用 Homebrew 升级 OpenSSL。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&quot;urllib3&lt;2.0&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-4：Nginx-反向代理超时-504-Gateway-Time-out">坑位 4：Nginx 反向代理超时 (504 Gateway Time-out)</h3><ul><li><strong>现象</strong>: 爬虫或长文本生成任务耗时超过 60s，前端收到 504 错误。</li><li><strong>分析</strong>: Nginx 默认 <code>proxy_read_timeout</code> 为 60s。</li><li><strong>解决</strong>: 在 Nginx 配置中针对 API 路由增加超时时间。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600s</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p><code>jd_agent</code> 项目展示了如何将一个简单的 Prompt 交互转化为一个<strong>工业级的后端服务</strong>。</p><p><strong>核心收益</strong>:</p><ol><li><strong>效率提升</strong>: 并行处理使响应速度提升 <strong>300%</strong>。</li><li><strong>成本降低</strong>: 通过 LLM 工厂模式切换至 DeepSeek，Token 成本降低 <strong>90%</strong>。</li><li><strong>稳定性</strong>: 强类型校验和重试机制保证了服务的鲁棒性。</li></ol><p><strong>后续规划</strong>:</p><ul><li>引入 <strong>Redis</strong> 缓存 JD 解析结果，避免重复扣费。</li><li>集成 <strong>Celery</strong> 处理超长耗时的系统设计题生成。</li><li>开发 <strong>React/Next.js</strong> 前端，实现流式 Markdown 渲染。</li></ul><hr><p><em>如果你觉得这个项目对你有帮助，欢迎在 GitHub 上点个 Star ⭐️！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GitHub 仓库&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com/caozhaoqi/jd_agent&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实现高可用 MySQL 集群</title>
    <link href="https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/"/>
    <id>https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/</id>
    <published>2025-09-30T02:18:54.000Z</published>
    <updated>2025-11-25T15:05:10.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备阶段：项目结构">准备阶段：项目结构</h3><blockquote><p>首先，在您的服务器上创建一个项目文件夹，结构如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql_cluster/</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── proxysql/</span><br><span class="line">│   └── proxysql.cnf</span><br><span class="line">└── mysql/</span><br><span class="line">    ├── master/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── master.cnf</span><br><span class="line">    ├── slave1/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── slave1.cnf</span><br><span class="line">    └── slave2/</span><br><span class="line">        └── conf/</span><br><span class="line">            └── slave2.cnf</span><br></pre></td></tr></table></figure><h3 id="阶段一：编写配置文件">阶段一：编写配置文件</h3><h4 id="1-主库配置-mysql-master-conf-master-cnf">1. 主库配置 (<code>mysql/master/conf/master.cnf</code>)</h4><p>这个文件定义了主库的特定配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">100</span></span><br><span class="line"><span class="attr">log-bin</span>                 = /var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我们使用了 <code>GTID</code> 模式，这是比传统基于 <code>File</code> 和 <code>Position</code> 更现代、更可靠的复制方式。</p><h4 id="2-从库配置-mysql-slave1-conf-slave1-cnf-和-slave2-cnf">2. 从库配置 (<code>mysql/slave1/conf/slave1.cnf</code> 和 <code>slave2.cnf</code>)</h4><p>两个从库的配置类似，只需更改 <code>server-id</code>。</p><p><strong><code>slave1.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">101</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>slave2.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">102</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="3-ProxySQL-配置-proxysql-proxysql-cnf">3. ProxySQL 配置 (<code>proxysql/proxysql.cnf</code>)</h4><p>这个文件用于初始化 ProxySQL 的配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">admin_credentials</span>=<span class="string">&quot;admin:admin&quot;</span></span><br><span class="line">    <span class="attr">mysql_ifaces</span>=<span class="string">&quot;0.0.0.0:6032&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">mysql_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">connect_timeout_server</span>=<span class="number">3000</span></span><br><span class="line">    <span class="attr">monitor_username</span>=<span class="string">&quot;monitor_user&quot;</span></span><br><span class="line">    <span class="attr">monitor_password</span>=<span class="string">&quot;monitor_password&quot;</span></span><br><span class="line">    <span class="attr">monitor_connect_timeout</span>=<span class="number">2000</span></span><br><span class="line">    <span class="attr">monitor_ping_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_interval</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">commands_stats</span>=<span class="string">&quot;enabled&quot;</span></span><br><span class="line">    <span class="attr">connect_timeout_server_max</span>=<span class="number">10000</span></span><br><span class="line">    <span class="attr">stacksize</span>=<span class="number">1048576</span></span><br><span class="line">    <span class="attr">threads</span>=<span class="number">4</span></span><br><span class="line">    <span class="attr">max_connections</span>=<span class="number">2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里我们定义了 ProxySQL 的管理用户 (<code>admin:admin</code>) 和一个用于监控后端 MySQL 健康状态的监控用户 (<code>monitor_user:monitor_password</code>)。</p><h4 id="4-Docker-Compose-文件-docker-compose-yml">4. Docker Compose 文件 (<code>docker-compose.yml</code>)</h4><p>这是整个架构的核心编排文件。它定义了所有的服务、网络和数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主数据库</span></span><br><span class="line">  <span class="attr">mysql_master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_master</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">my_app_db</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/master/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库1</span></span><br><span class="line">  <span class="attr">mysql_slave1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave1/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库2</span></span><br><span class="line">  <span class="attr">mysql_slave2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave2/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ProxySQL 中间件</span></span><br><span class="line">  <span class="attr">proxysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">proxysql/proxysql:2.4.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6032:6032&quot;</span> <span class="comment"># 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6033:6033&quot;</span> <span class="comment"># 客户端连接端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./proxysql/proxysql.cnf:/etc/proxysql.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proxysql_data:/var/lib/proxysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_master_data:</span></span><br><span class="line">  <span class="attr">mysql_slave1_data:</span></span><br><span class="line">  <span class="attr">mysql_slave2_data:</span></span><br><span class="line">  <span class="attr">proxysql_data:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mysql_cluster_net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p><strong>请务必将 <code>your_root_password</code> 替换为您自己的强密码。</strong></p><h3 id="阶段二：启动和配置集群">阶段二：启动和配置集群</h3><ol><li><p><strong>启动所有服务</strong>：<br>在 <code>mysql_cluster</code> 文件夹下，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Docker 会自动拉取镜像并按顺序启动所有容器。</p></li><li><p><strong>配置主从复制</strong>：<br>我们需要进入主库容器，创建复制用户和 ProxySQL 的监控用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入主库容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_master bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># (输入您在docker-compose中设置的密码)</span></span><br></pre></td></tr></table></figure><p>在MySQL命令行中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复制用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;repl_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建ProxySQL监控用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;monitor_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>现在，配置两个从库</strong>。进入每个从库容器，执行 <code>CHANGE MASTER TO</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入从库1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_slave1 bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>在从库1的MySQL命令行中执行（对从库2重复此操作）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用GTID自动定位，比File/Position更简单</span></span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST<span class="operator">=</span><span class="string">&#x27;mysql_master&#x27;</span>,  <span class="comment">-- 使用Docker的服务名</span></span><br><span class="line">  MASTER_USER<span class="operator">=</span><span class="string">&#x27;repl_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;repl_password&#x27;</span>,</span><br><span class="line">  MASTER_AUTO_POSITION<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> SLAVE;</span><br><span class="line"><span class="comment">-- 验证状态</span></span><br><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS\G; </span><br></pre></td></tr></table></figure><p>在从库2上重复以上 <code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 的步骤。</p></li><li><p><strong>配置 ProxySQL</strong>：<br>连接到 ProxySQL 的管理后台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，是从您的宿主机连接，不是在容器里</span></span><br><span class="line">mysql -u admin -padmin -h 127.0.0.1 -P 6032</span><br></pre></td></tr></table></figure><p>在 ProxySQL 管理后台执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置监控用户凭证（与proxysql.cnf和MySQL中创建的一致）</span></span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_user&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_username&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_password&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_password&#x27;</span>;</span><br><span class="line">LOAD MYSQL VARIABLES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置后端MySQL服务器</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers(hostgroup_id, hostname, port) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;mysql_master&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 写入组 (主库)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave1&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 读取组 (从库1)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave2&#x27;</span>, <span class="number">3306</span>); <span class="comment">-- 读取组 (从库2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置应用连接用户</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_users(username, password, default_hostgroup) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;app_user&#x27;</span>, <span class="string">&#x27;app_password&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义读写分离规则</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules(rule_id, active, match_digest, destination_hostgroup, apply) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;^SELECT.*&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;.*&#x27;</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">-- 一个更简单的规则：匹配SELECT的去读取组，其他所有都去写入组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载并保存配置</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL USERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL QUERY RULES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL USERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL QUERY RULES <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure></li></ol><h3 id="proxy-sql-web">proxy-sql-web</h3><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxysql-web:</span></span><br><span class="line">    <span class="comment"># --- 修改点在这里 ---</span></span><br><span class="line">    <span class="comment"># 使用一个在 Docker Hub 上公开可用的镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kishorj/proxysql-web:latest</span></span><br><span class="line">    <span class="comment"># ------------------</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql-web</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=192.168.10.158</span> <span class="comment"># 您的 ProxySQL 服务器 IP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=6032</span>         <span class="comment"># ProxySQL 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=admin</span>          <span class="comment"># ProxySQL 管理用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=admin</span>          <span class="comment"># ProxySQL 管理密码</span></span><br></pre></td></tr></table></figure><ul><li>run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="阶段三：切换应用">阶段三：切换应用</h3><p>现在，您的整个高可用集群已经在 Docker 中运行起来了。最后一步就是将您所有200多台电脑上的应用程序的数据库连接配置，指向 ProxySQL 容器暴露的端口。</p><ul><li><strong>Host</strong>: 运行 Docker 的那台服务器的 IP 地址。</li><li><strong>Port</strong>: <code>6033</code></li><li><strong>User</strong>: <code>app_user</code></li><li><strong>Password</strong>: <code>app_password</code></li></ul><h3 id="优点总结">优点总结</h3><ul><li><strong>环境一致性</strong>：无论部署到哪台机器，整个集群的环境都是完全一致的。</li><li><strong>快速部署与销毁</strong>：使用 <code>docker-compose up -d</code> 和 <code>docker-compose down -v</code> 可以秒级创建和彻底销毁整套环境，非常适合测试和开发。</li><li><strong>简化管理</strong>：服务之间的网络和依赖关系由 Docker Compose 管理，比手动配置网络和防火墙简单得多。</li><li><strong>资源隔离</strong>：每个服务都在自己的容器中运行，互不干扰。</li></ul><p>这个 Docker 化的方案为您提供了一个可移植、可复现、高度自动化的方式来部署和管理您的MySQL读写分离集群。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;准备阶段：项目结构&quot;&gt;准备阶段：项目结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，在您的服务器上创建一个项目文件夹，结构如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Devpi与Nginx构建高可用PyPI镜像源</title>
    <link href="https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/"/>
    <id>https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/</id>
    <published>2025-09-17T06:03:20.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Devpi与Nginx构建高可用PyPI镜像源">使用Devpi与Nginx构建高可用PyPI镜像源</h2><h3 id="前言：为什么你的pip-install又超时了？">前言：为什么你的<code>pip install</code>又超时了？</h3><p>对于每一位Python开发者来说，<code>pip install</code> 无疑是最常用的命令之一。然而，团队开发中，我们常常会遇到这些痛点：</p><ul><li><strong>速度瓶颈</strong>：团队几十号人，CI/CD流水线上百个任务，全都从国外的官方PyPI源拉取包，下载速度慢得令人抓狂，严重影响开发和部署效率。</li><li><strong>单点故障</strong>：官方PyPI偶尔会抖动，或者公司出口网络出现问题，导致所有依赖安装失败，研发流程瞬间停摆。</li><li><strong>安全与合规</strong>：无法对团队使用的第三方包进行统一管理和安全审计。</li><li><strong>私有包托管</strong>：团队内部开发的公共库无处安放，只能通过Git仓库等原始方式共享。</li></ul><p>为了彻底解决这些问题，我们需要一个<strong>私有的、高速的、且永不宕机</strong>的Python包仓库。今天，我将手把手带你使用业界最强大的开源工具 <strong><code>devpi</code></strong> 和 <strong><code>Nginx</code></strong>，构建一个具备自动故障转移能力的高可用PyPI镜像源。</p><p><strong>最终目标</strong>：无论清华源、阿里源还是其他任何一个镜像挂了，我们的 <code>pip install</code> 依然能丝滑流畅地运行，对开发者完全透明！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-------------------+     +-------------------------+     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |   Tsinghua Mirror       |</span><br><span class="line">|  开发者   | --&gt; |  devpi 服务器      | --&gt; |  Nginx 反向代理          | --&gt; |  (Upstream 1)            |</span><br><span class="line">| (pip)     |     | (缓存/私有包)      |     | (处理上游故障转移)       |     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |  Aliyun Mirror         |</span><br><span class="line">+-----------+     +-------------------+     +-------------------------+ --&gt; |  (Upstream 2)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  USTC Mirror             |</span><br><span class="line">                                                                          -&gt;|  (Upstream 3)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  ... and so on           |</span><br><span class="line">                                                                            +--------------------------+</span><br></pre></td></tr></table></figure><h3 id="第一章：核心武器介绍-Devpi-与-Nginx">第一章：核心武器介绍 - Devpi 与 Nginx</h3><p>在开始之前，我们先了解一下两位主角：</p><ol><li><p><strong>Devpi</strong>: 一个功能完备的Python包服务器。它不仅仅是 <code>pypi.org</code> 的一个缓存代理，更是一个强大的私有包仓库和版本发布管理工具。我们将主要利用它的<strong>缓存镜像</strong>功能。</p></li><li><p><strong>Nginx</strong>: 一款高性能的HTTP和反向代理服务器。在这里，它将扮演我们镜像源的“智能调度员”和“故障哨兵”，负责监测上游镜像源的健康状况，并在某个源出现问题时，自动将流量切换到健康的备用源上。</p></li></ol><h3 id="第二章：基础建设-搭建Devpi缓存服务器">第二章：基础建设 - 搭建Devpi缓存服务器</h3><p>首先，我们需要一个能稳定运行的<code>devpi</code>服务。</p><h4 id="步骤-1-准备服务器与安装Devpi">步骤 1: 准备服务器与安装Devpi</h4><p>在一台Linux服务器（本教程以Ubuntu为例）上，确保已安装Python和pip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新并安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 devpi-server</span></span><br><span class="line">pip3 install devpi-server</span><br><span class="line"></span><br><span class="line">devpi-init</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤-2-初始化Devpi">步骤 2: 初始化Devpi</h4><p>这个一次性操作会为你创建数据目录和 <code>root</code> 超级管理员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devpi-init</span><br></pre></td></tr></table></figure><p>在提示中，为 <code>root</code> 用户设置一个安全的密码，并牢牢记住它。</p><h4 id="步骤-3-让Devpi在后台稳定运行">步骤 3: 让Devpi在后台稳定运行</h4><p>为了生产环境的稳定，我们将 <code>devpi</code> 配置成一个 <code>systemd</code> 系统服务，实现开机自启和后台运行。</p><ol><li><p><strong>创建服务文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下配置</strong> (注意修改 <code>User</code> 和 <code>ExecStart</code> 中的路径为你自己的):</p></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ sudo cat /etc/systemd/system/devpi.service</span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=devpi-server daemon</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=czq2</span><br><span class="line"><span class="attr">Group</span>=czq2</span><br><span class="line"><span class="attr">ExecStart</span>=/home/czq2/clip-video/venv/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><code>--host=0.0.0.0</code> 确保局域网内的其他机器可以访问。</li></ul><ol start="3"><li><strong>启动并验证服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> devpi  <span class="comment"># 开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi   <span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status devpi  <span class="comment"># 检查状态</span></span><br></pre></td></tr></table></figure>看到绿色的 <code>active (running)</code>，恭喜你，基础的 <code>devpi</code> 镜像服务已经成功运行在 <code>http://&lt;你的服务器IP&gt;:3141</code> 上了！</li></ol><ul><li>成功输出</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl start devpi</span><br><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl status devpi</span><br><span class="line">● devpi.service - devpi-server daemon</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/devpi.service; enabled; preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2025-09-17 07:19:23 UTC; 3s ago</span><br><span class="line">   Main PID: 1619813 (devpi-server)</span><br><span class="line">      Tasks: 54 (<span class="built_in">limit</span>: 309293)</span><br><span class="line">     Memory: 41.4M (peak: 553.5M)</span><br><span class="line">        CPU: 15.733s</span><br><span class="line">     CGroup: /system.slice/devpi.service</span><br><span class="line">             └─1619813 /home/czq2/clip-video/venv/bin/python3 /home/czq2/clip-video/venv/bin/devpi-server --host=0.0.0.0 --p&gt;</span><br><span class="line"></span><br><span class="line">Sep 17 07:19:23 czq2 devpi-server[1619813]: 2025-09-17 07:19:23,634 WARNI NOCTX No secret file provided, creating a new rand&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,757 INFO  [ASYN] Starting asyncio event loop</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX devpi-server version: 6.17.0</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serverdir: /home/czq2/.devpi/server</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX uuid: 0c7aa3d0d1874fd596c8936cd007d305</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serving at url: http://0.0.0.0:3141 (might b&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX using 50 threads</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX bug tracker: https://github.com/devpi/devpi/&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX Hit Ctrl-C to quit.</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,785 INFO  Serving on http://0.0.0.0:3141</span><br></pre></td></tr></table></figure><ul><li>错误分析</li></ul> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u devpi.service -n 50 --no-pager</span><br></pre></td></tr></table></figure><h3 id="第三章：构建护城河-Nginx高可用反向代理">第三章：构建护城河 - Nginx高可用反向代理</h3><p>现在，我们要为 <code>devpi</code> 构建一个坚固的前哨站，让它不再直接依赖任何单一的上游源。</p><h4 id="步骤-1-安装-Nginx">步骤 1: 安装 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nginx</span><br></pre></td></tr></table></figure><h4 id="步骤-2-编写Nginx高可用配置">步骤 2: 编写Nginx高可用配置</h4><p>这是实现自动故障转移的<strong>核心</strong>。</p><ol><li><p><strong>创建Nginx配置文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/sites-available/pypi-proxy</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下魔法配置</strong>:</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /etc/nginx/sites-available/pypi-proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义一个上游服务器组，这次全部使用 HTTPS</span></span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> pypi_mirrors_https &#123;</span><br><span class="line">    <span class="comment"># 【核心修改】直接指向 HTTPS 域名，端口 443 是默认的，可以不写</span></span><br><span class="line">    <span class="attribute">server</span> pypi.tuna.tsinghua.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.aliyun.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> pypi.mirrors.ustc.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.cloud.tencent.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> repo.huaweicloud.com:<span class="number">443</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 【核心修改】将请求代理到我们新的 HTTPS 服务器组</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 故障转移的配置保持不变</span></span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 【重要】当代理到 HTTPS 上游时，必须正确设置 Host 头</span></span><br><span class="line">        <span class="comment"># 这里的 $host 会是上游服务器组的名称，为了正确性，我们应该传递原始请求的Host</span></span><br><span class="line">        <span class="comment"># 或者直接硬编码为 pypi.tuna.tsinghua.edu.cn 等，但传递原始Host更灵活</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>; <span class="comment"># 使用 $proxy_host 变量</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># （可选，但推荐）增加 SSL 相关的代理设置</span></span><br><span class="line">        <span class="attribute">proxy_ssl_server_name</span> <span class="literal">on</span>; <span class="comment"># 这会让Nginx在TLS握手中发送正确的服务器名称(SNI)</span></span><br><span class="line">        <span class="attribute">proxy_ssl_session_reuse</span> <span class="literal">on</span>; <span class="comment"># 启用SSL会话复用以提高性能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>启用配置并重启Nginx</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /etc/nginx/sites-available/pypi-proxy /etc/nginx/sites-enabled/</span><br><span class="line"><span class="built_in">sudo</span> nginx -t          <span class="comment"># 测试配置语法</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nginx <span class="comment"># 重启Nginx</span></span><br></pre></td></tr></table></figure>现在，一个强大的、能自动切换源的反向代理已经在 <code>http://192.168.10.158:8088</code> 上为你待命。</li></ol><hr><h3 id="第四章：合体！将Devpi接入Nginx代理">第四章：合体！将Devpi接入Nginx代理</h3><p>万事俱备，只差最后一步：让 <code>devpi</code> 通过我们的 Nginx “护城河”去访问世界。</p><ol><li><p><strong>停止Devpi服务</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop devpi</span><br></pre></td></tr></table></figure></li><li><p><strong>修改Devpi的启动参数</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p>在 <code>ExecStart</code> 行的末尾，添加 <code>--mirror-url</code> 参数，指向我们的Nginx代理：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">ExecStart</span>=/home/your_username/.local/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span> --mirror-url http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">8088</span>/pypi</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重新加载并启动Devpi</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="第五章：享受成果-配置客户端">第五章：享受成果 - 配置客户端</h3><p>现在，让团队的所有开发者和CI/CD服务器都享受到这个稳定高速的镜像源吧！</p><p>在每一台客户端机器上，创建或修改 <code>~/.pip/pip.conf</code> (macOS/Linux) 或 <code>%APPDATA%\pip\pip.ini</code> (Windows) 文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">3141</span>/root/pypi/</span><br><span class="line"><span class="attr">trusted-host</span> = <span class="number">192.168</span>.<span class="number">10.158</span></span><br></pre></td></tr></table></figure><ul><li><code>index-url</code> 指向我们搭建的 <code>devpi</code> 服务。</li><li><code>trusted-host</code> 告诉 <code>pip</code> 这是一个可信任的HTTP源。</li></ul><h3 id="使用docker-compose-搭建-devpi">使用docker compose 搭建 devpi</h3><ul><li>docker-comose.yml</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 属性已过时，可以移除</span></span><br><span class="line"><span class="comment"># version: &quot;2.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务1：高可用 Nginx 反向代理</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们的 stream 配置文件挂载到容器中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="comment"># 这个服务只在内部使用，不需要暴露端口到宿主机</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务2：Devpi 服务器</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lowinli98/devpi:v0.2</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7104</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_HOST=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PORT=7104</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_ROOT_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_USER=czq</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_MIRROR_INDEX=pypi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_LIB_INDEX=devpi</span></span><br><span class="line">      <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">      <span class="comment"># 将上游镜像源指向我们内部的 nginx-proxy 服务的 443 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SOURCE_MIRROR_URL=http://nginx-proxy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="comment"># 【重要】确保 devpi 服务依赖于 nginx-proxy 服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br></pre></td></tr></table></figure><ul><li>nignx conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># nginx_conf/nginx.conf (HTTP 代理版本)</span><br><span class="line"></span><br><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 定义高可用的 PyPI 镜像上游服务器池</span><br><span class="line">    upstream pypi_mirrors_https &#123;</span><br><span class="line">        server pypi.tuna.tsinghua.edu.cn:443;</span><br><span class="line">        server mirrors.aliyun.com:443;</span><br><span class="line">        server pypi.mirrors.ustc.edu.cn:443;</span><br><span class="line">        server mirrors.cloud.tencent.com:443;</span><br><span class="line">        server pypi.douban.com:443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听容器内部的 80 端口，接收来自 devpi-lib 的 HTTP 请求</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # 将请求代理到 HTTPS 上游</span><br><span class="line">            proxy_pass https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">            # --- 代理核心配置 ---</span><br><span class="line">            proxy_next_upstream error timeout http_502 http_503 http_504;</span><br><span class="line">            proxy_connect_timeout 10s;</span><br><span class="line"></span><br><span class="line">            # --- 关键的请求头与 SSL/TLS 配置 ---</span><br><span class="line">            proxy_set_header Host $proxy_host;</span><br><span class="line">            proxy_ssl_server_name on;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_ssl_session_reuse on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>docker run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build</span><br></pre></td></tr></table></figure><h3 id="自建devpi镜像">自建devpi镜像</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终稳定版)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个官方的、轻量级的 Python 3.9 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【构建时网络优化】</span></span><br><span class="line"><span class="comment"># 将 pip 的默认源设置为高速的镜像源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【核心 Bug 修复 &amp; 版本锁定】 ---</span></span><br><span class="line"><span class="comment"># 安装应用程序及其依赖，并锁定所有核心组件的版本</span></span><br><span class="line"><span class="comment"># devpi-server 6.9.x 是一个非常稳定的系列</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据卷挂载点</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【权限修复】</span></span><br><span class="line"><span class="comment"># 将数据目录的所有者更改为非 root 用户 (UID 1000)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R 1000:1000 /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【安全实践】</span></span><br><span class="line"><span class="comment"># 将容器的默认运行用户切换为非 root 用户</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明容器将要监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动时要执行的默认命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;devpi-server&quot;</span>, <span class="string">&quot;--serverdir&quot;</span>, <span class="string">&quot;/var/lib/devpi&quot;</span>, <span class="string">&quot;--host&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7104&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (最终、决定性版本)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">    <span class="comment"># 不再使用旧的 image，而是使用 build 指令</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 表示使用当前目录下的 Dockerfile 来构建镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="comment"># 【重要】我们不再需要旧镜像的环境变量来自动化配置</span></span><br><span class="line">    <span class="comment"># 我们将在启动后，手动进行一次性配置，这更可靠</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">        <span class="comment"># environment:</span></span><br><span class="line">    <span class="comment">#   - ... (可以全部删除)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 数据卷依然需要，用于持久化 devpi 的数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol><li><strong>在你的客户端电脑上，安装 <code>devpi-client</code></strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R czq2:czq2 ./volume <span class="comment"># 更改目录权限</span></span><br><span class="line">pip install devpi-client</span><br></pre></td></tr></table></figure></li><li><ol start="2"><li><strong>登录到你的新 <code>devpi</code> 服务器</strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指向服务器</span></span><br><span class="line">devpi use http://&lt;你的服务器IP&gt;:7104</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次登录 root 用户，devpi-server 会自动创建，无需密码</span></span><br><span class="line"><span class="comment"># 然后会强制你设置新密码</span></span><br><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># (按照提示输入你的新 root 密码)</span></span><br></pre></td></tr></table></figure></li><li><ol start="3"><li><strong>【关键】配置 <code>root/pypi</code> 镜像</strong>:<br>默认的 <code>root/pypi</code> 指向 <code>pypi.org</code>。我们需要将它修改为指向我们内部的 <code>nginx-proxy</code>。</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保你已登录 root</span></span><br><span class="line">devpi index root/pypi mirror_url=http://nginx-proxy</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>: 这里的 <code>http://nginx-proxy</code> 是 <code>devpi-lib</code> 容器内部访问 <code>nginx-proxy</code> 容器的地址。<code>devpi-server</code> 在收到这个配置后，它内部发起的请求就会走这条路。</li></ul></li><li><ol start="4"><li><strong>验证</strong>:<br>在你的客户端电脑上，配置好 <code>pip</code> 指向 <code>http://&lt;服务器IP&gt;:7104/root/pypi/</code>，然后执行 <code>pip install numpy</code>。</li></ol></li></ul><h3 id="成功日志">成功日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(.venv) czq2@czq2:~/pypi-docker$ sudo docker logs devpi-lib</span><br><span class="line">2025-09-22 02:56:36,728 INFO  [req12] POST /+login</span><br><span class="line">2025-09-22 02:57:08,329 INFO  [req13] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:08,339 INFO  [req14] PATCH /root/pypi</span><br><span class="line">2025-09-22 02:57:08,342 INFO  [req14] [Wtx13] modified index root/pypi: &#123;&#x27;type&#x27;: &#x27;mirror&#x27;, &#x27;volatile&#x27;: False, &#x27;title&#x27;: &#x27;PyPI&#x27;, &#x27;mirror_url&#x27;: &#x27;http://mirrors.aliyun.com/pypi/simple/&#x27;, &#x27;mirror_web_url_fmt&#x27;: &#x27;https://pypi.org/project/&#123;name&#125;/&#x27;&#125;</span><br><span class="line">2025-09-22 02:57:08,345 INFO  [req14] [Wtx13] fswriter14: committed at 14</span><br><span class="line">2025-09-22 02:57:08,351 INFO  [req15] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:25,788 INFO  [req16] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:40,843 INFO  [req17] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:41,058 INFO  [req18] GET /root</span><br><span class="line">2025-09-22 02:57:41,533 INFO  [req19] GET /+static-4.1.0/favicon.ico</span><br><span class="line">2025-09-22 02:57:43,732 INFO  [Wtx14] fswriter15: committed at 15</span><br><span class="line">2025-09-22 02:57:43,885 INFO  [NOTI] [Rtx15] indexing &#x27;root/pypi&#x27; mirror with 658356 projects</span><br><span class="line">2025-09-22 02:57:44,305 INFO  [IDX] Indexer queue size ~ 2</span><br><span class="line">2025-09-22 02:57:46,680 INFO  [req20] GET /root</span><br><span class="line">2025-09-22 02:57:47,303 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:57:47,410 INFO  [req21] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:48,180 INFO  [req22] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:48,183 INFO  [req22] starting +simple</span><br><span class="line">2025-09-22 02:57:52,640 INFO  [req23] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:52,643 INFO  [req23] starting +simple</span><br><span class="line">2025-09-22 02:58:00,856 INFO  [IDX] Indexer queue size ~ 23</span><br><span class="line">2025-09-22 02:58:03,872 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:13,593 INFO  [IDX] Indexer queue size ~ 43</span><br><span class="line">2025-09-22 02:58:16,637 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:24,550 INFO  [IDX] Indexer queue size ~ 63</span><br><span class="line">2025-09-22 02:58:27,063 INFO  [req24] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:58:27,068 INFO  [req24] starting +simple</span><br><span class="line">2025-09-22 02:58:31,043 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:36,905 INFO  [IDX] Indexer queue size ~ 84</span><br><span class="line">2025-09-22 02:58:40,109 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:46,493 INFO  [IDX] Indexer queue size ~ 105</span><br><span class="line">2025-09-22 02:58:49,808 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:57,171 INFO  [req25] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:58:57,452 INFO  [req26] GET /root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:57,703 INFO  [req26] [Rtx15] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/68/1f/795e7f4aa2eacc59afa4fb61a2e35e510d06414dd5a802b51a012d691b37/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl&#x27;), target root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:58,698 INFO  [IDX] Indexer queue size ~ 125</span><br><span class="line">2025-09-22 02:59:02,452 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:13,134 INFO  [Wtx15] fswriter16: committed at 16</span><br><span class="line">2025-09-22 02:59:13,406 INFO  [req27] GET /root/pypi/numpy/</span><br><span class="line">2025-09-22 02:59:16,152 INFO  [IDX] Indexer queue size ~ 144</span><br><span class="line">2025-09-22 02:59:20,559 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:22,506 INFO  [Wtx16] fswriter17: committed at 17</span><br><span class="line">2025-09-22 02:59:22,974 INFO  [req28] GET /root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:23,201 INFO  [req28] [Rtx17] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/8c/3d/1e1db36cfd41f895d266b103df00ca5b3cbe965184df824dec5c08c6b803/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl&#x27;), target root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:25,317 INFO  [Wtx17] fswriter18: committed at 18</span><br><span class="line">2025-09-22 02:59:29,854 INFO  [IDX] Indexer queue size ~ 157</span><br><span class="line">2025-09-22 02:59:32,438 INFO  [req29] GET /czq/devpi</span><br><span class="line">2025-09-22 02:59:33,214 INFO  [req30] GET /czq/devpi/+simple/</span><br><span class="line">2025-09-22 02:59:33,219 INFO  [req30] starting +simple</span><br><span class="line">2025-09-22 02:59:33,222 WARNI [req30] [Rtx18] Index czq/devpi refers to non-existing base czq/pypi.</span><br><span class="line">2025-09-22 02:59:33,419 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:35,333 INFO  [req31] GET /root/dev</span><br><span class="line">2025-09-22 02:59:36,071 INFO  [req32] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:59:36,073 INFO  [req32] starting +simple</span><br><span class="line">2025-09-22 02:59:45,543 INFO  [IDX] Indexer queue size ~ 183</span><br><span class="line">2025-09-22 02:59:49,092 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:59,191 INFO  [IDX] Indexer queue size ~ 204</span><br><span class="line">2025-09-22 02:59:59,375 INFO  [req33] GET /</span><br><span class="line">2025-09-22 03:00:02,409 INFO  [req34] GET /+search</span><br><span class="line">2025-09-22 03:00:03,190 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:12,782 INFO  [IDX] Indexer queue size ~ 223</span><br><span class="line">2025-09-22 03:00:16,424 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:22,925 INFO  [IDX] Indexer queue size ~ 243</span><br></pre></td></tr></table></figure><h2 id="python-搭建高可用">python 搭建高可用</h2><ul><li>python flask</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ha_proxy.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response, request</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 高可用镜像源列表 ---</span></span><br><span class="line"><span class="comment"># 将按照这个顺序尝试。可以随意增删或调整顺序。</span></span><br><span class="line">UPSTREAM_MIRRORS = [</span><br><span class="line">    <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.aliyun.com/pypi/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://pypi.mirrors.ustc.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.cloud.tencent.com/pypi/simple&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接和读取的超时时间（秒）</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proxy</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收来自 devpi-server 的所有请求，并尝试从上游镜像列表中获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> base_url <span class="keyword">in</span> UPSTREAM_MIRRORS:</span><br><span class="line">        url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Attempting to fetch from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># `requests` 会自动使用 HTTP_PROXY/HTTPS_PROXY 环境变量</span></span><br><span class="line">            response = requests.get(url, timeout=TIMEOUT, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果请求成功 (例如 200 OK)</span></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Success from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 使用流式响应，避免大文件占用过多内存</span></span><br><span class="line">                <span class="keyword">return</span> Response(response.iter_content(chunk_size=<span class="number">8192</span>),</span><br><span class="line">                                status=response.status_code,</span><br><span class="line">                                content_type=response.headers[<span class="string">&#x27;Content-Type&#x27;</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是 404，说明这个源没有这个包，立即尝试下一个</span></span><br><span class="line">            <span class="keyword">elif</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got 404 from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                 <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 其他客户端错误，也尝试下一个</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got client error <span class="subst">&#123;response.status_code&#125;</span> from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 捕获所有网络层面的错误 (如超时、连接失败)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Failed to connect to <span class="subst">&#123;base_url&#125;</span>. Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果所有镜像源都尝试失败</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: All upstream mirrors failed for path: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&quot;All upstream mirrors failed.&quot;</span>, status=<span class="number">502</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 监听在 8000 端口，只接受来自容器内部的连接</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><ul><li>supervisord.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; supervisord.conf (最终生产版)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon=true</span><br><span class="line"></span><br><span class="line">[program:devpi]</span><br><span class="line">command=devpi-server --serverdir /var/lib/devpi --host 0.0.0.0 --port 7104</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/devpi_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/devpi_out.log</span><br><span class="line"></span><br><span class="line">[program:ha_proxy]</span><br><span class="line">command=python3 /app/ha_proxy.py</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/ha_proxy_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/ha_proxy_out.log</span><br></pre></td></tr></table></figure><h3 id="同步更新dockerfile和docker-compose-yml">同步更新dockerfile和docker-compose.yml</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终生产版)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list.d/debian.sources</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【关键修复】创建一个专用的非 root 用户 ---</span></span><br><span class="line"><span class="comment"># 创建一个名为 devpiuser 的系统组和用户，并指定其 ID 为 1000</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> adduser \</span></span><br><span class="line"><span class="language-bash">    --system \</span></span><br><span class="line"><span class="language-bash">    --group \</span></span><br><span class="line"><span class="language-bash">    --uid 1000 \</span></span><br><span class="line"><span class="language-bash">    --no-create-home \</span></span><br><span class="line"><span class="language-bash">    --disabled-password \</span></span><br><span class="line"><span class="language-bash">    devpiuser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 安装所有依赖 ---</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y supervisor &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;flask&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;requests&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 复制配置文件和脚本 ---</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ha_proxy.py /app/ha_proxy.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 权限修复 ---</span></span><br><span class="line"><span class="comment"># 使用新创建的用户名 devpiuser 来设置权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /var/log/supervisor</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/log/supervisor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器将以 root 启动，由 supervisor 负责降权</span></span><br><span class="line"><span class="comment"># USER devpiuser (这里不需要，supervisor 会处理)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/supervisord&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (与最终高可用版 Dockerfile 配合使用)</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">devpi-data:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 代理配置依然需要，ha_proxy.py 会使用它</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">devpi-data:</span></span><br></pre></td></tr></table></figure><ul><li>docker build</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build --force-recreate</span><br></pre></td></tr></table></figure><ul><li>mirror set</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将 mirror_url 指向我们内部的 HA 代理服务</span></span><br><span class="line">devpi index root/pypi mirror_url=http://127.0.0.1:8000/</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li><ol><li><a href="https://github.com/devpi/devpi">https://github.com/devpi/devpi</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Devpi与Nginx构建高可用PyPI镜像源&quot;&gt;使用Devpi与Nginx构建高可用PyPI镜像源&lt;/h2&gt;
&lt;h3 id=&quot;前言：为什么你的pip-install又超时了？&quot;&gt;前言：为什么你的&lt;code&gt;pip install&lt;/code&gt;又超时了？&lt;/h</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker Compose 快速部署 Shadowsocks 代理服务教程</title>
    <link href="https://caozhaoqi.github.io/2025/08/29/ss-build-doc/"/>
    <id>https://caozhaoqi.github.io/2025/08/29/ss-build-doc/</id>
    <published>2025-08-29T01:06:20.000Z</published>
    <updated>2025-11-25T15:05:10.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境">基础环境</h2><h4 id="1-1-更新系统软件包列表">1.1 更新系统软件包列表</h4><p>首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br></pre></td></tr></table></figure><p>d</p><h4 id="1-2-安装-Docker-的依赖项">1.2 安装 Docker 的依赖项</h4><p>接下来，安装一些必要的软件包，以允许 <code>apt</code> 通过 HTTPS 使用 Docker 的软件仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h4 id="1-3-添加-Docker-官方-GPG-密钥">1.3 添加 Docker 官方 GPG 密钥</h4><p>为了安全起见，我们需要添加 Docker 的官方 GPG 密钥。这会验证我们下载的 Docker 软件包是官方发布的，未经篡改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于存放密钥的目录</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Docker 的 GPG 密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密钥文件的权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure><h4 id="1-4-设置-Docker-的-APT-软件源">1.4 设置 Docker 的 APT 软件源</h4><p>现在，我们将 Docker 的官方软件源地址添加到我们系统的源列表中。这样，<code>apt</code> 命令就能找到并安装 Docker 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 1.5 安装 Docker 引擎和 Compose V2</span></span><br><span class="line"></span><br><span class="line">再次更新软件包列表，以包含来自 Docker 官方源的软件包信息，然后执行安装：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 再次更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker 引擎, 命令行工具, containerd 和 Docker Compose V2 插件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="1-6-可选但推荐-配置非-root-用户运行-Docker">1.6 (可选但推荐) 配置非 root 用户运行 Docker</h4><p>每次都输入 <code>sudo</code> 来运行 Docker 命令很麻烦。我们可以将当前用户添加到 <code>docker</code> 用户组，从而免去 <code>sudo</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将您的用户（$USER 是一个环境变量，代表当前用户）添加到 docker 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong> 执行此命令后，您需要<strong>完全退出 SSH 会话并重新登录</strong>，才能使权限更改生效！</p><hr><h3 id="第二步：配置并部署-Shadowsocks-服务">第二步：配置并部署 Shadowsocks 服务</h3><p>环境准备好后，我们就可以开始定义和部署我们的 Shadowsocks 服务了。</p><h4 id="2-1-创建一个工作目录">2.1 创建一个工作目录</h4><p>为我们的项目创建一个专门的目录，这样可以保持整洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 ss 的目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/ss</span><br><span class="line"><span class="built_in">cd</span> ~/ss</span><br></pre></td></tr></table></figure><h4 id="2-2-编写-docker-compose-yml-配置文件">2.2 编写 <code>docker-compose.yml</code> 配置文件</h4><p>这是整个部署的核心。我们将创建一个名为 <code>docker-compose.yml</code> 的文件，它像一份蓝图，详细描述了我们的服务应该如何运行。</p><p>使用您喜欢的文本编辑器（这里以 <code>nano</code> 为例，它比 <code>vim</code> 更易上手）创建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>然后，将以下内容<strong>复制并粘贴</strong>到编辑器中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Compose 文件格式的版本 3</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义所有服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义一个名为 &quot;shadowsocks&quot; 的服务</span></span><br><span class="line">  <span class="attr">shadowsocks:</span></span><br><span class="line">    <span class="comment"># 指定要使用的 Docker 镜像，我们使用官方的 shadowsocks-libev</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shadowsocks/shadowsocks-libev</span></span><br><span class="line">    <span class="comment"># 给运行的容器起一个固定的名字，方便我们管理</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">shadowsocks</span></span><br><span class="line">    <span class="comment"># 设置端口映射 (格式: &quot;主机端口:容器端口&quot;)</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 将服务器的 TCP 8388 端口映射到容器的 TCP 8388 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/tcp&quot;</span></span><br><span class="line">      <span class="comment"># 将服务器的 UDP 8388 端口也映射出去 (用于游戏、视频通话等)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/udp&quot;</span></span><br><span class="line">    <span class="comment"># 设置容器的重启策略</span></span><br><span class="line">    <span class="comment"># unless-stopped: 除非我们手动停止容器，否则它总是在退出后自动重启</span></span><br><span class="line">    <span class="comment"># (包括服务器重启后，服务也会自动拉起，非常省心)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="comment"># 设置容器内的环境变量，用于配置 Shadowsocks</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 设置加密方法，chacha20-ietf-poly1305 是目前推荐的安全且高效的算法</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">METHOD=chacha20-ietf-poly1305</span></span><br><span class="line">      <span class="comment"># 在这里设置您的连接密码！请务必替换成一个您自己的强密码！</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PASSWORD=YOUR_STRONG_PASSWORD_HERE</span></span><br></pre></td></tr></table></figure><p><strong>重要配置修改：</strong></p><ul><li><strong><code>PASSWORD</code></strong>: 将 <code>YOUR_STRONG_PASSWORD_HERE</code> <strong>替换为您自己设定的一个强密码</strong>。这是您的客户端连接时需要用到的凭证。</li><li><strong><code>ports</code></strong>: 如果您服务器的 <code>8388</code> 端口已被其他服务占用，您可以修改主机端口。例如，改成 <code>&quot;10086:8388/tcp&quot;</code>，这样您的客户端就需要连接服务器的 <code>10086</code> 端口。</li></ul><p>修改完成后，在 <code>nano</code> 编辑器中，按 <code>Ctrl + X</code>，然后按 <code>Y</code>，最后按 <code>Enter</code> 保存并退出。</p><h4 id="2-3-启动-Shadowsocks-服务">2.3 启动 Shadowsocks 服务</h4><p>现在，激动人心的时刻到了！在 <code>docker-compose.yml</code> 文件所在的目录（即 <code>~/ss</code>），运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：如果您在 1.6 步中配置了用户组，这里就不需要 sudo 了</span></span><br><span class="line"><span class="comment"># 新版命令 (推荐)</span></span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版命令 (也能工作)</span></span><br><span class="line"><span class="comment"># docker-compose up -d</span></span><br></pre></td></tr></table></figure><ul><li><code>up</code>: 告诉 Docker Compose 启动并运行服务。</li><li><code>-d</code>: (<code>--detach</code>) 参数表示在后台运行服务。这是必须的，否则当您关闭 SSH 窗口时，服务也会停止。</li></ul><p>Docker Compose 现在会自动：</p><ol><li>检查 <code>docker-compose.yml</code> 文件。</li><li>从 Docker Hub 上拉取 <code>shadowsocks/shadowsocks-libev</code> 镜像（如果是第一次运行）。</li><li>根据您的配置创建并启动一个名为 <code>shadowsocks</code> 的容器。</li></ol><hr><h3 id="第三步：验证服务与客户端配置">第三步：验证服务与客户端配置</h3><blockquote><p>服务启动后，我们需要确认它是否正常运行，并配置客户端进行连接。</p></blockquote><h4 id="3-1-检查容器运行状态">3.1 检查容器运行状态</h4><p>运行以下命令查看当前正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>您应该能看到类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS         PORTS                                                 NAMES</span><br><span class="line">a1b2c3d4e5f6   shadowsocks/shadowsocks-libev   &quot;/usr/bin/ss-server …&quot;   30 seconds ago   Up 29 seconds   0.0.0.0:8388-&gt;8388/tcp, 0.0.0.0:8388-&gt;8388/udp   shadowsocks</span><br></pre></td></tr></table></figure><p>请关注以下几点：</p><ul><li><strong><code>IMAGE</code></strong>: 确认是 <code>shadowsocks/shadowsocks-libev</code>。</li><li><strong><code>STATUS</code></strong>: 必须是 <code>Up ...</code>，表示正在健康运行。如果是 <code>Exited</code>，说明启动失败。</li><li><strong><code>PORTS</code></strong>: 确认端口映射正确。</li><li><strong><code>NAMES</code></strong>: 确认是 <code>shadowsocks</code>。</li></ul><h4 id="3-2-查看服务日志">3.2 查看服务日志</h4><p>如果容器启动失败，或者您想确认服务的内部运行情况，查看日志是最佳方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs shadowsocks</span><br></pre></td></tr></table></figure><p>成功的日志会显示服务正在监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO: initializing ciphers... chacha20-ietf-poly1305</span><br><span class="line">INFO: listening at 0.0.0.0:8388</span><br></pre></td></tr></table></figure><h4 id="3-3-配置您的客户端">3.3 配置您的客户端</h4><p>现在，您可以在您的电脑或手机上配置 Shadowsocks 客户端了。填入以下信息：</p><ul><li><strong>服务器地址 (Server Address)</strong>: <code>您服务器的公网 IP 地址</code></li><li><strong>服务器端口 (Server Port)</strong>: <code>8388</code> (或者您在 <code>docker-compose.yml</code> 中设置的主机端口)</li><li><strong>密码 (Password)</strong>: <code>您在 docker-compose.yml 中设置的密码</code></li><li><strong>加密方法 (Encryption/Method)</strong>: <code>chacha20-ietf-poly1305</code></li></ul><p>保存配置并连接，现在您应该可以正常使用了！</p><hr><h3 id="第四步：常用管理命令">第四步：常用管理命令</h3><ul><li><strong>停止服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure></li><li><strong>重启服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose restart</span><br></pre></td></tr></table></figure></li><li><strong>更新服务 (例如更新 Shadowsocks 镜像)</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line"><span class="comment"># 1. 拉取最新的镜像</span></span><br><span class="line">docker compose pull</span><br><span class="line"><span class="comment"># 2. 重新创建并启动容器</span></span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure></li></ul><h2 id="客户端">客户端</h2><ul><li>windows</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-windows</span><br></pre></td></tr></table></figure><ul><li>android</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-android</span><br></pre></td></tr></table></figure><h2 id="代理模式">代理模式</h2><ul><li><p>禁用 (Disabled)：不使用代理。等同于取消勾选“启用系统代理”。</p></li><li><p>PAC 模式 (PAC)：推荐日常使用。此模式下，客户端会根据一个名为 PAC (Proxy Auto-Config) 的规则列表来判断。</p></li><li><p>全局模式 (Global)：所有网络流量都强制通过代理服务器。</p></li></ul><h2 id="See">See</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-rust">https://github.com/shadowsocks/shadowsocks-rust</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows">https://github.com/shadowsocks/shadowsocks-windows</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础环境&quot;&gt;基础环境&lt;/h2&gt;
&lt;h4 id=&quot;1-1-更新系统软件包列表&quot;&gt;1.1 更新系统软件包列表&lt;/h4&gt;
&lt;p&gt;首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PyAV用于视频剪辑处理</title>
    <link href="https://caozhaoqi.github.io/2025/08/14/pyav-use-video/"/>
    <id>https://caozhaoqi.github.io/2025/08/14/pyav-use-video/</id>
    <published>2025-08-14T10:54:52.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h1>PyAV用于视频剪辑处理</h1><blockquote><p>PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：</p></blockquote><ul><li><strong>内存操作</strong>：直接在内存中处理视频帧和音频样本，无需创建大量临时文件。</li><li><strong>精细控制</strong>：你可以完全控制容器的解复用、数据包的解码、帧的处理和编码的每一个环节。</li><li><strong>硬件加速</strong>：可以利用GPU（如macOS的VideoToolbox, Linux/Windows的CUDA/NVENC）来极大地加速解码和编码过程。</li><li><strong>高度集成</strong>：可以无缝地将视频帧与NumPy、Pillow等流行的Python库结合使用。</li></ul><h3 id="PyAV的核心概念">PyAV的核心概念</h3><blockquote><p>在深入代码之前，我们先了解几个核心概念，它们直接映射自FFmpeg：</p></blockquote><ol><li><strong>容器 (Container)</strong>: 指的是视频文件本身，比如一个<code>.mp4</code>或<code>.mkv</code>文件。它是一个“容器”，里面装着各种数据流。</li><li><strong>流 (Stream)</strong>: 指的是容器内的数据轨道。一个视频文件通常至少包含一个视频流和一个音频流，有时还会有字幕流。</li><li><strong>数据包 (Packet)</strong>: 从流中读取的一小块<strong>压缩后</strong>的数据。</li><li><strong>帧 (Frame)</strong>: 一个数据包经过<strong>解码后</strong>得到的数据。对于视频流，它是一张图片；对于音频流，它是一段声音样本。</li></ol><blockquote><p>标准的处理流程是：<strong>打开容器 → 找到需要的流 → 从流中解复用(demux)数据包 → 解码(decode)数据包得到帧 → (处理帧) → 编码(encode)处理后的帧变回数据包 → 将数据包混合(mux)到新的输出容器 → 关闭容器</strong>。</p></blockquote><h2 id="简单安装">简单安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install av</span><br><span class="line">conda install av -c conda-forge</span><br></pre></td></tr></table></figure><h3 id="功能">功能</h3><ul><li><p>libavformat: containers, audio/video/subtitle streams, packets;</p></li><li><p>libavdevice (by specifying a format to containers);</p></li><li><p>libavcodec: Codec, CodecContext, BitStreamFilterContext, audio/video frames, data planes, subtitles;</p></li><li><p>libavfilter: Filter, Graph;</p></li><li><p>libswscale: VideoReformatter;</p></li><li><p>libswresample: AudioResampler;</p></li></ul><h3 id="simple-demo">simple demo</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> av</span><br><span class="line"></span><br><span class="line">av.logging.set_level(av.logging.VERBOSE)</span><br><span class="line">container = av.<span class="built_in">open</span>(path_to_video)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, frame <span class="keyword">in</span> <span class="built_in">enumerate</span>(container.decode(video=<span class="number">0</span>)):</span><br><span class="line">    frame.to_image().save(<span class="string">f&quot;frame-<span class="subst">&#123;index:04d&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 调度器函数 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params">input_video_path, output_video_path, ...</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查硬件加速是否受支持</span></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速</span></span><br><span class="line">            logger.info(<span class="string">&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(...)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                <span class="comment"># 如果硬件路径明确返回失败，则降级</span></span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(...)</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 如果硬件路径意外崩溃，则降级</span></span><br><span class="line">            logger.error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(...)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(...)</span><br></pre></td></tr></table></figure><p>接下来，我们将深入分析这两种核心实现。</p><h3 id="Part-1-健壮的基石-——-纯软件-CPU-实现">Part 1: 健壮的基石 —— 纯软件 (CPU) 实现</h3><p>这是我们后备方案的核心，也是理解PyAV基础操作的最佳入口。它不依赖任何特殊的硬件，可以在任何平台上运行。</p><h4 id="核心步骤">核心步骤</h4><ol><li><p><strong>参数准备</strong>:<br>最关键的一步是确保输出的分辨率永远是偶数。像 <code>libx264</code> 这样的H.264编码器无法处理宽度或高度为奇数的视频。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final_w = w - (w % <span class="number">2</span>)</span><br><span class="line">final_h = h - (h % <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>打开输入/输出容器</strong>:<br>使用 <code>av.open()</code>，就像Python内置的 <code>open()</code> 一样简单，但它可以同时用于读和写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">    <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建输出流</strong>:<br>最简单的方式是从输入流创建模板。这会自动复制编解码器、码率等大部分参数。然后我们再手动覆盖需要修改的参数，比如新的宽度和高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有输入流</span></span><br><span class="line">in_video_stream = in_container.streams.video[<span class="number">0</span>]</span><br><span class="line">in_audio_stream = in_container.streams.audio[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从模板创建输出流</span></span><br><span class="line">out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">out_audio_stream = out_container.add_stream_from_template(in_audio_stream)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖视频流的尺寸</span></span><br><span class="line">out_video_stream.width = final_w</span><br><span class="line">out_video_stream.height = final_h</span><br></pre></td></tr></table></figure></li><li><p><strong>核心处理循环</strong>:<br>这是最精彩的部分，完美体现了PyAV与Pillow的结合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">            <span class="comment"># a. 解码帧并转换为Pillow Image对象</span></span><br><span class="line">            img = frame.to_image()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># b. 使用Pillow的强大功能进行图像处理</span></span><br><span class="line">            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line">            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># c. 将处理后的Pillow Image转换回PyAV的VideoFrame</span></span><br><span class="line">            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># d. 编码新帧并混合到输出文件</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">        <span class="comment"># 音频直通：不解码，直接复制数据包，效率最高</span></span><br><span class="line">        packet.stream = out_audio_stream</span><br><span class="line">        out_container.mux(packet)</span><br></pre></td></tr></table></figure></li><li><p><strong>冲洗 (Flush) 编码器</strong>:<br>处理完所有帧后，编码器的内部可能还缓存着一些数据。我们通过发送一个 <code>None</code> 来告诉它结束编码，并清空所有缓冲区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">    out_container.mux(out_packet)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Part-2-极致性能-——-Metal硬件加速-GPU-实现">Part 2: 极致性能 —— Metal硬件加速 (GPU) 实现</h3><p>这是脚本的“高性能模式”，专门为macOS设计。它尽可能地将所有操作都留在GPU上，避免了昂贵的CPU&lt;-&gt;GPU数据拷贝。</p><h4 id="核心步骤-2">核心步骤</h4><ol><li><p><strong>创建硬件设备上下文</strong>:<br>这是开启硬件加速的第一步，我们告诉PyAV我们要使用苹果的 <code>videotoolbox</code> 框架。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>配置硬件解码</strong>:<br>这是现代PyAV中配置硬件解码的关键。我们不是手动设置上下文，而是为输入流的 <code>codec_context</code> 提供一个 <code>get_format</code> 回调函数。当解码器准备好时，它会调用这个函数并提供一个它支持的像素格式列表。我们的函数只需从中选择 <code>'videotoolbox'</code> 格式即可。这告诉解码器：“请直接将帧解码到GPU显存中，不要下载到CPU内存。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">    <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">        <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">            <span class="keyword">return</span> fmt</span><br><span class="line">    <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">&quot;未找到 &#x27;videotoolbox&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">in_stream.codec_context.get_format = get_hw_format</span><br></pre></td></tr></table></figure></li><li><p><strong>构建硬件滤镜图 (Filter Graph)</strong>:<br>裁剪和缩放是通过FFmpeg的滤镜系统完成的。PyAV允许我们用代码构建这个处理链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">buffer_src = graph.add_buffer(template=in_stream) <span class="comment"># 输入源</span></span><br><span class="line">buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>) <span class="comment"># 输出汇</span></span><br><span class="line"></span><br><span class="line">filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;...&#125;</span>,scale=<span class="subst">&#123;...&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：源 -&gt; 滤镜链 -&gt; 汇</span></span><br><span class="line">filters = graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>)</span><br><span class="line">buffer_src.link_to(filters)</span><br><span class="line">filters.link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">graph.configure()</span><br></pre></td></tr></table></figure><p>这里最巧妙的是，即使 <code>crop</code> 和 <code>scale</code> 滤镜是纯CPU操作，FFmpeg也会在后台<strong>自动</strong>处理硬件帧的下载（GPU-&gt;CPU）、应用滤镜、再上传（CPU-&gt;GPU）的过程。</p></li><li><p><strong>配置硬件编码</strong>:<br>我们创建一个使用 <code>h264_videotoolbox</code> 编码器的输出流。它会自动接收来自滤镜图的、已经处理好的帧（这些帧可能在CPU上，也可能在GPU上，编码器会自动处理）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out_stream = out_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">out_stream.width = final_w</span><br><span class="line">out_stream.height = final_h</span><br><span class="line">out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span> <span class="comment"># VideoToolbox 编码器偏好的像素格式</span></span><br></pre></td></tr></table></figure></li><li><p><strong>硬件处理循环</strong>:<br>循环的主体结构类似，但操作对象变成了滤镜图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode(): <span class="comment"># 解码出的 frame 是一个指向GPU显存的硬件帧</span></span><br><span class="line">    graph.push(frame) <span class="comment"># 将硬件帧推入滤镜图处理</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            filtered_frame = buffer_sink.pull() <span class="comment"># 从滤镜图拉取处理好的帧</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                output_container.mux(out_packet)</span><br><span class="line">        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实际处理">实际处理</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 检查当前 PyAV 环境是否支持硬件加速</span></span><br><span class="line">HW_ACCEL_SUPPORTED = <span class="built_in">hasattr</span>(av, <span class="string">&#x27;hwdevice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">    <span class="comment"># 进一步检查平台是否为 macOS</span></span><br><span class="line">    <span class="keyword">if</span> platform.system() == <span class="string">&#x27;Darwin&#x27;</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;硬件加速 (VideoToolbox) 可用。将优先使用 Metal 路径。&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        HW_ACCEL_SUPPORTED = <span class="literal">False</span></span><br><span class="line">        logger.warning(<span class="string">&quot;PyAV 支持硬件加速，但当前系统不是 macOS。VideoToolbox 不可用。&quot;</span>)</span><br><span class="line">        logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.warning(<span class="string">&quot;当前 PyAV 环境中未找到硬件加速模块 (&#x27;av.hwdevice&#x27;)。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式，速度会较慢。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;要解决此问题，请确保您的项目解释器配置正确，并使用了完整编译的 PyAV 库。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 主调度器函数 ---</span></span><br><span class="line"><span class="comment"># 您的外部代码应该只调用这个函数</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_x: <span class="built_in">float</span>, crop_y: <span class="built_in">float</span>, crop_w: <span class="built_in">float</span>, crop_h: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        log_queue=<span class="literal">None</span>,  <span class="comment"># log_queue 和其他参数保留以兼容您的接口</span></span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        assigned_gpu_id: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs  <span class="comment"># 捕获任何其他未使用的参数</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果支持硬件加速，则尝试使用Metal路径；否则，或Metal路径失败时，</span></span><br><span class="line"><span class="string">    自动回退到纯软件路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    crop_params = &#123;</span><br><span class="line">        <span class="string">&#x27;x&#x27;</span>: crop_x, <span class="string">&#x27;y&#x27;</span>: crop_y, <span class="string">&#x27;w&#x27;</span>: crop_w, <span class="string">&#x27;h&#x27;</span>: crop_h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速路径</span></span><br><span class="line">            logger.info(<span class="string">f&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(</span><br><span class="line">                    input_video_path, output_video_path, crop_params,</span><br><span class="line">                    min_short_side_output_px</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果一开始就不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">f&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">            input_video_path, output_video_path, crop_params,</span><br><span class="line">            min_short_side_output_px</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 硬件加速实现 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_pyav_metal</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 PyAV 和 VideoToolbox (Metal) 进行硬件加速的视频裁剪。</span></span><br><span class="line"><span class="string">    这是一个内部函数，假设硬件支持已确认。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Metal路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数准备</span></span><br><span class="line">    crop_w_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_h_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_x_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_y_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> crop_w_f &lt;= <span class="number">0</span> <span class="keyword">or</span> crop_h_f &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    final_w, final_h = crop_w_f, crop_h_f</span><br><span class="line">    needs_scaling = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(crop_w_f, crop_h_f) &lt; min_short_side_output_px:</span><br><span class="line">        needs_scaling = <span class="literal">True</span></span><br><span class="line">        scale_factor = min_short_side_output_px / <span class="built_in">min</span>(crop_w_f, crop_h_f)</span><br><span class="line">        final_w = math.ceil((crop_w_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">        final_h = math.ceil((crop_h_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 硬件设备与容器 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 创建 VideoToolbox 上下文。&quot;</span>)</span><br><span class="line">        hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br><span class="line"></span><br><span class="line">        input_container = av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        output_container = av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        in_stream = input_container.streams.video[<span class="number">0</span>]</span><br><span class="line">        in_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件解码 (现代方式) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件解码。&quot;</span>)</span><br><span class="line">        hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">            <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">                <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">                    <span class="keyword">return</span> fmt</span><br><span class="line">            <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">f&quot;未找到 &#x27;<span class="subst">&#123;hw_pix_fmt&#125;</span>&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        in_stream.codec_context.get_format = get_hw_format</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置滤镜图 ---</span></span><br><span class="line">        <span class="comment"># FFmpeg 会在后台自动插入 hwupload/hwdownload 滤镜</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置滤镜图。&quot;</span>)</span><br><span class="line">        graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">        buffer_src = graph.add_buffer(template=in_stream)</span><br><span class="line"></span><br><span class="line">        filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;crop_w_f&#125;</span>:<span class="subst">&#123;crop_h_f&#125;</span>:<span class="subst">&#123;crop_x_f&#125;</span>:<span class="subst">&#123;crop_y_f&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> needs_scaling:</span><br><span class="line">            filter_chain += <span class="string">f&quot;,scale=<span class="subst">&#123;final_w&#125;</span>:<span class="subst">&#123;final_h&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滤镜图的终点是 buffer_sink</span></span><br><span class="line">        buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接滤镜</span></span><br><span class="line">        buffer_src.link_to(graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>))</span><br><span class="line">        graph.get_filter(<span class="string">&quot;filters&quot;</span>).link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">        graph.configure()</span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 滤镜图配置成功: &#x27;<span class="subst">&#123;filter_chain&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件编码 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件编码。&quot;</span>)</span><br><span class="line">        rate = in_stream.base_rate <span class="keyword">or</span> in_stream.guessed_rate <span class="keyword">or</span> in_stream.average_rate</span><br><span class="line">        out_stream = output_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">        out_stream.width = final_w</span><br><span class="line">        out_stream.height = final_h</span><br><span class="line">        out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span>  <span class="comment"># VideoToolbox 编码器通常使用 nv12</span></span><br><span class="line">        out_stream.time_base = in_stream.time_base</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 音频流处理 (直通) ---</span></span><br><span class="line">        in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> input_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> in_audio_stream:</span><br><span class="line">            out_audio_stream = output_container.add_stream(<span class="string">&#x27;aac&#x27;</span>, template=in_audio_stream)</span><br><span class="line">            streams_to_demux = (in_stream, in_audio_stream)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out_audio_stream = <span class="literal">None</span></span><br><span class="line">            streams_to_demux = in_stream</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 核心处理循环 ---</span></span><br><span class="line">        <span class="keyword">for</span> packet <span class="keyword">in</span> input_container.demux(streams_to_demux):</span><br><span class="line">            <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                    graph.push(frame)</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            filtered_frame = buffer_sink.pull()</span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                                output_container.mux(out_packet)</span><br><span class="line">                        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> out_audio_stream <span class="keyword">and</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">                packet.stream = out_audio_stream</span><br><span class="line">                output_container.mux(packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 冲洗(Flush) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 冲洗滤镜和编码器。&quot;</span>)</span><br><span class="line">        graph.push(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                filtered_frame = buffer_sink.pull()</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                    output_container.mux(out_packet)</span><br><span class="line">            <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(<span class="literal">None</span>):</span><br><span class="line">            output_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正常关闭</span></span><br><span class="line">        output_container.close()</span><br><span class="line">        input_container.close()</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;Metal路径处理时发生致命错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 清理</span></span><br><span class="line">        <span class="keyword">if</span> output_container:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 纯软件备用方案 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_software</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用纯软件 (CPU) 进行视频裁剪的备用方法。</span></span><br><span class="line"><span class="string">    这个方法总是可用的，但速度比硬件加速慢。</span></span><br><span class="line"><span class="string">    它确保输出尺寸为偶数，以兼容H.264等编码器。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;软件路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line">    success = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 1. 参数准备 (关键修正部分) ---</span></span><br><span class="line">        x, y, w, h = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> w &lt;= <span class="number">0</span> <span class="keyword">or</span> h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;裁剪尺寸无效 (w=<span class="subst">&#123;w&#125;</span>, h=<span class="subst">&#123;h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始的最终尺寸就是裁剪后的尺寸</span></span><br><span class="line">        final_w, final_h = w, h</span><br><span class="line">        needs_scaling = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否需要缩放</span></span><br><span class="line">        <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(w, h) &lt; min_short_side_output_px:</span><br><span class="line">            needs_scaling = <span class="literal">True</span></span><br><span class="line">            scale_factor = min_short_side_output_px / <span class="built_in">min</span>(w, h)</span><br><span class="line">            final_w = <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">            final_h = <span class="built_in">int</span>(h * scale_factor)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** 核心修正：确保最终的输出尺寸永远是偶数 ***</span></span><br><span class="line">        <span class="comment"># 这对于 H.264 (libx264) 和许多其他编码器至关重要</span></span><br><span class="line">        final_w = final_w - (final_w % <span class="number">2</span>)</span><br><span class="line">        final_h = final_h - (final_h % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> final_w &lt;= <span class="number">0</span> <span class="keyword">or</span> final_h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;计算后的输出尺寸无效 (<span class="subst">&#123;final_w&#125;</span>x<span class="subst">&#123;final_h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 2. 打开容器并设置流 ---</span></span><br><span class="line">        <span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">            <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># a. 查找所有输入流</span></span><br><span class="line">                in_video_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> in_video_stream:</span><br><span class="line">                    logger.error(<span class="string">&quot;输入文件中未找到视频流。&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                in_video_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">                in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                in_subtitle_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># b. 为每个输入流创建对应的输出流</span></span><br><span class="line">                out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">                out_video_stream.width = final_w</span><br><span class="line">                out_video_stream.height = final_h</span><br><span class="line"></span><br><span class="line">                out_audio_stream = out_container.add_stream_from_template(in_audio_stream) <span class="keyword">if</span> in_audio_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                out_subtitle_stream = out_container.add_stream_from_template(</span><br><span class="line">                    in_subtitle_stream) <span class="keyword">if</span> in_subtitle_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                streams_to_demux = [s <span class="keyword">for</span> s <span class="keyword">in</span> [in_video_stream, in_audio_stream, in_subtitle_stream] <span class="keyword">if</span> s]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 3. 核心处理循环 ---</span></span><br><span class="line">                <span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">                    <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                            img = frame.to_image()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 裁剪</span></span><br><span class="line">                            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 如果需要，进行缩放</span></span><br><span class="line">                            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                                <span class="comment"># Pillow 的 resize 需要一个 (width, height) 元组</span></span><br><span class="line">                                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line"></span><br><span class="line">                            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">                            new_frame.pts = frame.pts</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span> <span class="keyword">and</span> out_audio_stream:</span><br><span class="line">                        packet.stream = out_audio_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span> <span class="keyword">and</span> out_subtitle_stream:</span><br><span class="line">                        packet.stream = out_subtitle_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 4. 冲洗(Flush)视频编码器 ---</span></span><br><span class="line">                logger.debug(<span class="string">&quot;软件路径: 冲洗视频编码器。&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">                    out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        success = <span class="literal">True</span></span><br><span class="line">        logger.info(<span class="string">f&quot;软件路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;软件路径处理时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> output_container <span class="keyword">and</span> <span class="keyword">not</span> output_container.closed:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container <span class="keyword">and</span> <span class="keyword">not</span> input_container.closed:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> success <span class="keyword">and</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">                logger.info(<span class="string">f&quot;已清理失败的输出文件: <span class="subst">&#123;output_video_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">                logger.warning(<span class="string">f&quot;清理失败的输出文件时出错: <span class="subst">&#123;err&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="one-more-thing">one more thing</h2><ul><li>gpu acc</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU Acceleration Defaults</span></span><br><span class="line">GPU_ACCELERATION_DEFAULT = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;videotoolbox&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_videotoolbox&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GPU_ACCELERATION_DEFAULT_win = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;cuda&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_nvenc&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li>1.<a href="https://github.com/PyAV-Org/PyAV/tree/main/docs/api">https://github.com/PyAV-Org/PyAV/tree/main/docs/api</a></li><li>2.<a href="https://ffmpeg.org/documentation.html">https://ffmpeg.org/documentation.html</a></li><li>3.<a href="https://pyav.basswood-io.com/docs/stable/">https://pyav.basswood-io.com/docs/stable/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PyAV用于视频剪辑处理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数字水印系统实现</title>
    <link href="https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/"/>
    <id>https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/</id>
    <published>2025-07-22T10:25:23.000Z</published>
    <updated>2025-11-25T15:05:10.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现流程框架">实现流程框架</h2><p>无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：</p><ol><li><p><strong>水印嵌入 (Watermark Embedding)</strong>：</p><ul><li><strong>输入</strong>：原始载体（如图片A）、水印信息（如字符串&quot;ID:123&quot;或一个Logo图片B）。</li><li><strong>过程</strong>：通过特定算法，将水印信息B处理后，“叠加”或“融入”到原始载体A中。</li><li><strong>输出</strong>：一个带有水印、但看起来和原始载体几乎没区别的载体A’。</li></ul></li><li><p><strong>水印提取/检测 (Watermark Extraction/Detection)</strong>：</p><ul><li><strong>输入</strong>：可能被修改过的带水印载体A’'，有时还需要原始载体A或原始水印B作为参考。</li><li><strong>过程</strong>：通过与嵌入过程相逆的算法，从载体A’'中解码出隐藏的水印信息。</li><li><strong>输出</strong>：提取出的水印信息B’，或者一个“是/否”的判断（确认是否存在某个特定水印）。</li></ul></li></ol><blockquote><p>现在，我们来看实现这些流程的具体技术。</p></blockquote><hr><h3 id="一、-空域（Spatial-Domain）技术">一、 空域（Spatial Domain）技术</h3><p><strong>核心思想</strong>：直接修改原始图像的像素值（比如RGB值）来嵌入信息。这种方法直观、简单。</p><h4 id="典型技术：LSB-Least-Significant-Bit-算法">典型技术：LSB (Least Significant Bit) 算法</h4><p>这是最经典、最简单的空域水印技术。</p><ul><li><p><strong>原理</strong>：</p><ul><li>计算机中的图像，每个像素的颜色由若干个二进制位（bits）表示。例如，一个8位的灰度图像，每个像素的灰度值范围是0-255，由8个二进制位组成。</li><li><strong>最低有效位 (LSB)</strong> 就是这8个位中最右边的那一位。改变这一位，对像素值的整体影响最小（最多改变1），人眼基本无法察觉。</li><li><strong>嵌入方法</strong>：将要隐藏的水印信息（比如一张黑白Logo图片）转换成二进制流（0和1的序列）。然后，用这个二进制流去替换原始图像中每个（或部分）像素的LSB。<ul><li>如果要嵌入<code>1</code>，就把像素的LSB改成<code>1</code>。</li><li>如果要嵌入<code>0</code>，就把像素的LSB改成<code>0</code>。</li></ul></li></ul></li><li><p><strong>提取方法</strong>：直接读取带水印图像中相应像素的LSB，就能还原出隐藏的二进制流，从而重构水印信息。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：算法非常直接。</li><li><strong>容量大</strong>：每个像素都能藏1比特信息，可以隐藏大量数据。</li><li><strong>隐蔽性好</strong>：对视觉影响极小。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>鲁棒性极差（非常脆弱）</strong>：这是它的致命弱点。任何对图像的轻微处理，如 <strong>JPEG压缩、缩放、裁剪、加个滤镜</strong>，都会破坏LSB层的数据，导致水印完全丢失。</li></ul></li><li><p><strong>应用场景</strong>：主要用于<strong>脆弱水印</strong>，即<strong>内容完整性认证</strong>。因为只要图片被改动，水印就会被破坏，从而可以证明“此图已被修改”。</p></li></ul><hr><h3 id="二、-变换域（Transform-Domain）技术">二、 变换域（Transform Domain）技术</h3><p><strong>核心思想</strong>：不直接改像素值，而是先对图像进行数学变换（如傅里叶变换、余弦变换），将其从空域转换到另一个域（如频域）。然后，在变换后的域中修改系数来嵌入水印。这是目前主流的、<strong>鲁棒水印</strong>的实现方式。</p><p><strong>为什么要这么做？</strong><br>因为像JPEG压缩这样的操作，主要丢弃的是图像的<strong>高频信息</strong>（细节），而保留<strong>中低频信息</strong>（轮廓、主要能量）。如果在中低频系数里嵌入水印，那么即使经过压缩，水印信息也能大概率被保留下来。</p><h4 id="1-基于DCT（离散余弦变换）的技术">1. 基于DCT（离散余弦变换）的技术</h4><ul><li><strong>背景</strong>：DCT是 <strong>JPEG 压缩</strong>的核心算法。它将图像分成8x8的小块，然后对每个块进行DCT变换，得到一个频率系数矩阵。这个矩阵中，左上角是低频系数（能量集中），右下角是高频系数。</li><li><strong>嵌入方法</strong>：<ol><li>将原始图像分块（如8x8）。</li><li>对每个块进行DCT变换。</li><li>选择<strong>中频区域</strong>的系数进行修改。为什么是中频？因为低频系数对视觉影响太大，高频系数容易在压缩中丢失，中频是最佳平衡点。</li><li>根据水印信息（0或1）来修改这些中频系数。例如，通过量化或比较两个系数的大小来嵌入1比特信息。</li><li>对修改后的系数矩阵进行<strong>逆DCT变换</strong> (IDCT)，得到带水印的图像块。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>鲁棒性强</strong>：对JPEG压缩、轻微噪声、亮度调整等有很好的抵抗能力。</li><li><strong>隐蔽性好</strong>：利用了人类视觉系统对中频变化不敏感的特性。</li></ul></li><li><strong>应用场景</strong>：<strong>版权保护</strong>、<strong>盗版追踪</strong>等需要强鲁棒性的场合。</li></ul><h4 id="2-基于DWT（离散小波变换）的技术">2. 基于DWT（离散小波变换）的技术</h4><ul><li><strong>背景</strong>：DWT是 <strong>JPEG 2000</strong> 压缩标准的核心。与DCT不同，DWT能对整个图像进行多分辨率分析，得到不同尺度和方向的子带（低频、水平细节、垂直细节、对角线细节）。</li><li><strong>嵌入方法</strong>：<ol><li>对整个图像进行DWT变换。</li><li>水印通常被嵌入到<strong>中、低频子带</strong>的系数中。</li><li>因为DWT提供了图像的空间和频率局部化信息，所以它对裁剪、缩放等几何攻击的抵抗性更好。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>多分辨率特性</strong>：鲁棒性比DCT更全面，尤其在抗几何攻击方面。</li><li><strong>与人类视觉系统（HVS）匹配更好</strong>：可以更精细地控制水印的嵌入强度，达到更好的隐蔽性。</li></ul></li><li><strong>应用场景</strong>：同DCT，用于需要更高鲁棒性的版权保护系统。</li></ul><h4 id="3-基于DFT（离散傅里叶变换）的技术">3. 基于DFT（离散傅里叶变换）的技术</h4><ul><li><strong>背景</strong>：DFT将图像转换成幅度和相位谱。</li><li><strong>特点</strong>：图像的幅度谱对<strong>旋转、缩放和平移（RST攻击）</strong> 具有不变性或特定的变化规律。</li><li><strong>嵌入方法</strong>：通过修改DFT变换后的<strong>幅度谱</strong>来嵌入水印。</li><li><strong>优点</strong>：<ul><li>对旋转、缩放等几何攻击具有天然的鲁棒性。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，且容易出现图像块效应。</li></ul></li><li><strong>应用场景</strong>：主要用于抵抗几何变换的特定场合。</li></ul><hr><h2 id="实现">实现</h2><h3 id="核心的Python库：">核心的Python库：</h3><ul><li><strong>Pillow (PIL Fork)</strong>: 用于图像的读写和基本的像素操作（实现LSB）。</li><li><strong>NumPy</strong>: 用于高效的数组和矩阵运算，是所有图像处理的基础。</li><li><strong>PyWavelets (pywt)</strong>: 用于实现DWT（离散小波变换）。</li><li><strong>OpenCV-Python (cv2)</strong>: 功能最强大的计算机视觉库，可以方便地实现DCT、DFT以及各种图像处理操作。</li></ul><hr><h3 id="1-空域-Spatial-Domain-LSB-算法">1. 空域 (Spatial Domain) - LSB 算法</h3><p><strong>核心库</strong>: <code>Pillow</code> (PIL), <code>NumPy</code></p><p>这个算法不依赖复杂的数学库，Pillow和NumPy足以胜任。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">image_path, secret_message</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将秘密信息嵌入到图片的LSB层&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    width, height = img.size</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 将秘密信息转换为二进制流</span></span><br><span class="line">    binary_secret = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">format</span>(<span class="built_in">ord</span>(c), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> secret_message])</span><br><span class="line">    binary_secret += <span class="string">&#x27;1111111111111110&#x27;</span> <span class="comment"># 添加结束标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_secret) &gt; width * height * <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;信息过长，无法嵌入到图片中！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data_index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 2. 遍历像素并修改LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="comment"># 遍历RGB三个通道</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> data_index &lt; <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                    <span class="comment"># 清除LSB并设置新的位</span></span><br><span class="line">                    pixel[i] = (pixel[i] &amp; <span class="number">0xFE</span>) | <span class="built_in">int</span>(binary_secret[data_index])</span><br><span class="line">                    data_index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建并保存新图片</span></span><br><span class="line">    encoded_image = Image.fromarray(img_array)</span><br><span class="line">    encoded_image.save(<span class="string">&quot;encoded_image.png&quot;</span>, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信息嵌入成功，已保存为 encoded_image.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从图片的LSB层提取秘密信息&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line">    width, height = img.size</span><br><span class="line"></span><br><span class="line">    binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 遍历像素并提取LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                binary_data += <span class="built_in">str</span>(pixel[i] &amp; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 找到结束标记并转换信息</span></span><br><span class="line">    end_marker = <span class="string">&#x27;1111111111111110&#x27;</span></span><br><span class="line">    end_index = binary_data.find(end_marker)</span><br><span class="line">    <span class="keyword">if</span> end_index != -<span class="number">1</span>:</span><br><span class="line">        secret_binary = binary_data[:end_index]</span><br><span class="line">        secret_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(secret_binary), <span class="number">8</span>):</span><br><span class="line">            byte = secret_binary[i:i+<span class="number">8</span>]</span><br><span class="line">            secret_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> secret_message</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;未找到结束标记或信息。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备一张名为 &#x27;original.png&#x27; 的图片</span></span><br><span class="line"><span class="comment"># encode_lsb(&#x27;original.png&#x27;, &quot;This is a secret message!&quot;)</span></span><br><span class="line"><span class="comment"># message = decode_lsb(&#x27;encoded_image.png&#x27;)</span></span><br><span class="line"><span class="comment"># print(f&quot;提取到的信息: &#123;message&#125;&quot;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-变换域-Transform-Domain-DCT-算法">2. 变换域 (Transform Domain) - DCT 算法</h3><p><strong>核心库</strong>: <code>OpenCV-Python (cv2)</code>, <code>NumPy</code></p><p>OpenCV 提供了非常方便的 <code>cv2.dct()</code> 和 <code>cv2.idct()</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DCT的中频带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保水印尺寸小于载体</span></span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DCT变换</span></span><br><span class="line">    img_dct = cv2.dct(np.float32(img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 对水印图像进行DCT变换 (也可以直接用二值化水印)</span></span><br><span class="line">    watermark_dct = cv2.dct(np.float32(watermark))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将水印的DCT系数加到载体的中频DCT系数上</span></span><br><span class="line">    <span class="comment"># 这里简单地将整个水印DCT加到载体DCT上，更复杂的会选择特定区域</span></span><br><span class="line">    <span class="comment"># alpha 是嵌入强度</span></span><br><span class="line">    result_dct = img_dct + alpha * watermark_dct</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 进行逆DCT变换</span></span><br><span class="line">    result_img = cv2.idct(result_dct)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 裁剪值到 0-255 并转换为uint8</span></span><br><span class="line">    result_img = np.clip(result_img, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_embedded_image.png&#x27;</span>, result_img)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DCT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 这是一个非盲水印提取的例子</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对带水印图像和原始图像分别做DCT</span></span><br><span class="line">    embedded_dct = cv2.dct(np.float32(embedded_img))</span><br><span class="line">    original_dct = cv2.dct(np.float32(original_img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 相减并除以强度因子，得到水印的DCT系数</span></span><br><span class="line">    extracted_watermark_dct = (embedded_dct - original_dct) / alpha</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 逆DCT变换，恢复水印</span></span><br><span class="line">    extracted_watermark = cv2.idct(extracted_watermark_dct)</span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dct_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.1)</span></span><br><span class="line"><span class="comment"># dct_watermark_extract(&#x27;dct_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.1)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 上述DCT示例是一个<strong>非盲水印</strong>，提取时需要原始图像。实现盲水印（无需原图）会更复杂，通常涉及在中频带选择特定的系数对进行比较，而不是直接叠加。</p><hr><h3 id="3-变换域-Transform-Domain-DWT-算法">3. 变换域 (Transform Domain) - DWT 算法</h3><p><strong>核心库</strong>: <code>PyWavelets (pywt)</code>, <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p><code>pywt</code> 是Python中进行小波变换的标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DWT的LL子带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DWT变换</span></span><br><span class="line">    <span class="comment"># &#x27;haar&#x27; 是最简单的小波基</span></span><br><span class="line">    coeffs_img = pywt.dwt2(img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL, (LH, HL, HH) = coeffs_img</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保水印尺寸与LL子带匹配</span></span><br><span class="line">    watermark_resized = cv2.resize(watermark, (LL.shape[<span class="number">1</span>], LL.shape[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 将水印添加到低频子带 (LL)</span></span><br><span class="line">    <span class="comment"># LL子带能量最集中，鲁棒性最强，但对画质影响也最大</span></span><br><span class="line">    LL_watermarked = LL + alpha * watermark_resized</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 重构图像</span></span><br><span class="line">    coeffs_watermarked = (LL_watermarked, (LH, HL, HH))</span><br><span class="line">    img_watermarked = pywt.idwt2(coeffs_watermarked, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    img_watermarked = np.clip(img_watermarked, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_embedded_image.png&#x27;</span>, img_watermarked)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DWT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 同样是非盲水印提取</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对两张图分别做DWT</span></span><br><span class="line">    coeffs_embedded = pywt.dwt2(embedded_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_embedded, _ = coeffs_embedded</span><br><span class="line">    </span><br><span class="line">    coeffs_original = pywt.dwt2(original_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_original, _ = coeffs_original</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 提取水印</span></span><br><span class="line">    extracted_watermark = (LL_embedded - LL_original) / alpha</span><br><span class="line">    </span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dwt_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.2)</span></span><br><span class="line"><span class="comment"># dwt_watermark_extract(&#x27;dwt_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.2)</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-变换域-Transform-Domain-DFT-算法">4. 变换域 (Transform Domain) - DFT 算法</h3><p><strong>核心库</strong>: <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p>DFT的实现与DCT类似，但通常用于抵抗几何攻击。这里提供一个基础的嵌入思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dft_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DFT幅度谱嵌入水印&quot;&quot;&quot;</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. DFT变换</span></span><br><span class="line">    <span class="comment"># OpenCV的dft需要输入float32，并会输出双通道复数结果</span></span><br><span class="line">    dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 将频谱中心移到图像中央，便于观察和操作</span></span><br><span class="line">    dft_shift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算幅度和相位谱</span></span><br><span class="line">    magnitude_spectrum = cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line">    phase_spectrum = cv2.phase(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 在幅度谱上添加水印</span></span><br><span class="line">    magnitude_spectrum_watermarked = magnitude_spectrum + alpha * watermark</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 根据新的幅度和旧的相位，重构DFT结果</span></span><br><span class="line">    real_part = magnitude_spectrum_watermarked * np.cos(phase_spectrum)</span><br><span class="line">    imag_part = magnitude_spectrum_watermarked * np.sin(phase_spectrum)</span><br><span class="line">    dft_shift_watermarked = cv2.merge([real_part, imag_part])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 将频谱中心移回左上角</span></span><br><span class="line">    dft_watermarked = np.fft.ifftshift(dft_shift_watermarked)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 逆DFT变换</span></span><br><span class="line">    img_back = cv2.idft(dft_watermarked)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取实部并恢复图像</span></span><br><span class="line">    img_back = cv2.magnitude(img_back[:,:,<span class="number">0</span>], img_back[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    img_back = np.clip(img_back, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dft_embedded_image.png&#x27;</span>, img_back)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DFT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dft_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=100)</span></span><br><span class="line"><span class="comment"># 提取DFT水印通常也需要原始图像，过程与DCT/DWT类似。</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖库">安装依赖库</h3><ul><li>pip安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow numpy opencv-python pywavelets</span><br></pre></td></tr></table></figure><h2 id="demo">demo</h2><h3 id="水印信息嵌入（LSB）">水印信息嵌入（LSB）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_message_to_binary</span>(<span class="params">message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a string message into its binary representation.&quot;&quot;&quot;</span></span><br><span class="line">    binary_message = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">format</span>(<span class="built_in">ord</span>(char), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> char <span class="keyword">in</span> message)</span><br><span class="line">    <span class="keyword">return</span> binary_message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_binary_to_message</span>(<span class="params">binary_message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a binary string back into a string message.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Ensure the binary string is a multiple of 8</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_message) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        logger.warning(<span class="string">&quot;Binary string length is not a multiple of 8; data may be incomplete.&quot;</span>)</span><br><span class="line">        binary_message = binary_message[:-(<span class="built_in">len</span>(binary_message) % <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    message = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_message), <span class="number">8</span>):</span><br><span class="line">        byte = binary_message[i:i + <span class="number">8</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte) == <span class="number">8</span>:</span><br><span class="line">            message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encodes a secret message into an image using the LSB (Least Significant Bit) technique.</span></span><br><span class="line"><span class="string">    The output image will be saved in a lossless format (PNG) to preserve the watermark.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path (str): The path to the source image.</span></span><br><span class="line"><span class="string">        secret_message (str): The message to hide.</span></span><br><span class="line"><span class="string">        output_image_path (str): The path to save the watermarked image.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB encoding for &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path, <span class="string">&#x27;r&#x27;</span>).convert(<span class="string">&quot;RGBA&quot;</span>) <span class="comment"># Convert to RGBA for consistency</span></span><br><span class="line">        width, height = image.size</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        channels = <span class="number">4</span>  <span class="comment"># We are using RGBA</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add a unique delimiter to know where the message ends</span></span><br><span class="line">        binary_secret_message = _message_to_binary(secret_message + <span class="string">&quot;####&quot;</span>)</span><br><span class="line">        required_pixels = <span class="built_in">len</span>(binary_secret_message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> required_pixels &gt; width * height * channels:</span><br><span class="line">            logger.error(<span class="string">&quot;Error: Message is too long to be encoded in this image.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Modify the LSB of the pixel data</span></span><br><span class="line">        data_index = <span class="number">0</span></span><br><span class="line">        flat_array = img_array.flatten()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flat_array)):</span><br><span class="line">            <span class="keyword">if</span> data_index &lt; required_pixels:</span><br><span class="line">                <span class="comment"># Change the LSB of the color value</span></span><br><span class="line">                flat_array[i] = <span class="built_in">int</span>(<span class="built_in">bin</span>(flat_array[i])[<span class="number">2</span>:-<span class="number">1</span>] + binary_secret_message[data_index], <span class="number">2</span>)</span><br><span class="line">                data_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># Stop once the message is encoded</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a new image with the modified pixel data</span></span><br><span class="line">        encoded_image = Image.fromarray(flat_array.reshape(height, width, channels).astype(<span class="string">&#x27;uint8&#x27;</span>), image.mode)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save as PNG to ensure lossless storage of the watermark</span></span><br><span class="line">        encoded_image.save(output_image_path, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;Successfully encoded message into &#x27;<span class="subst">&#123;output_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Input image not found at &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during encoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decodes a secret message from an image using the LSB technique.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path (str): The path to the watermarked image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        The decoded secret message, or None if an error occurs or no message is found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB decoding for &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pixel <span class="keyword">in</span> img_array:</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> pixel:</span><br><span class="line">                binary_data += <span class="built_in">bin</span>(value)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find the delimiter by decoding byte by byte</span></span><br><span class="line">        decoded_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_data), <span class="number">8</span>):</span><br><span class="line">            byte = binary_data[i:i+<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(byte) &lt; <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># End of data</span></span><br><span class="line">            decoded_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> decoded_message.endswith(<span class="string">&quot;####&quot;</span>):</span><br><span class="line">                logger.info(<span class="string">&quot;Successfully decoded the message.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message[:-<span class="number">4</span>]  <span class="comment"># Return message without the delimiter</span></span><br><span class="line"></span><br><span class="line">        logger.warning(<span class="string">&quot;Could not find the end-of-message delimiter in the image.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Encoded image not found at &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during decoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="水印信息验证">水印信息验证</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_img_msg</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Command-line tool to decode an invisible watermark from an image file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    image_path = Path(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> image_path.is_file():</span><br><span class="line">        logger.debug(<span class="string">f&quot;Error: File not found at &#x27;<span class="subst">&#123;image_path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">f&quot;Verifying &#x27;<span class="subst">&#123;image_path.name&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">    decoded_message = decode_lsb(<span class="built_in">str</span>(image_path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decoded_message:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ✅ Watermark Found! ---&quot;</span>)</span><br><span class="line">        <span class="comment"># Pretty logger.debug the decoded information</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> decoded_message.split(<span class="string">&#x27;|&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;:&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">                key, value = item.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;key.strip():&lt;<span class="number">15</span>&#125;</span>: <span class="subst">&#123;value.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ❌ No Watermark Found ---&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;No hidden message could be decoded from this image.&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> decoded_message</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="水印信息嵌入（EXIF）">水印信息嵌入（EXIF）</h3> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> piexif</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 UserComment 的标准前缀，UNDEFINED 表示未定义编码，允许我们使用 UTF-8。</span></span><br><span class="line"><span class="comment"># 这是符合 EXIF 规范的推荐做法。</span></span><br><span class="line">USER_COMMENT_PREFIX = <span class="string">b&#x27;UNDEFINED\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_exif</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将秘密信息作为隐形水印编码到图片的EXIF元数据中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path: 输入图片的路径。</span></span><br><span class="line"><span class="string">        secret_message: 要隐藏的信息。</span></span><br><span class="line"><span class="string">        output_image_path: 保存带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        如果编码成功，返回 True，否则返回 False。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在为 &#x27;<span class="subst">&#123;Path(input_image_path).name&#125;</span>&#x27; 添加EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开图片</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 复制原始图片信息，以便在保存时保留质量、DPI等设置</span></span><br><span class="line">        image_info = image.info.copy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否已有EXIF数据，如果没有则创建一个空的</span></span><br><span class="line">        exif_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">in</span> image_info <span class="keyword">and</span> image_info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            exif_dict = piexif.load(image_info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 确保 &#x27;Exif&#x27; 子字典存在，防止 KeyError</span></span><br><span class="line">        <span class="keyword">if</span> piexif.ImageIFD.ExifPtr <span class="keyword">not</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">             exif_dict[<span class="string">&#x27;Exif&#x27;</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 将秘密信息编码并添加标准前缀，然后放入 UserComment 字段</span></span><br><span class="line">        <span class="comment"># 这是存储任意用户数据的标准字段</span></span><br><span class="line">        user_comment_payload = USER_COMMENT_PREFIX + secret_message.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        exif_dict[<span class="string">&#x27;Exif&#x27;</span>][piexif.ExifIFD.UserComment] = user_comment_payload</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将更新后的EXIF字典转换为字节流</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 有时 EXIF 数据可能包含 piexif 不支持的格式</span></span><br><span class="line">            logger.error(<span class="string">f&quot;无法序列化 EXIF 数据: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 尝试移除可能导致问题的缩略图数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;thumbnail&#x27;</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">                <span class="keyword">del</span> exif_dict[<span class="string">&#x27;thumbnail&#x27;</span>]</span><br><span class="line">                exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 保存图片，并附上新的EXIF数据</span></span><br><span class="line">        <span class="comment"># 对于 JPEG，传递原始 info 字典以保留质量等设置</span></span><br><span class="line">        <span class="comment"># 对于 PNG 等其他格式，直接使用 exif 参数</span></span><br><span class="line">        <span class="keyword">if</span> image.<span class="built_in">format</span> == <span class="string">&#x27;JPEG&#x27;</span>:</span><br><span class="line">            image.save(output_image_path, <span class="string">&quot;jpeg&quot;</span>, exif=exif_bytes, **image_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image.save(output_image_path, exif=exif_bytes)</span><br><span class="line"></span><br><span class="line">        logger.success(<span class="string">f&quot;成功将EXIF水印写入 &#x27;<span class="subst">&#123;Path(output_image_path).name&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;输入文件未找到: <span class="subst">&#123;input_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;添加EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_exif</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从图片的EXIF元数据中解码出隐藏的秘密信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path: 带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        解码后的信息字符串，如果未找到或发生错误则返回 None。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在从 &#x27;<span class="subst">&#123;Path(encoded_image_path).name&#125;</span>&#x27; 解码EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否有EXIF数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> image.info <span class="keyword">or</span> <span class="keyword">not</span> image.info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            logger.warning(<span class="string">&quot;图片中未找到EXIF数据。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载EXIF数据</span></span><br><span class="line">        exif_dict = piexif.load(image.info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 安全地从 UserComment 字段读取信息，防止 KeyError</span></span><br><span class="line">        exif_ifd = exif_dict.get(<span class="string">&#x27;Exif&#x27;</span>, &#123;&#125;)</span><br><span class="line">        user_comment_bytes = exif_ifd.get(piexif.ExifIFD.UserComment)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user_comment_bytes:</span><br><span class="line">            <span class="comment"># [FIXED] 检查是否存在我们定义的前缀，并剥离它</span></span><br><span class="line">            <span class="keyword">if</span> user_comment_bytes.startswith(USER_COMMENT_PREFIX):</span><br><span class="line">                message_bytes = user_comment_bytes[<span class="built_in">len</span>(USER_COMMENT_PREFIX):]</span><br><span class="line">                <span class="comment"># 将字节解码回字符串</span></span><br><span class="line">                decoded_message = message_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                logger.success(<span class="string">&quot;成功解码EXIF水印。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(<span class="string">&quot;在&#x27;UserComment&#x27;字段中找到数据，但不包含预期的水印前缀。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&quot;在EXIF中未找到&#x27;UserComment&#x27;水印字段。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;文件未找到: <span class="subst">&#123;encoded_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;解码EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="技术总结对比">技术总结对比</h3><table><thead><tr><th style="text-align:left">技术类别</th><th style="text-align:left">核心算法</th><th style="text-align:left">主要优点</th><th style="text-align:left">主要缺点</th><th style="text-align:left">典型应用</th></tr></thead><tbody><tr><td style="text-align:left"><strong>空域 (Spatial Domain)</strong></td><td style="text-align:left"><strong>LSB</strong></td><td style="text-align:left">实现简单、容量大</td><td style="text-align:left"><strong>鲁棒性极差</strong>，一碰就坏</td><td style="text-align:left"><strong>完整性认证 (脆弱水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DCT</strong></td><td style="text-align:left"><strong>对压缩鲁棒</strong>、隐蔽性好</td><td style="text-align:left">对几何攻击抵抗力一般</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DWT</strong></td><td style="text-align:left"><strong>综合鲁棒性强</strong>，尤其对裁剪等</td><td style="text-align:left">算法比DCT复杂</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DFT</strong></td><td style="text-align:left"><strong>对旋转/缩放鲁棒</strong></td><td style="text-align:left">实现复杂，可能影响画质</td><td style="text-align:left"><strong>抵抗几何攻击的特殊应用</strong></td></tr></tbody></table><p>简单来说：</p><ul><li>想做<strong>防伪标签</strong>，一改就失效，用 <strong>LSB</strong>。</li><li>想做<strong>版权印章</strong>，不怕压缩和基本处理，用 <strong>DCT</strong> 或 <strong>DWT</strong>。它们是目前最实用和最主流的鲁棒水印技术。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现流程框架&quot;&gt;实现流程框架&lt;/h2&gt;
&lt;p&gt;无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水印嵌入 (Watermark Embedding)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Tailscale</title>
    <link href="https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/</id>
    <published>2025-07-17T12:10:39.000Z</published>
    <updated>2025-11-25T15:05:10.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="一、Tailscale-到底是什么？">一、Tailscale 到底是什么？</h3><p>你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。</p><ul><li><strong>传统的VPN</strong>：像是在你家（局域网）和公司（另一个局域网）之间挖了一条秘密隧道。</li><li><strong>Tailscale</strong>：更像是给你的每一台设备（NAS、电脑、手机、平板）都穿上了一件“隐身衣”，并给它们一个秘密的联络暗号。无论这些设备身处世界何地，只要它们都穿着这件“隐身衣”（安装了 Tailscale 客户端并用同一账号登录），它们就能互相看见、互相通信，仿佛就在同一个房间里。</li></ul><p>这个“虚拟局域网”是建立在互联网之上的，但它又是完全隔离和加密的，外界无法窥探。</p><h3 id="二、它如何解决你的-NAS-外链问题？">二、它如何解决你的 NAS 外链问题？</h3><p>Tailscale 通过以下几个核心功能来解决你的问题：</p><ol><li><strong>稳定的虚拟 IP 地址</strong>：一旦你的 NAS 加入了 Tailscale 网络，它会被分配一个 <code>100.x.x.x</code> 开头的、独一无二且固定的 IP 地址。你再也不用关心家里宽带的公网 IP 是不是变了。</li><li><strong>零配置穿透 (Zero-config NAT traversal)</strong>：你不需要在路由器上做任何端口转发。Tailscale 会自动想办法在你的设备之间“打洞”，建立点对点（P2P）的加密连接。这意味着数据传输速度很快，因为大部分时间数据是直连的，不经过第三方服务器中转。</li><li><strong>极高的安全性</strong>：它基于目前最先进的 VPN 协议 <strong>WireGuard®</strong> 构建，所有通信都是端到端加密的。因为你没有在路由器上开放任何端口，所以你的 NAS 不会暴露在公网上，大大降低了被黑客扫描和攻击的风险。</li><li><strong>设备间的无缝访问</strong>：只要你的电脑或手机也安装并登录了 Tailscale，你就可以在任何地方，直接通过 NAS 的那个 <code>100.x.x.x</code> 虚拟 IP 来访问它的管理页面、File Station 等所有服务，体验和在家里一模一样。</li></ol><h2 id="部署">部署</h2><h3 id="部署方式一：使用-docker-run-命令（单次部署）">部署方式一：使用 <code>docker run</code> 命令（单次部署）</h3><p>这是最直接的方式，适合快速启动。</p><h4 id="步骤-1：准备持久化目录">步骤 1：准备持久化目录</h4><p>为了让 Tailscale 的状态（主要是它的身份密钥）在容器重启后不丢失，我们需要在主机上创建一个目录来持久化存储它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH 登录到你的 NAS 或服务器</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /path/to/your/appdata/tailscale</span><br><span class="line"><span class="comment"># 注意：请将 /path/to/your/appdata 替换为你自己存放应用数据的实际路径</span></span><br><span class="line"><span class="comment"># 例如，在群晖上可能是 /volume1/docker/tailscale</span></span><br></pre></td></tr></table></figure><h4 id="步骤-2：运行-Docker-容器">步骤 2：运行 Docker 容器</h4><p>复制并执行以下命令。这条命令已经包含了运行 Tailscale 所需的所有关键配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=tailscaled \</span><br><span class="line">  -v /path/to/your/appdata/tailscale:/var/lib/tailscale \</span><br><span class="line">  -v /dev/net/tun:/dev/net/tun \</span><br><span class="line">  --network=host \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=NET_RAW \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  tailscale/tailscale</span><br></pre></td></tr></table></figure><p><strong>命令参数详解：</strong></p><ul><li><code>docker run -d</code>: 在后台（detached mode）运行容器。</li><li><code>--name=tailscaled</code>: 给容器起一个好记的名字，方便管理。</li><li><code>-v /path/to/your/appdata/tailscale:/var/lib/tailscale</code>: <strong>【核心】</strong> 将主机上的目录挂载到容器内，用于保存 Tailscale 的状态。<strong>务必替换为你自己的路径</strong>。</li><li><code>-v /dev/net/tun:/dev/net/tun</code>: 将主机的 TUN 设备挂载到容器内，这是 Tailscale 创建虚拟网卡所必需的。</li><li><code>--network=host</code>: <strong>【核心】</strong> 让容器直接使用主机的网络，这是最简单且功能最全的模式。容器可以轻松访问主机的所有端口，也方便将主机作为子网路由（Subnet Router）。</li><li><code>--cap-add=NET_ADMIN --cap-add=NET_RAW</code>: 授予容器操作网络接口所需的 Linux Capabilities 权限。</li><li><code>--restart unless-stopped</code>: 设置容器的重启策略，除非手动停止，否则 Docker 重启时会自动启动该容器。</li><li><code>tailscale/tailscale</code>: 指定要使用的官方 Docker 镜像。</li></ul><h4 id="步骤-3：将-NAS-加入你的-Tailscale-网络">步骤 3：将 NAS 加入你的 Tailscale 网络</h4><p>容器已经在运行了，但它还不知道自己是谁。我们需要执行一条命令来让它登录。</p><ol><li><p>执行以下命令，启动 Tailscale 并获取登录链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure></li><li><p>命令执行后，终端会输出一个登录 URL，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To authenticate, visit:</span><br><span class="line"></span><br><span class="line">    https://login.tailscale.com/a/123456789ABC</span><br></pre></td></tr></table></figure></li><li><p>复制这个 URL，在你的电脑浏览器中打开，用你的 Tailscale 账户登录并授权这台新设备。</p></li><li><p>授权成功后，回到你的 <a href="https://login.tailscale.com/admin/machines">Tailscale Admin Console</a> 后台，你就能看到这台新设备已经加入了你的网络。</p></li></ol><p><strong>至此，你的 NAS 已经成功通过 Docker 加入了 Tailscale 网络！</strong> 你可以在任何其他已登录 Tailscale 的设备上，通过分配的 <code>100.x.x.x</code> IP 地址来访问你的 NAS。</p><hr><h3 id="部署方式二：使用-docker-compose（推荐，便于管理）">部署方式二：使用 <code>docker-compose</code>（推荐，便于管理）</h3><p>如果你需要管理多个容器，或者希望将配置以文件形式保存下来，<code>docker-compose</code> 是更好的选择。</p><h4 id="步骤-1：创建-docker-compose-yml-文件">步骤 1：创建 <code>docker-compose.yml</code> 文件</h4><p>在你喜欢的位置（例如 <code>/volume1/docker/tailscale</code>）创建一个名为 <code>docker-compose.yml</code> 的文件，并将以下内容粘贴进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">tailscaled:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tailscale/tailscale</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tailscaled</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">my-nas</span> <span class="comment"># 在 Tailscale 管理后台显示的设备名</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/tailscale</span> <span class="comment"># 将状态保存在当前目录下的 data 文件夹</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/net/tun:/dev/net/tun</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_RAW</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>hostname</code>: 你可以自定义一个名字，这样在 Tailscale 后台一眼就能认出是哪台设备。</li><li><code>volumes</code>: <code>- ./data:/var/lib/tailscale</code> 这种相对路径的写法表示将状态文件保存在 <code>docker-compose.yml</code> 文件同级的 <code>data</code> 文件夹内，非常方便。</li></ul><h4 id="步骤-2：启动服务">步骤 2：启动服务</h4><p>在 <code>docker-compose.yml</code> 文件所在的目录中，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="步骤-3：登录和授权">步骤 3：登录和授权</h4><p>这一步和 <code>docker run</code> 方式完全一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure><p>然后复制输出的 URL 到浏览器完成授权。</p><hr><h3 id="高级功能：如何生成外链和访问内网？">高级功能：如何生成外链和访问内网？</h3><p>部署成功后，你可以利用 Tailscale 的高级功能来实现最初的目标。</p><h4 id="1-将-NAS-作为子网路由-Subnet-Router">1. 将 NAS 作为子网路由 (Subnet Router)</h4><p><strong>场景</strong>：你想通过手机（已连接 Tailscale）访问你家里的其他设备，比如打印机 (<code>192.168.1.100</code>)。</p><ol><li><p>修改启动命令，使其“宣告”它可以路由的内网网段。在执行 <code>tailscale up</code> 时加入 <code>--advertise-routes</code> 参数。</p><ul><li>你需要先 <code>down</code> 再 <code>up</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale down</span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.1.0/24</span><br><span class="line"><span class="comment"># !!! 将 192.168.1.0/24 替换为你自己的局域网网段 !!!</span></span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.10.0/24 -accept-dns=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 Tailscale Admin Console 后台，找到你的 NAS 设备，点击右侧的 “…”，选择 “Edit route settings…”。</p></li><li><p>勾选并启用你刚刚宣告的子网路由。</p></li></ol><p>现在，你任何连接了 Tailscale 的设备，都可以直接访问 <code>192.168.1.x</code> 网段的所有设备了，就像在家一样。</p><h4 id="2-使用-Tailscale-Funnel-生成外链">2. 使用 Tailscale Funnel 生成外链</h4><p><strong>场景</strong>：你想临时分享 NAS 上的一个文件给没有安装 Tailscale 的朋友。</p><ol><li><p>确保你的 Docker 容器已经通过 <code>tailscale up</code> 成功连接。</p></li><li><p>假设你想分享的服务在主机的 <code>8080</code> 端口上（比如一个临时的文件服务器）。</p><ul><li>由于我们使用了 <code>--network=host</code>，容器可以直接访问到主机的 <code>8080</code> 端口。</li></ul></li><li><p>执行 Funnel 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale funnel 8080</span><br></pre></td></tr></table></figure></li><li><p>命令会输出一个公网可访问的 HTTPS 链接，形如 <code>https://your-nas-hostname.ts.net</code>。将这个链接发给你的朋友即可。</p></li><li><p>分享完毕后，按 <code>Ctrl+C</code> 停止 Funnel，外链即刻失效，非常安全。如果想在后台运行，可以加上 <code>--bg</code> 参数。</p></li></ol><h3 id="总结：如何使用部署后的服务">总结：如何使用部署后的服务</h3><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">使用的功能</th><th style="text-align:left">具体操作</th></tr></thead><tbody><tr><td style="text-align:left"><strong>在外面用</strong></td><td style="text-align:left"><strong>Tailscale 核心连接 + MagicDNS</strong></td><td style="text-align:left">在你的电脑/手机上安装并登录 Tailscale，然后像在家里一样，用 <code>http://设备名:端口</code> 的方式访问 NAS 的各项服务。</td></tr><tr><td style="text-align:left"><strong>映射为电脑硬盘</strong></td><td style="text-align:left"><strong>SMB/AFP over Tailscale</strong></td><td style="text-align:left">在电脑的“映射网络驱动器”或“连接服务器”功能中，使用 <code>\\设备名</code> 或 <code>smb://设备名</code> 作为地址。</td></tr><tr><td style="text-align:left"><strong>分享文件给别人</strong></td><td style="text-align:left"><strong>Tailscale Funnel</strong></td><td style="text-align:left">在 NAS 上用 Python 或其他方式启动一个临时 Web 服务器，然后用 <code>tailscale funnel &lt;端口号&gt;</code> 命令生成一个临时的公网下载链接。</td></tr><tr><td style="text-align:left"><strong>访问家里其他设备</strong></td><td style="text-align:left"><strong>子网路由 (Subnet Router)</strong></td><td style="text-align:left">在部署 Tailscale 时宣告内网网段，并在管理后台启用。之后就能直接通过内网 IP 访问家里所有设备。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;h3 id=&quot;一、Tailscale-到底是什么？&quot;&gt;一、Tailscale 到底是什么？&lt;/h3&gt;
&lt;p&gt;你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统的V</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NAS 文件借助 MinIO 转换OSS</title>
    <link href="https://caozhaoqi.github.io/2025/07/16/minio-nas-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/16/minio-nas-build/</id>
    <published>2025-07-16T08:58:11.000Z</published>
    <updated>2025-11-25T15:05:10.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体架构">整体架构</h3><p>这个架构的核心思想是：<strong>MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。</strong> 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理路径下。</p><h3 id="方案优点">方案优点</h3><ol><li><strong>协议现代化</strong>：将传统的、基于文件系统的访问（如 NFS, SMB）升级为现代的、基于 HTTP 的 S3 API 访问。</li><li><strong>无需数据迁移</strong>：数据仍然存放在 NAS 上，你不需要花费大量时间去拷贝或迁移 TB 级的海量数据。MinIO 直接在 NAS 的文件系统之上运行。</li><li><strong>统一访问入口</strong>：无论你有多少个 NAS 卷或目录，都可以通过 MinIO 的 Bucket（存储桶）来组织和访问，形成一个统一的视图。</li><li><strong>生态兼容性</strong>：几乎所有现代云原生应用、大数据框架、备份工具都原生支持 S3 协议，可以无缝对接。</li><li><strong>高性能</strong>：MinIO 本身是为高性能而设计的，可以直接利用 NAS 的硬件性能。</li></ol><hr><h3 id="第一步：准备工作">第一步：准备工作</h3><ol><li><strong>一台服务器/虚拟机</strong>：你需要一台 Linux 服务器来运行 MinIO。这台服务器<strong>必须能够高速挂载（mount）你的 NAS 目录</strong>。这台服务器的 CPU 和内存资源会影响 MinIO 的性能，但对于一般的文件服务，配置要求不高（例如 2核4G 内存即可起步）。我们称这台服务器为 “MinIO Server”。</li><li><strong>网络连接</strong>：确保 MinIO Server 和 NAS 之间有高速、低延迟的网络连接（例如，千兆或万兆以太网）。</li><li><strong>NAS 目录</strong>：确定你要提供为对象存储的 NAS 上的一个或多个目录。例如，<code>/volume1/data</code>。</li></ol><h3 id="第二步：在-MinIO-Server-上挂载-NAS-目录">第二步：在 MinIO Server 上挂载 NAS 目录</h3><p>这是最关键的一步。你必须将 NAS 的共享目录挂载到 MinIO Server 的本地文件系统上。</p><p>假设你的 NAS IP 是 <code>192.168.1.100</code>，共享的目录是 <code>shared_data</code>，你希望将它挂载到 MinIO Server 的 <code>/mnt/nas_data</code> 目录。</p><h4 id="使用-NFS-挂载（推荐）">使用 NFS 挂载（推荐）</h4><ol><li><p><strong>在 NAS 上</strong>：确保 NFS 服务已开启，并且 <code>shared_data</code> 目录已经通过 NFS 共享出去，同时授权 MinIO Server 的 IP (<code>192.168.1.50</code> 假设) 有读写权限。</p></li><li><p><strong>在 MinIO Server 上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 NFS 客户端</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nfs-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建本地挂载点</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 手动挂载进行测试</span></span><br><span class="line"><span class="comment"># -o nfsvers=4 指定版本，可根据你的NAS调整</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t nfs 192.168.1.100:/shared_data /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 验证挂载是否成功</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 你应该能看到类似下面的一行</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/shared_data   50T   10T   40T   20% /mnt/nas_data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. (重要) 设置开机自动挂载，防止服务器重启后服务失效</span></span><br><span class="line"><span class="comment"># 编辑 /etc/fstab 文件</span></span><br><span class="line"><span class="built_in">sudo</span> nano /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾添加一行 (使用 nofail 选项防止NAS故障导致服务器无法启动)</span></span><br><span class="line">192.168.1.100:/shared_data /mnt/nas_data nfs defaults,nofail 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="第三步：使用-Docker-Compose-部署-MinIO">第三步：使用 Docker Compose 部署 MinIO</h3><p>使用 Docker Compose 是部署和管理 MinIO 最简单、最可靠的方式。</p><ol><li><p><strong>在 MinIO Server 上安装 Docker 和 Docker Compose。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker Compose</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-compose</span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个工作目录并编写 <code>docker-compose.yml</code> 文件。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> minio-deployment</span><br><span class="line"><span class="built_in">cd</span> minio-deployment</span><br><span class="line">nano docker-compose.yml</span><br></pre></td></tr></table></figure></li><li><p><strong>将以下内容粘贴到 <code>docker-compose.yml</code> 文件中：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="comment"># 使用官方 MinIO 镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">local-oss-server</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义环境变量 (请务必修改密码)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Access Key (用户名)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_USER:</span> <span class="string">minioadmin</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Secret Key (密码, 至少8位)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_PASSWORD:</span> <span class="string">VERY_SECRET_PASSWORD_CHANGE_ME</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># volumes 卷挂载是核心</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们刚刚挂载的 NAS 目录，映射到 MinIO 容器内部的 /data 目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas_data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas:/data2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ports 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 9000 端口是 S3 API 的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="comment"># 9001 端口是 MinIO Web 控制台的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># command 命令</span></span><br><span class="line">    <span class="comment"># 告诉 MinIO 启动一个服务器，并使用容器内的 /data 目录作为存储根目录</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span> <span class="string">/data2</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 健康检查，确保服务正常运行</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动 MinIO 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><h3 id="第四步：验证和使用">第四步：验证和使用</h3><p>现在，你的本地 OSS 服务已经搭建完成并开始运行了！</p><ol><li><p><strong>访问 Web 控制台</strong>：</p><ul><li>在浏览器中打开 <code>http://&lt;MinIO_Server_IP&gt;:9001</code>。</li><li>使用你在 <code>docker-compose.yml</code> 中设置的 <code>MINIO_ROOT_USER</code> (minioadmin) 和 <code>MINIO_ROOT_PASSWORD</code> 登录。</li></ul></li><li><p><strong>查看数据</strong>：</p><ul><li>登录后，你会看到 MinIO 的界面。点击 “Buckets”（存储桶）。</li><li><strong>你会惊喜地发现，你在 NAS 目录 <code>/mnt/nas_data</code> 下的所有一级子目录，都已经自动变成了 MinIO 的 Buckets！</strong></li><li>例如，如果你的 NAS 目录结构是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nas_data/</span><br><span class="line">├── images/</span><br><span class="line">│   ├── cat.jpg</span><br><span class="line">│   └── dog.png</span><br><span class="line">└── videos/</span><br><span class="line">    └── movie.mp4</span><br></pre></td></tr></table></figure></li><li>那么在 MinIO 控制台里，你就会看到两个 bucket：<code>images</code> 和 <code>videos</code>。你可以直接点击进入并管理里面的文件。</li></ul></li><li><p><strong>使用 S3 API 访问</strong>：</p><ul><li><strong>Endpoint (服务地址)</strong>: <code>http://&lt;MinIO_Server_IP&gt;:9000</code></li><li><strong>Access Key</strong>: <code>minioadmin</code></li><li><strong>Secret Key</strong>: <code>VERY_SECRET_PASSWORD_CHANGE_ME</code></li><li>你可以使用任何支持 S3 的客户端工具（如 <code>s3cmd</code>, <code>mc</code>, AWS SDK）来连接和操作你的数据。</li></ul><p><strong>使用 MinIO Client (mc) 的示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载 mc</span></span><br><span class="line">wget https://dl.min.io/client/mc/release/linux-amd64/mc</span><br><span class="line"><span class="built_in">chmod</span> +x mc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> mc /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置一个别名，指向你的本地 OSS</span></span><br><span class="line">mc <span class="built_in">alias</span> <span class="built_in">set</span> local-oss http://&lt;MinIO_Server_IP&gt;:9000 minioadmin VERY_SECRET_PASSWORD_CHANGE_ME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 列出所有的 bucket (即 NAS 上的一级目录)</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 列出 images bucket 里的所有文件</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss/images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 上传一个新文件到 videos bucket</span></span><br><span class="line">mc <span class="built_in">cp</span> my_new_video.mp4 local-oss/videos</span><br><span class="line"><span class="comment"># 执行后，你会在 NAS 的 /mnt/nas_data/videos/ 目录下看到 my_new_video.mp4 文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="问题">问题</h3><ul><li>重启后残留文件清理</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf .minio.sys</span><br><span class="line">docker-compose down &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过 <strong>NAS 挂载 + MinIO Docker 部署</strong> 这个简单的两步组合，你成功地将传统的 NAS 文件存储“包装”成了一个功能强大、接口标准、易于扩展的本地对象存储服务。这个方案兼具了 NAS 的大容量存储成本优势和 OSS 的现代化接口优势，是盘活存量数据资产的绝佳实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;整体架构&quot;&gt;整体架构&lt;/h3&gt;
&lt;p&gt;这个架构的核心思想是：&lt;strong&gt;MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。&lt;/strong&gt; 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 FFmpeg 的视频场景（镜头边界）检测</title>
    <link href="https://caozhaoqi.github.io/2025/07/02/ffmpeg-detect-scene/"/>
    <id>https://caozhaoqi.github.io/2025/07/02/ffmpeg-detect-scene/</id>
    <published>2025-07-02T10:44:48.000Z</published>
    <updated>2025-11-25T15:05:10.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在视频处理领域，场景检测（Scene Detection）或称镜头分割（Shot Boundary Detection）是一项基础且关键的任务，广泛应用于视频索引、自动剪辑、内容摘要等场景。</p></blockquote><h2 id="1-技术可行性分析-Feasibility-Analysis"><strong>1. 技术可行性分析 (Feasibility Analysis)</strong></h2><p>将 FFmpeg 用于场景检测不仅可行，而且是一种非常成熟和高效的方案。其可行性主要基于以下几点：</p><ul><li><strong>内置的专业滤镜</strong>: FFmpeg 内置了专门为媒体分析设计的强大滤镜（filters），如 <code>scdet</code> 和 <code>select</code>，它们可以直接访问视频帧的底层数据，并进行快速的数学运算。</li><li><strong>像素级差异计算</strong>: 场景检测的核心原理是计算连续视频帧之间的视觉差异。当差异超过某个阈值时，即认为发生了场景切换。FFmpeg 的滤镜能够高效地执行这种像素级的直方图或帧差计算，并将结果量化为一个“场景变化分数”（scene score）。</li><li><strong>跨平台与标准化</strong>: FFmpeg 是一个跨平台的命令行工具，在 Windows, macOS, Linux 上表现一致，无需依赖复杂的图形界面或特定操作系统API。这使其成为自动化、服务器端处理流程的理想选择。</li><li><strong>轻量级与零依赖</strong>: 与需要安装庞大依赖库的专业软件或Python库相比，FFmpeg 只有一个可执行文件，部署简单，资源占用极低。</li></ul><p><strong>结论</strong>: FFmpeg 提供了实现场景检测所需的核心功能，其性能和标准化特性使其成为一个高度可行的技术选型。</p><h2 id="2-实现方法-Implementation"><strong>2. 实现方法 (Implementation)</strong></h2><p>实现 FFmpeg 场景检测的最佳实践是结合 <code>select</code> 和 <code>showinfo</code> 两个滤镜。这种方法比单独使用老旧的 <code>scdet</code> 滤镜输出更干净、更可靠。</p><p><strong>核心命令</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="string">&quot;input.mp4&quot;</span> -vf <span class="string">&quot;select=&#x27;gt(scene,THRESHOLD)&#x27;,showinfo&quot;</span> -f null -</span><br></pre></td></tr></table></figure><p><strong>命令解析</strong>:</p><ol><li><code>ffmpeg -i &quot;input.mp4&quot;</code>: 指定输入视频文件。</li><li><code>-vf &quot;...&quot;</code>: <code>-vf</code> 是 <code>-filter:v</code> 的缩写，用于指定视频滤镜链。</li><li><code>select='gt(scene,THRESHOLD)'</code>: 这是核心的<strong>选择滤镜</strong>。<ul><li><code>scene</code>: FFmpeg 内置的一个变量，代表当前帧与前一帧的场景变化分数（范围 0.0 到 1.0）。</li><li><code>gt(a, b)</code>: “Greater Than” 函数，当 <code>a &gt; b</code> 时返回真。</li><li><code>THRESHOLD</code>: 这是一个<strong>可调阈值</strong>（例如 <code>0.4</code>）。值越低，检测越灵敏。该滤镜会筛选出所有场景变化分数大于阈值的视频帧。</li></ul></li><li><code>,showinfo</code>: 这是<strong>信息打印滤镜</strong>。它会接收由 <code>select</code> 滤镜筛选出的帧，并在标准错误流（stderr）中打印出这些帧的详细信息，格式高度统一。</li><li><code>-f null -</code>: 指示 FFmpeg 不生成任何输出文件，仅执行滤镜分析，并将结果输出到标准输出/错误流。</li></ol><p><strong>Python 脚本实现</strong>:</p><p>在实际应用中，我们通常使用 Python 的 <code>subprocess</code> 模块来调用此命令并解析其输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_scenes_with_ffmpeg</span>(<span class="params">video_path, threshold=<span class="number">0.4</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 FFmpeg 检测视频场景切换点。&quot;&quot;&quot;</span></span><br><span class="line">    command = [</span><br><span class="line">        <span class="string">&quot;ffmpeg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">        <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;gt(scene,<span class="subst">&#123;threshold&#125;</span>)&#x27;,showinfo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;null&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    process = subprocess.Popen(command, stderr=subprocess.PIPE, text=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    timestamps = []</span><br><span class="line">    <span class="comment"># 正则表达式专门匹配 showinfo 输出的 pts_time</span></span><br><span class="line">    regex = <span class="string">r&quot;\[Parsed_showinfo.*\] .* pts_time:([0-9]+\.?[0-9]*)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> process.stderr:</span><br><span class="line">        <span class="keyword">match</span> = re.search(regex, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            timestamps.append(<span class="built_in">float</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)))</span><br><span class="line">            </span><br><span class="line">    process.wait()</span><br><span class="line">    <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;FFmpeg command failed.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> timestamps</span><br></pre></td></tr></table></figure><h2 id="3-测试与验证方法-Testing-Validation"><strong>3. 测试与验证方法 (Testing &amp; Validation)</strong></h2><p>要验证 FFmpeg 场景检测的准确性，需要系统性的测试方法。</p><ol><li><p><strong>构建测试集 (Test Dataset Construction)</strong>:</p><ul><li><strong>正样本</strong>: 包含多种类型场景切换的视频。<ul><li><strong>硬切 (Hard Cuts)</strong>: 瞬间切换，FFmpeg 检测效果最好。</li><li><strong>淡入淡出 (Fades)</strong>: 逐渐变黑或从黑屏出现。</li><li><strong>叠化 (Dissolves)</strong>: 两个场景平滑过渡。</li><li><strong>快速运动/闪光</strong>: 容易产生误报的场景，如爆炸、相机快速摇晃、闪光灯。</li></ul></li><li><strong>负样本</strong>: 长镜头、无明显切换的视频，用于测试是否会产生误报。</li></ul></li><li><p><strong>人工标注 (Ground Truth Annotation)</strong>:</p><ul><li>使用视频编辑软件（如 Adobe Premiere, Final Cut Pro）手动记录测试集中所有场景切换的精确时间戳，作为“黄金标准”或“基准真相”（Ground Truth）。</li></ul></li><li><p><strong>量化评估指标 (Quantitative Metrics)</strong>:</p><ul><li>将 FFmpeg 检测出的时间戳与人工标注的时间戳进行比对（允许一个小的容忍窗口，如 ±0.5秒）。</li><li>计算以下指标：<ul><li><strong>精确率 (Precision)</strong>: <code>TP / (TP + FP)</code>，检测出的转场中有多少是正确的。</li><li><strong>召回率 (Recall)</strong>: <code>TP / (TP + FN)</code>，所有真实转场中，有多少被成功检测出来了。</li><li><strong>F1-Score</strong>: <code>2 * (Precision * Recall) / (Precision + Recall)</code>，精确率和召回率的调和平均值，是综合评估性能的常用指标。</li><li><code>TP</code> (True Positives): 正确检测到的转场。</li><li><code>FP</code> (False Positives): 误报的转场。</li><li><code>FN</code> (False Negatives): 漏掉的转场。</li></ul></li></ul></li><li><p><strong>阈值调优</strong>:</p><ul><li>通过在测试集上运行不同阈值（例如从 0.2 到 0.7），绘制 Precision-Recall 曲线，找到在特定应用场景下 F1-Score 最高的最佳阈值。</li></ul></li></ol><h2 id="4-优缺点分析-Pros-and-Cons"><strong>4. 优缺点分析 (Pros and Cons)</strong></h2><p><strong>优点 (Pros)</strong>:</p><ul><li><strong>性能卓越</strong>: 作为C语言编写的高度优化的程序，FFmpeg 的处理速度极快，远超许多高级语言实现的库。</li><li><strong>资源占用低</strong>: 内存和CPU占用都很小，非常适合在资源受限的环境或大规模服务器集群上运行。</li><li><strong>部署简单</strong>: 无需复杂的依赖安装，一个可执行文件即可搞定。</li><li><strong>高度可定制与集成</strong>: 可以通过调整阈值来控制灵敏度，并且能与 FFmpeg 其他上百种滤镜和功能（如切片、转码、截图）在同一个命令中无缝集成，形成强大的处理流水线。</li><li><strong>免费与开源</strong>: 无任何商业成本，社区活跃，文档丰富。</li></ul><p><strong>缺点 (Cons)</strong>:</p><ul><li><strong>仅基于像素，不理解内容</strong>: 这是其核心局限。FFmpeg 无法理解视频的语义。<ul><li><strong>对渐变转场不敏感</strong>: 对于淡入淡出、叠化等缓慢变化的转场，由于连续帧差异小，很容易被漏检 (False Negatives)。</li><li><strong>对剧烈运动敏感</strong>: 快速的镜头移动、爆炸、闪光灯等非场景切换的剧烈视觉变化，很容易被误报 (False Positives)。</li><li><strong>无法识别转场类型</strong>: 它只能告诉你“这里发生了变化”，但无法区分是硬切还是其他特效。</li></ul></li><li><strong>阈值依赖性强</strong>: 效果好坏严重依赖于阈值的设定，而“最佳阈值”对于不同类型（如动画、电影、Vlog）的视频可能完全不同，需要经验或实验来确定。</li><li><strong>需要外部调用与解析</strong>: 它不是一个原生库，在 Python 等语言中使用时，必须通过子进程调用，并编写正则表达式等代码来解析其文本输出，增加了集成的复杂性。</li></ul><h2 id="5-效率评估-Efficiency-Evaluation"><strong>5. 效率评估 (Efficiency Evaluation)</strong></h2><p>FFmpeg 的效率是其最显著的优势之一。</p><ul><li><strong>处理速度</strong>: 在现代多核 CPU 上，处理一个 1080p 的视频文件，其速度通常可以达到实时速度的数倍甚至数十倍（例如，处理1小时的视频可能只需要几分钟）。由于其主要进行数学计算，性能瓶颈通常在于磁盘 I/O 或 CPU 单核性能。</li><li><strong>与 PySceneDetect 的对比</strong>:<ul><li><code>PySceneDetect</code> (使用 OpenCV 后端) 同样高效，但通常会比 FFmpeg 稍慢，因为它有 Python 层的开销。</li><li>当 <code>PySceneDetect</code> 使用更复杂的检测器（如 <code>ThresholdDetector</code>，检测黑场/白场）时，其开销会进一步增加。</li><li>FFmpeg 的优势在于其纯 C 实现和极简的计算逻辑，使其在原始速度上通常保持领先。</li></ul></li><li><strong>内存使用</strong>: FFmpeg 采用流式处理（streaming），一次只在内存中保留少量帧进行计算，因此内存占用非常稳定且低下，即便是处理数小时的长视频也不会耗尽内存。</li></ul><p><strong>优化建议</strong>: 虽然 FFmpeg 已经很快，但对于超高分辨率视频（如 4K, 8K），可以通过在滤镜链中加入 <code>scale</code> 滤镜进行<strong>降采样</strong>来进一步提速，例如 <code>scale=640:-1</code>，这通常不会影响硬切检测的准确性。</p><h2 id="6-案例">6. 案例</h2><ul><li>code</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Any</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. Setup Logging ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_logging</span>(<span class="params">log_file: <span class="built_in">str</span> = <span class="string">&quot;analysis.log&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Configures logging to file and console.&quot;&quot;&quot;</span></span><br><span class="line">    logging.basicConfig(</span><br><span class="line">        level=logging.INFO,</span><br><span class="line">        <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s [%(levelname)s] - %(message)s&quot;</span>,</span><br><span class="line">        handlers=[</span><br><span class="line">            logging.FileHandler(log_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">            logging.StreamHandler()  <span class="comment"># Also print to console</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_video_transitions</span>(<span class="params"></span></span><br><span class="line"><span class="params">        video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ffmpeg_path: <span class="built_in">str</span> = <span class="string">&quot;ffmpeg&quot;</span>,</span></span><br><span class="line"><span class="params">        threshold: <span class="built_in">float</span> = <span class="number">0.4</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[<span class="type">List</span>[<span class="built_in">float</span>], <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Analyzes a video file for scene transitions using ffmpeg.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function uses the &#x27;select&#x27; and &#x27;showinfo&#x27; filters in ffmpeg, which is a</span></span><br><span class="line"><span class="string">    more robust method than parsing the output of &#x27;scdet&#x27; alone. It identifies</span></span><br><span class="line"><span class="string">    frames where the scene change score exceeds a given threshold.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        video_path: The absolute or relative path to the video file.</span></span><br><span class="line"><span class="string">        ffmpeg_path: The path to the ffmpeg executable. Defaults to &#x27;ffmpeg&#x27;.</span></span><br><span class="line"><span class="string">        threshold: The sensitivity for scene detection, from 0.0 to 1.0.</span></span><br><span class="line"><span class="string">                   Lower values detect more transitions. A common default is 0.4.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A tuple containing:</span></span><br><span class="line"><span class="string">        - A sorted list of timestamps (in seconds) where transitions were detected.</span></span><br><span class="line"><span class="string">        - The complete, raw stderr output from the ffmpeg command for debugging.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        FileNotFoundError: If the ffmpeg executable is not found at ffmpeg_path.</span></span><br><span class="line"><span class="string">        FFmpegError: If ffmpeg returns a non-zero exit code, indicating an error</span></span><br><span class="line"><span class="string">                     (e.g., invalid video file, incorrect parameters).</span></span><br><span class="line"><span class="string">        ValueError: If the provided video_path does not exist.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># It&#x27;s good practice to check for file existence early</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(video_path):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Video file not found at: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This command is more robust:</span></span><br><span class="line">    <span class="comment"># - `select=&#x27;gt(scene,&#123;threshold&#125;)&#x27;`: Selects frames where the scene change</span></span><br><span class="line">    <span class="comment">#   score is greater than the threshold.</span></span><br><span class="line">    <span class="comment"># - `showinfo`: Prints information about the selected frames to stderr.</span></span><br><span class="line">    <span class="comment"># The output is structured and easy to parse.</span></span><br><span class="line">    command = [</span><br><span class="line">        ffmpeg_path,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">        <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;gt(scene,<span class="subst">&#123;threshold&#125;</span>)&#x27;,showinfo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;null&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        process = subprocess.Popen(</span><br><span class="line">            command,</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.PIPE,</span><br><span class="line">            text=<span class="literal">True</span>,</span><br><span class="line">            encoding=<span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">            errors=<span class="string">&#x27;replace&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(</span><br><span class="line">            <span class="string">f&quot;ffmpeg executable not found at &#x27;<span class="subst">&#123;ffmpeg_path&#125;</span>&#x27;. &quot;</span></span><br><span class="line">            <span class="string">&quot;Please install ffmpeg or provide the correct path.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process stderr line-by-line for memory efficiency</span></span><br><span class="line">    timestamps = []</span><br><span class="line">    <span class="comment"># The regex now specifically looks for &#x27;pts_time&#x27; from the showinfo filter</span></span><br><span class="line">    regex = <span class="string">r&quot;\[Parsed_showinfo.*\] .* pts_time:([0-9]+\.?[0-9]*)&quot;</span></span><br><span class="line"></span><br><span class="line">    stderr_lines = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> process.stderr:</span><br><span class="line">        stderr_lines.append(line)</span><br><span class="line">        <span class="keyword">match</span> = re.search(regex, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            time_str = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> time_str:</span><br><span class="line">                timestamps.append(<span class="built_in">float</span>(time_str))</span><br><span class="line"></span><br><span class="line">    process.wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check for ffmpeg errors after processing is complete</span></span><br><span class="line">    <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">        full_stderr = <span class="string">&quot;&quot;</span>.join(stderr_lines)</span><br><span class="line">        <span class="comment"># raise FFmpegError(</span></span><br><span class="line">        <span class="comment">#     f&quot;ffmpeg failed with exit code &#123;process.returncode&#125;.\n&quot;</span></span><br><span class="line">        <span class="comment">#     f&quot;Command: &#123;&#x27; &#x27;.join(command)&#125;\n&quot;</span></span><br><span class="line">        <span class="comment">#     f&quot;Stderr:\n&#123;full_stderr&#125;&quot;</span></span><br><span class="line">        <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Timestamps from showinfo should already be in order, but sorting is safe</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(timestamps), <span class="string">&quot;&quot;</span>.join(stderr_lines)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Main function to run the analysis script.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Configuration ---</span></span><br><span class="line">    <span class="comment"># 1. Setup logging first</span></span><br><span class="line">    log_file = <span class="string">&quot;./logs/transition_analysis.log&quot;</span></span><br><span class="line">    os.makedirs(log_file, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    setup_logging(log_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Get user input for video directory</span></span><br><span class="line">    video_directory = <span class="string">&quot;/Volumes/share/新建文件夹/7，1数据&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. Output JSON file path</span></span><br><span class="line">    output_json_path = <span class="string">&quot;./data/transition_analysis_results.json&quot;</span></span><br><span class="line"></span><br><span class="line">    os.makedirs(<span class="string">&quot;./data&quot;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. (Optional) FFmpeg executable path</span></span><br><span class="line">    ffmpeg_executable = <span class="string">&quot;ffmpeg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. Supported video file extensions</span></span><br><span class="line">    supported_extensions = &#123;<span class="string">&quot;.mp4&quot;</span>, <span class="string">&quot;.mkv&quot;</span>, <span class="string">&quot;.mov&quot;</span>, <span class="string">&quot;.avi&quot;</span>, <span class="string">&quot;.webm&quot;</span>, <span class="string">&quot;.flv&quot;</span>&#125;</span><br><span class="line">    <span class="comment"># --- End of Configuration ---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(video_directory):</span><br><span class="line">        logging.error(<span class="string">f&quot;Directory not found at &#x27;<span class="subst">&#123;video_directory&#125;</span>&#x27;. Aborting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    all_results: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">&quot;Starting video transition analysis...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 2. Find all video files first to set up the progress bar ---</span></span><br><span class="line">    video_files_to_process = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(video_directory):</span><br><span class="line">        file_path = os.path.join(video_directory, filename)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path) <span class="keyword">and</span> Path(filename).suffix.lower() <span class="keyword">in</span> supported_extensions:</span><br><span class="line">            video_files_to_process.append(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files_to_process:</span><br><span class="line">        logging.warning(<span class="string">&quot;No video files found in the specified directory.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 3. Process files with a tqdm progress bar ---</span></span><br><span class="line">    <span class="keyword">with</span> tqdm(total=<span class="built_in">len</span>(video_files_to_process), desc=<span class="string">&quot;Analyzing Videos&quot;</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">for</span> video_path <span class="keyword">in</span> video_files_to_process:</span><br><span class="line">            filename = os.path.basename(video_path)</span><br><span class="line">            pbar.set_description(<span class="string">f&quot;Processing <span class="subst">&#123;filename[:<span class="number">20</span>]&#125;</span>...&quot;</span>)  <span class="comment"># Update progress bar description</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                transition_times, ffmpeg_log = analyze_video_transitions(video_path, ffmpeg_executable)</span><br><span class="line"></span><br><span class="line">                logging.info(<span class="string">f&quot;Successfully analyzed &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;. Found <span class="subst">&#123;<span class="built_in">len</span>(transition_times)&#125;</span> transitions.&quot;</span>)</span><br><span class="line">                all_results[filename] = &#123;</span><br><span class="line">                    <span class="string">&quot;file_path&quot;</span>: video_path,</span><br><span class="line">                    <span class="string">&quot;transitions&quot;</span>: transition_times,</span><br><span class="line">                    <span class="string">&quot;transition_count&quot;</span>: <span class="built_in">len</span>(transition_times)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(<span class="string">f&quot;Failed to analyze &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment"># Also log the full ffmpeg output for debugging</span></span><br><span class="line">                logging.debug(<span class="string">f&quot;FFmpeg stderr for failed file &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;:\n<span class="subst">&#123;ffmpeg_log&#125;</span>&quot;</span>)</span><br><span class="line">                all_results[filename] = &#123;</span><br><span class="line">                    <span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            pbar.update(<span class="number">1</span>)  <span class="comment"># Move progress bar forward by one step</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save the results to a JSON file</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_json_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(all_results, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        logging.info(<span class="string">f&quot;Analysis complete. Results saved to &#x27;<span class="subst">&#123;output_json_path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;Error saving results to JSON file: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>output</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;6月27日 (1)-71.mp4&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;file_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Volumes/share/新建文件夹/7，1数据/6月27日 (1)-71.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;transitions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">4.0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">7.666667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">11.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">16.566667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">22.866667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">27.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">29.266667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">34.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">36.966667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">49.566667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">57.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">61.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">63.5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">69.866667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">74.8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">79.466667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">81.266667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">84.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">88.266667</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;transition_count&quot;</span><span class="punctuation">:</span> <span class="number">19</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>log</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2025-07-02 17:50:43,359 [INFO] - Successfully analyzed &#x27;._6月27日 (1)-36.mp4&#x27;. Found 0 transitions.</span><br><span class="line">2025-07-02 17:50:55,619 [INFO] - Successfully analyzed &#x27;6月27日 (1)-71.mp4&#x27;. Found 19 transitions.</span><br><span class="line">2025-07-02 17:50:55,620 [INFO] - Analysis complete. Results saved to &#x27;transition_analysis_results.json&#x27;</span><br></pre></td></tr></table></figure><h2 id="结论"><strong>结论</strong></h2><h3 id="检出效果对比">检出效果对比</h3><table><thead><tr><th style="text-align:left">对比项</th><th style="text-align:left"><strong>方法一: PySceneDetect (pyscenedetect_analysis.py)</strong></th><th style="text-align:left"><strong>方法二: FFmpeg (transition_analysis.py)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心技术</strong></td><td style="text-align:left">使用专业的Python场景检测库 <code>scenedetect</code>。通过 <code>ContentDetector</code> 算法，比较连续帧在亮度（luma）和色度（chroma）上的变化来识别场景切换。</td><td style="text-align:left">调用外部命令行工具 FFmpeg，并使用其内置的 <code>select</code> 和 <code>showinfo</code> 滤镜组合。该方法基于一个简单的“场景变化分数”（scene score）进行阈值判断。</td></tr><tr><td style="text-align:left"><strong>检测灵敏度与准确性</strong></td><td style="text-align:left"><strong>高</strong>。此方法非常灵敏，能稳定地识别出大量的有效场景切换点。其算法对硬切（Hard Cuts）的识别准确率很高。</td><td style="text-align:left"><strong>依赖阈值，默认较低</strong>。在 <code>threshold=0.4</code> 的设置下，灵敏度可能不足，导致大量明显的镜头切换被漏检。需要针对视频内容进行细致的阈值调优才能达到理想效果。</td></tr><tr><td style="text-align:left"><strong>结果对比 (示例)</strong></td><td style="text-align:left"><code>6月27日 (1)-47.mp4</code>: 检出 <strong>46</strong> 个<br><code>6月27日 (1)-49.mp4</code>: 检出 <strong>43</strong> 个<br><code>6.27(1)-64.mp4</code>: 检出 <strong>17</strong> 个</td><td style="text-align:left"><code>6月27日 (1)-47.mp4</code>: 检出 <strong>0</strong> 个<br><code>6月27日 (1)-49.mp4</code>: 检出 <strong>33</strong> 个<br><code>6.27(1)-64.mp4</code>: 检出 <strong>4</strong> 个</td></tr><tr><td style="text-align:left"><strong>文件处理健壮性</strong></td><td style="text-align:left"><strong>高</strong>。脚本中加入了明确的逻辑，能自动识别并跳过 macOS 系统产生的无效元数据文件（如 <code>._filename.mp4</code>），避免了因处理无效文件而导致的程序崩溃或错误。</td><td style="text-align:left"><strong>中等</strong>。脚本会尝试处理 <code>._</code> 开头的无效文件。虽然 FFmpeg 本身通常不会因此崩溃（会报告错误并退出），但这浪费了处理时间，并在日志和结果文件中留下了无效条目。</td></tr><tr><td style="text-align:left"><strong>性能与效率</strong></td><td style="text-align:left"><strong>中等</strong>。单个文件处理速度相对较慢，因其在Python层有一定开销。但通过自动降采样（downscaling）高分辨率视频，性能已得到显著优化，最终以可接受的速度换取高质量的检测结果。</td><td style="text-align:left"><strong>非常高</strong>。作为C语言编写的底层工具，单个文件处理速度极快。但这种速度优势建立在算法相对简单的基础上，牺牲了部分准确性和对复杂转场的识别能力。</td></tr><tr><td style="text-align:left"><strong>易用性与集成</strong></td><td style="text-align:left"><strong>高</strong>。作为原生Python库，集成方便，无需处理外部进程和解析文本输出。API友好，返回直接可用的Python数据结构（如列表）。</td><td style="text-align:left"><strong>中等</strong>。需要通过 <code>subprocess</code> 模块调用，并编写正则表达式来解析 <code>stderr</code> 输出，集成相对复杂，且容易因FFmpeg版本更新导致解析逻辑失效。</td></tr><tr><td style="text-align:left"><strong>依赖与部署</strong></td><td style="text-align:left"><strong>中等</strong>。需要通过 <code>pip</code> 安装 <code>scenedetect</code> 及其依赖（如 <code>opencv-python</code>），环境配置相对复杂。</td><td style="text-align:left"><strong>简单</strong>。仅依赖于一个单一的 FFmpeg 可执行文件，部署和分发非常方便。</td></tr><tr><td style="text-align:left"><strong>推荐场景</strong></td><td style="text-align:left">适用于对<strong>检测准确性要求高</strong>、需要稳定可靠结果的应用。是构建专业视频分析工具和服务的首选。</td><td style="text-align:left">适用于对<strong>处理速度要求极高</strong>、资源受限，且主要任务是检测硬切（Hard Cuts）的批量自动化流程。</td></tr></tbody></table><h3 id="检出数目对比">检出数目对比</h3><table><thead><tr><th style="text-align:left">检测方法</th><th style="text-align:left">分析的视频总数</th><th style="text-align:left">成功检出转场的视频数</th><th style="text-align:left">检出率</th></tr></thead><tbody><tr><td style="text-align:left">方法一: PySceneDetect</td><td style="text-align:left">48</td><td style="text-align:left">37</td><td style="text-align:left">77.1%</td></tr><tr><td style="text-align:left">方法二: FFmpeg</td><td style="text-align:left">48</td><td style="text-align:left">19</td><td style="text-align:left">39.6%</td></tr></tbody></table><h3 id="总结">总结</h3><ul><li><p>PySceneDetect 效果远胜 FFmpeg：PySceneDetect 成功在 37 个视频中找到了转场，而 FFmpeg 只在其中的 19 个视频中找到了转场。PySceneDetect 的“命中率”几乎是 FFmpeg 的两倍。</p></li><li><p>FFmpeg 漏检严重：从数据可以看出，FFmpeg 的方法漏掉了大量有转场的视频。例如，在 PySceneDetect 检出 80 个转场的 6月27日 (1)-7.mp4 视频中，FFmpeg 的结果为 0。这种巨大的差异表明 FFmpeg 的 scdet 滤镜在当前参数下过于迟钝，不适合用于精确的场景切分。</p></li></ul><blockquote><p>FFmpeg 是一种用于视频场景检测的“快、准（对硬切而言）、狠”的工具**。它非常适合于需要<strong>大规模、自动化、快速处理</strong>视频，且主要目标是检测<strong>硬切</strong>的场景。它的高性能、低资源占用和强大的集成能力使其在后端服务和数据预处理流程中具有不可替代的价值。</p></blockquote><h2 id="See">See</h2><ul><li><a href="https://ffmpeg.org/ffmpeg-bitstream-filters.html">https://ffmpeg.org/ffmpeg-bitstream-filters.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在视频处理领域，场景检测（Scene Detection）或称镜头分割（Shot Boundary Detection）是一项基础且关键的任务，广泛应用于视频索引、自动剪辑、内容摘要等场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>TransNetV2模型用于视频复杂转场检测</title>
    <link href="https://caozhaoqi.github.io/2025/06/09/TransNetV2-model-use/"/>
    <id>https://caozhaoqi.github.io/2025/06/09/TransNetV2-model-use/</id>
    <published>2025-06-09T02:39:48.000Z</published>
    <updated>2025-11-25T15:05:10.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TransNet-V2-模型介绍">TransNet V2 模型介绍</h2><ol><li>目标：<br>TransNet V2 的目标是创建一个快速且准确的镜头边界检测（Shot Boundary Detection, SBD）模型。它能够识别视频中的两种主要类型的镜头切换：<ul><li>硬切 (Hard Cuts): 两个镜头之间的突变。</li><li>渐变转场 (Gradual Transitions): 如溶解 (dissolves)、淡入淡出 (fades)、划像 (wipes) 等，这些转场会持续数帧。</li></ul></li></ol><ul><li>模型架构</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/transnetv2_struct.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/transnetv2_struct.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol start="2"><li><p>核心思想：<br>TransNet V2 是一个深度神经网络。它直接处理一系列连续的、低分辨率的 RGB 视频帧，来预测每一帧发生镜头转换的概率，并能区分转场类型。</p></li><li><p>关键架构特点：</p><ul><li>输入 (Input)：<ul><li>模型接收 <code>N</code> 个连续的、低分辨率 RGB 视频帧作为输入（例如，论文中常使用 <code>N=100</code> 帧，每帧分辨率缩小到 <code>48x27</code> 像素）。</li><li>直接使用原始的、降采样后的 RGB 帧（而不是预先计算的特征，如帧差或光流）使得网络可以端到端地学习最优的视觉特征。</li></ul></li><li>帧编码 (Frame Encoding)：<ul><li>输入的每一帧首先会经过两个 2D 卷积层和最大池化层，用于提取空间特征。</li><li>这些特征图随后被展平 (flatten) 并按时间顺序堆叠起来，形成一个特征序列。</li></ul></li><li>时间建模 (Temporal Modeling) - 核心部分：<ul><li>TransNet V2 的核心是一堆一维扩张卷积 (1D Dilated Convolutions) 块，它们作用于帧特征序列。</li><li>一维卷积： 非常适合处理序列数据，计算效率高。</li><li>扩张卷积 (Dilated Convolutions)： 允许网络在不显著增加参数数量或计算成本（通过避免过多的池化层）的情况下，拥有非常大的感受野（即能看到很长的时间上下文）。这对于检测跨越多帧的渐变转场至关重要。每个扩张卷积块通常包含一个扩张一维卷积层、批量归一化 (Batch Normalization)、ReLU 激活函数和 Dropout。</li></ul></li><li>双预测头 (Dual Prediction Heads)：<br>网络从最后一个扩张卷积层的输出特征中引出两个分支（预测头）：<ol><li>转场概率预测 (Transition Probability Prediction)： 一个核大小为 1 的一维卷积层，后接 Sigmoid 激活函数。对输入序列中的每一帧输出一个概率值（0 到 1），表示该帧是镜头边界（硬切或渐变转场的中心）的可能性。使用二元交叉熵 (BCE) 损失进行训练。</li><li>转场类型预测 (Transition Type Prediction - One-Hot)： 另一个核大小为 1 的一维卷积层，有 3 个输出通道，每个通道后接 Sigmoid。它们分别预测每一帧属于以下类别的概率：<ul><li>无镜头转场</li><li>硬切</li><li>渐变转场的中心<br>这被视为三个独立的二分类问题，同样使用 BCE 损失训练。这个辅助任务有助于网络学习更丰富的特征。</li></ul></li></ol></li><li>组合损失 (Combined Loss)：<br>总损失是两个预测头 BCE 损失的加权和。</li></ul></li><li><p>模型优势：</p><ul><li>高准确性： 在多个标准 SBD 数据集（如 ClipShots, TRECVID IACC.3, RAI, BBC Planet Earth）上取得了业界领先 (SOTA) 的结果。</li><li>高速度： 为效率而设计，在现代 GPU 上能够实现远超实时的处理速度（例如，在 NVIDIA V100 上网络推理部分约 150 FPS，不包括视频解码）。</li><li>鲁棒性强： 能够有效处理硬切和各种复杂的渐变转场。</li><li>端到端学习： 直接从低分辨率 RGB 帧中学习特征，无需复杂的手动特征工程。</li></ul></li></ol><h2 id="TransNet-V2-使用方法-推理与后处理">TransNet V2 使用方法 (推理与后处理)</h2><ol><li><p>输入视频处理：</p><ul><li>将视频解码成单独的帧。</li><li>将每一帧的大小调整到网络所需的输入分辨率（例如 <code>48x27</code> 像素）。</li></ul></li><li><p>滑动窗口推理：</p><ul><li>视频以 <code>N</code> 帧（如 100 帧）的重叠窗口进行处理。</li><li>对于每个窗口，网络从主要的转场概率预测头输出 <code>N</code> 个概率值（对应窗口中的每一帧）。</li><li>由于窗口是重叠的，视频中的同一帧可能会获得多个预测。通常会对这些预测进行平均，以获得该帧更稳定的概率。</li></ul></li><li><p>预测结果后处理：</p><ul><li>阈值化 (Thresholding)：<ul><li>将（平均后的）逐帧概率与一个预定义的阈值 <code>P_thresh</code> 进行比较。概率超过此阈值的帧被认为是候选的镜头边界。</li><li>论文建议 <code>P_thresh = 0.5</code> 是一个不错的默认值，但可以根据实际情况调整。</li></ul></li><li>最小镜头长度 (Minimum Shot Length - <code>L_min</code>)：<ul><li>为了避免产生许多非常短的、可能是误报的镜头，会施加一个约束：任何会导致镜头长度小于 <code>L_min</code> 帧的检测边界都会被丢弃。</li><li>这通常通过遍历候选边界并确保其与前一个已接受边界的距离至少为 <code>L_min</code> 来实现。</li><li>论文中提到根据数据集或期望的粒度使用 <code>L_min</code> 值，如 10 帧或 25 帧。</li></ul></li></ul></li><li><p>输出：</p><ul><li>最终输出是一个列表，包含检测到的镜头边界所在的帧索引号。</li><li>可选地，可以使用转场类型预测头的输出来对检测到的边界进行分类，但通常主要关注的是边界的检测本<br>身。</li></ul></li></ol><ul><li>模型检测结果</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/detect_result.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/detect_result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="使用">使用</h2><h3 id="模型推理">模型推理</h3><ul><li>推理脚本如下：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment"># 引入 sys 以便使用 sys.stderr</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransNetV2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model_dir=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> model_dir <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            model_dir = os.path.join(os.path.dirname(__file__), <span class="string">&quot;transnetv2-weights/&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(model_dir):</span><br><span class="line">                <span class="keyword">raise</span> FileNotFoundError(<span class="string">f&quot;[TransNetV2] ERROR: <span class="subst">&#123;model_dir&#125;</span> is not a directory.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] Using weights from <span class="subst">&#123;model_dir&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._input_size = (<span class="number">27</span>, <span class="number">48</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>._model = tf.saved_model.load(model_dir)</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">raise</span> IOError(<span class="string">f&quot;[TransNetV2] It seems that files in <span class="subst">&#123;model_dir&#125;</span> are corrupted or missing. &quot;</span></span><br><span class="line">                          <span class="string">f&quot;Re-download them manually and retry. For more info, see: &quot;</span></span><br><span class="line">                          <span class="string">f&quot;https://github.com/soCzech/TransNetV2/issues/1#issuecomment-647357796&quot;</span>) <span class="keyword">from</span> exc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_raw</span>(<span class="params">self, frames: np.ndarray</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(frames.shape) == <span class="number">5</span> <span class="keyword">and</span> frames.shape[<span class="number">2</span>:] == <span class="variable language_">self</span>._input_size, \</span><br><span class="line">            <span class="string">&quot;[TransNetV2] Input shape must be [batch, frames, height, width, 3].&quot;</span></span><br><span class="line">        frames = tf.cast(frames, tf.float32)</span><br><span class="line"></span><br><span class="line">        logits, dict_ = <span class="variable language_">self</span>._model(frames)</span><br><span class="line">        single_frame_pred = tf.sigmoid(logits)</span><br><span class="line">        all_frames_pred = tf.sigmoid(dict_[<span class="string">&quot;many_hot&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> single_frame_pred, all_frames_pred</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_frames</span>(<span class="params">self, frames: np.ndarray</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(frames.shape) == <span class="number">4</span> <span class="keyword">and</span> frames.shape[<span class="number">1</span>:] == <span class="variable language_">self</span>._input_size, \</span><br><span class="line">            <span class="string">&quot;[TransNetV2] Input shape must be [frames, height, width, 3].&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">input_iterator</span>():</span><br><span class="line">            <span class="comment"># return windows of size 100 where the first/last 25 frames are from the previous/next batch</span></span><br><span class="line">            <span class="comment"># the first and last window must be padded by copies of the first and last frame of the video</span></span><br><span class="line">            no_padded_frames_start = <span class="number">25</span></span><br><span class="line">            no_padded_frames_end = <span class="number">25</span> + <span class="number">50</span> - (<span class="built_in">len</span>(frames) % <span class="number">50</span> <span class="keyword">if</span> <span class="built_in">len</span>(frames) % <span class="number">50</span> != <span class="number">0</span> <span class="keyword">else</span> <span class="number">50</span>)  <span class="comment"># 25 - 74</span></span><br><span class="line"></span><br><span class="line">            start_frame = np.expand_dims(frames[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            end_frame = np.expand_dims(frames[-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">            padded_inputs = np.concatenate(</span><br><span class="line">                ([start_frame] * no_padded_frames_start) + [frames] + ([end_frame] * no_padded_frames_end), <span class="number">0</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            ptr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> ptr + <span class="number">100</span> &lt;= <span class="built_in">len</span>(padded_inputs):</span><br><span class="line">                out = padded_inputs[ptr:ptr + <span class="number">100</span>]</span><br><span class="line">                ptr += <span class="number">50</span></span><br><span class="line">                <span class="keyword">yield</span> out[np.newaxis]</span><br><span class="line"></span><br><span class="line">        predictions = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在循环外部初始化处理帧数的计数器</span></span><br><span class="line">        processed_frames_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> inp <span class="keyword">in</span> input_iterator():</span><br><span class="line">            single_frame_pred, all_frames_pred = <span class="variable language_">self</span>.predict_raw(inp)</span><br><span class="line">            predictions.append((single_frame_pred.numpy()[<span class="number">0</span>, <span class="number">25</span>:<span class="number">75</span>, <span class="number">0</span>],</span><br><span class="line">                                all_frames_pred.numpy()[<span class="number">0</span>, <span class="number">25</span>:<span class="number">75</span>, <span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">            processed_frames_count = <span class="built_in">min</span>(<span class="built_in">len</span>(predictions) * <span class="number">50</span>, <span class="built_in">len</span>(frames))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\r[TransNetV2] Processing video frames &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                processed_frames_count, <span class="built_in">len</span>(frames)</span><br><span class="line">            ), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保即使视频帧数少于一个批次，也会打印最终的换行符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frames) &gt; <span class="number">0</span>:  <span class="comment"># 只有在有帧的情况下才打印换行，避免空视频也打印</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        single_frame_pred_list = [single_ <span class="keyword">for</span> single_, all_ <span class="keyword">in</span> predictions]</span><br><span class="line">        all_frames_pred_list = [all_ <span class="keyword">for</span> single_, all_ <span class="keyword">in</span> predictions]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> single_frame_pred_list:  <span class="comment"># 如果 predictions 为空 (例如，视频帧数非常少)</span></span><br><span class="line">            <span class="comment"># 根据 frames 的长度创建一个全零的预测数组</span></span><br><span class="line">            <span class="comment"># 这确保了即使没有通过迭代器处理任何内容，也会返回正确形状的数组</span></span><br><span class="line">            <span class="comment"># （尽管对于非常短的视频，这可能仍然不是理想的，但至少避免了 concatenate 空列表的错误）</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 WARNING] No predictions generated from input_iterator for a video of length <span class="subst">&#123;<span class="built_in">len</span>(frames)&#125;</span>. Returning zeros.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            empty_preds_shape = (<span class="built_in">len</span>(frames),)  <span class="comment"># 或者 (0,) 如果 len(frames) 是 0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(frames) == <span class="number">0</span>:  <span class="comment"># 处理0帧视频的极端情况</span></span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([])</span><br><span class="line">            <span class="keyword">return</span> np.zeros(empty_preds_shape, dtype=np.float32), np.zeros(empty_preds_shape, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">        single_frame_pred_concatenated = np.concatenate(single_frame_pred_list)</span><br><span class="line">        all_frames_pred_concatenated = np.concatenate(all_frames_pred_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> single_frame_pred_concatenated[:<span class="built_in">len</span>(frames)], all_frames_pred_concatenated[</span><br><span class="line">                                                             :<span class="built_in">len</span>(frames)]  <span class="comment"># remove extra padded frames</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_video</span>(<span class="params">self, video_fn: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">import</span> ffmpeg</span><br><span class="line">        <span class="keyword">except</span> ModuleNotFoundError:</span><br><span class="line">            <span class="keyword">raise</span> ModuleNotFoundError(<span class="string">&quot;For `predict_video` function `ffmpeg` needs to be installed in order to extract &quot;</span></span><br><span class="line">                                      <span class="string">&quot;individual frames from video file. Install `ffmpeg` command line tool and then &quot;</span></span><br><span class="line">                                      <span class="string">&quot;install python wrapper by `pip install ffmpeg-python`.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2] Extracting frames from &#123;&#125;&quot;</span>.<span class="built_in">format</span>(video_fn))</span><br><span class="line">        video_stream, err = <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># Initialize</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            process = (</span><br><span class="line">                ffmpeg</span><br><span class="line">                .<span class="built_in">input</span>(video_fn)</span><br><span class="line">                .output(<span class="string">&quot;pipe:&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;rawvideo&quot;</span>, pix_fmt=<span class="string">&quot;rgb24&quot;</span>, s=<span class="string">&quot;48x27&quot;</span>)</span><br><span class="line">                .run_async(pipe_stdout=<span class="literal">True</span>, pipe_stderr=<span class="literal">True</span>)</span><br><span class="line">            )</span><br><span class="line">            video_stream, err = process.communicate()  <span class="comment"># Get output after process finishes</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] ffmpeg process failed for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> with exit code <span class="subst">&#123;process.returncode&#125;</span>.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> err:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] ffmpeg stderr:\n<span class="subst">&#123;err.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty arrays indicating failure</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err:  <span class="comment"># Even if return code is 0, check stderr</span></span><br><span class="line">                <span class="comment"># Not all messages on stderr are errors, but log them as warnings</span></span><br><span class="line">                <span class="comment"># Filter out common non-error messages if necessary, or log all for debugging</span></span><br><span class="line">                decoded_err = err.decode(errors=<span class="string">&#x27;ignore&#x27;</span>).strip()</span><br><span class="line">                <span class="keyword">if</span> decoded_err:  <span class="comment"># Only print if there&#x27;s actual content</span></span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 WARNING] ffmpeg stderr for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> (exit code <span class="subst">&#123;process.returncode&#125;</span>):\n<span class="subst">&#123;decoded_err&#125;</span>&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> video_stream:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] ffmpeg produced no video stream for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>. Cannot proceed.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> ffmpeg.Error <span class="keyword">as</span> e_ffmpeg:  <span class="comment"># Catch ffmpeg&#x27;s own errors</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] ffmpeg.Error during frame extraction for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>:&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(e_ffmpeg, <span class="string">&#x27;stderr&#x27;</span>) <span class="keyword">and</span> e_ffmpeg.stderr:</span><br><span class="line">                <span class="built_in">print</span>(e_ffmpeg.stderr.decode(errors=<span class="string">&#x27;ignore&#x27;</span>), file=sys.stderr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(e_ffmpeg), file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_generic_ffmpeg:  <span class="comment"># Catch other potential errors during ffmpeg processing</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Generic exception during ffmpeg processing for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>: <span class="subst">&#123;e_generic_ffmpeg&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> video_stream <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># Should have been caught above, but as a safeguard</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] video_stream is None after ffmpeg processing for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            video = np.frombuffer(video_stream, np.uint8).reshape([-<span class="number">1</span>, <span class="number">27</span>, <span class="number">48</span>, <span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e_reshape:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Failed to reshape video_stream for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>. Stream length: <span class="subst">&#123;<span class="built_in">len</span>(video_stream)&#125;</span>. Error: <span class="subst">&#123;e_reshape&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> video.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Extracted 0 frames from <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> after ffmpeg. Cannot proceed.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (video, *<span class="variable language_">self</span>.predict_frames(video))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predictions_to_scenes</span>(<span class="params">predictions: np.ndarray, threshold: <span class="built_in">float</span> = <span class="number">0.5</span></span>):</span><br><span class="line">        <span class="keyword">if</span> predictions <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> predictions.size == <span class="number">0</span>:  <span class="comment"># Handle empty or None predictions</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 DEBUG] predictions_to_scenes received empty or None predictions. Returning empty scenes.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([], dtype=np.int32)  <span class="comment"># Return empty array of correct type</span></span><br><span class="line"></span><br><span class="line">        predictions = (predictions &gt; threshold).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">        scenes = []</span><br><span class="line">        t, t_prev, start = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, t_current_frame_pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(predictions):  <span class="comment"># Renamed &#x27;t&#x27; to avoid conflict</span></span><br><span class="line">            <span class="keyword">if</span> t_prev == <span class="number">1</span> <span class="keyword">and</span> t_current_frame_pred == <span class="number">0</span>:</span><br><span class="line">                start = i</span><br><span class="line">            <span class="keyword">if</span> t_prev == <span class="number">0</span> <span class="keyword">and</span> t_current_frame_pred == <span class="number">1</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">                scenes.append([start, i])</span><br><span class="line">            t_prev = t_current_frame_pred</span><br><span class="line"></span><br><span class="line">        <span class="comment"># After loop, check if the video ends in a shot (t_prev will be 0 if it ended with a transition, or 1 if it ended mid-shot)</span></span><br><span class="line">        <span class="comment"># The original logic for &#x27;if t == 0:&#x27; was based on the last prediction value.</span></span><br><span class="line">        <span class="comment"># If the last prediction was 0 (meaning it&#x27;s part of a shot that started earlier)</span></span><br><span class="line">        <span class="keyword">if</span> t_prev == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(predictions) &gt; <span class="number">0</span>:  <span class="comment"># Ensure there was at least one prediction</span></span><br><span class="line">            <span class="comment"># If start is not the beginning of the video and a shot has started</span></span><br><span class="line">            <span class="keyword">if</span> start &lt; <span class="built_in">len</span>(predictions):  <span class="comment"># Make sure start is a valid index</span></span><br><span class="line">                scenes.append([start, <span class="built_in">len</span>(predictions) - <span class="number">1</span>])  <span class="comment"># Shot goes to the end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># just fix if all predictions are 1 (no transitions found, so one scene from start to end)</span></span><br><span class="line">        <span class="comment"># or if all predictions are 0 (also one scene from start to end, after fixing start to 0)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scenes <span class="keyword">and</span> <span class="built_in">len</span>(predictions) &gt; <span class="number">0</span>:  <span class="comment"># If no scenes were appended and there are predictions</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 DEBUG] No scenes detected by transition logic, assuming single scene for the entire video.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([[<span class="number">0</span>, <span class="built_in">len</span>(predictions) - <span class="number">1</span>]], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scenes <span class="keyword">and</span> <span class="built_in">len</span>(predictions) == <span class="number">0</span>:  <span class="comment"># If no predictions at all</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 DEBUG] No predictions, returning empty scenes array.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.array(scenes, dtype=np.int32)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visualize_predictions</span>(<span class="params">frames: np.ndarray, predictions</span>):</span><br><span class="line">        <span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> frames.size == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 WARNING] visualize_predictions received no frames. Skipping visualization.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Or a placeholder image</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(predictions, np.ndarray):</span><br><span class="line">            predictions = [predictions]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Filter out None or empty prediction arrays</span></span><br><span class="line">        valid_predictions = []</span><br><span class="line">        <span class="keyword">for</span> p_arr <span class="keyword">in</span> predictions:</span><br><span class="line">            <span class="keyword">if</span> p_arr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> p_arr.size &gt; <span class="number">0</span>:</span><br><span class="line">                valid_predictions.append(p_arr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> valid_predictions:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 WARNING] visualize_predictions received no valid prediction arrays. Skipping visualization.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Or a placeholder image</span></span><br><span class="line">        predictions = valid_predictions</span><br><span class="line"></span><br><span class="line">        ih, iw, ic = frames.shape[<span class="number">1</span>:]</span><br><span class="line">        width = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pad frames so that length of the video is divisible by width</span></span><br><span class="line">        <span class="comment"># pad frames also by len(predictions) pixels in width in order to show predictions</span></span><br><span class="line">        pad_with = width - <span class="built_in">len</span>(frames) % width <span class="keyword">if</span> <span class="built_in">len</span>(frames) % width != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Ensure pad_with is not negative if len(frames) is 0</span></span><br><span class="line">        pad_with = <span class="built_in">max</span>(<span class="number">0</span>, pad_with)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pad frames, ensuring frames is not empty</span></span><br><span class="line">        <span class="keyword">if</span> frames.size &gt; <span class="number">0</span>:</span><br><span class="line">            frames = np.pad(frames, [(<span class="number">0</span>, pad_with), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="built_in">len</span>(predictions)), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># Should not happen if caught earlier, but as a safeguard</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        predictions = [np.pad(x, (<span class="number">0</span>, pad_with)) <span class="keyword">for</span> x <span class="keyword">in</span> predictions]</span><br><span class="line">        height = <span class="built_in">len</span>(frames) // width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height == <span class="number">0</span> <span class="keyword">or</span> width == <span class="number">0</span>:  <span class="comment"># Avoid division by zero or empty reshape</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 WARNING] Cannot create visualization due to zero height or width after padding.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        img = frames.reshape([height, width, ih + <span class="number">1</span>, iw + <span class="built_in">len</span>(predictions), ic])</span><br><span class="line">        img = np.concatenate(np.split(</span><br><span class="line">            np.concatenate(np.split(img, height, axis=<span class="number">0</span>), axis=<span class="number">2</span>)[<span class="number">0</span>], width, axis=<span class="number">1</span>  <span class="comment"># Corrected axis for split</span></span><br><span class="line">        ), axis=<span class="number">2</span>)[<span class="number">0</span>, :-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = Image.fromarray(img)</span><br><span class="line">        draw = ImageDraw.Draw(img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># iterate over all frames</span></span><br><span class="line">        <span class="keyword">for</span> i, pred_tuple <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(*predictions)):  <span class="comment"># pred_tuple contains predictions for frame i</span></span><br><span class="line">            x_base, y_base = i % width, i // width  <span class="comment"># Top-left corner of the frame in the grid</span></span><br><span class="line">            x_offset, y_offset = x_base * (iw + <span class="built_in">len</span>(predictions)) + iw, y_base * (</span><br><span class="line">                    ih + <span class="number">1</span>) + ih - <span class="number">1</span>  <span class="comment"># Bottom-right of frame content, before prediction lines</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># we can visualize multiple predictions per single frame</span></span><br><span class="line">            <span class="keyword">for</span> j, p_value <span class="keyword">in</span> <span class="built_in">enumerate</span>(pred_tuple):  <span class="comment"># j is prediction type index, p_value is its value</span></span><br><span class="line">                color = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">                <span class="comment"># Cycle through R, G, B for different prediction types</span></span><br><span class="line">                color[j % <span class="number">3</span>] = <span class="number">255</span>  <span class="comment"># Use j for color to distinguish prediction types</span></span><br><span class="line"></span><br><span class="line">                value_scaled = <span class="built_in">round</span>(p_value * (ih - <span class="number">1</span>))  <span class="comment"># Scale prediction to frame height</span></span><br><span class="line">                <span class="keyword">if</span> value_scaled != <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># Draw line upwards from the bottom edge of the frame visualization area</span></span><br><span class="line">                    draw.line((x_offset + j, y_offset, x_offset + j, y_offset - value_scaled), fill=<span class="built_in">tuple</span>(color),</span><br><span class="line">                              width=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">import</span> argparse  <span class="comment"># Already imported sys</span></span><br><span class="line"></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&quot;files&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;path to video files to process&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--weights&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;path to TransNet V2 weights, tries to infer the location if not specified&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--visualize&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;save a png file with prediction visualization for each extracted video&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        model = TransNetV2(args.weights)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e_model_load:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 CRITICAL] Failed to load TransNetV2 model: <span class="subst">&#123;e_model_load&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">        sys.exit(<span class="number">1</span>)  <span class="comment"># Exit if model fails to load</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> args.files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 INFO] Processing file: <span class="subst">&#123;file&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">        <span class="comment"># This pre-check is fine, but the calling script test_and_cut_video.py now also does pre-cleanup</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(file + <span class="string">&quot;.predictions.txt&quot;</span>) <span class="keyword">or</span> os.path.exists(file + <span class="string">&quot;.scenes.txt&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] <span class="subst">&#123;file&#125;</span>.predictions.txt or <span class="subst">&#123;file&#125;</span>.scenes.txt already exists. &quot;</span></span><br><span class="line">                  <span class="string">f&quot;Skipping video <span class="subst">&#123;file&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            video_frames, single_frame_predictions, all_frame_predictions = \</span><br><span class="line">                model.predict_video(file)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># --- Debugging: Check outputs of predict_video ---</span></span><br><span class="line">            <span class="keyword">if</span> video_frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> video_frames.size == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] predict_video returned no frames for <span class="subst">&#123;os.path.basename(file)&#125;</span>. Cannot save outputs.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file</span></span><br><span class="line">            <span class="keyword">if</span> single_frame_predictions <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> single_frame_predictions.size == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] predict_video returned no single_frame_predictions for <span class="subst">&#123;os.path.basename(file)&#125;</span>. Cannot save outputs.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file</span></span><br><span class="line">            <span class="comment"># all_frame_predictions can sometimes be legitimately empty if single_frame_predictions is also empty.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Returned from predict_video for <span class="subst">&#123;os.path.basename(file)&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   video_frames shape: <span class="subst">&#123;video_frames.shape&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   single_frame_predictions shape: <span class="subst">&#123;single_frame_predictions.shape&#125;</span>&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   all_frame_predictions shape: <span class="subst">&#123;all_frame_predictions.shape&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="comment"># --- End Debugging ---</span></span><br><span class="line"></span><br><span class="line">            predictions = np.stack([single_frame_predictions, all_frame_predictions], <span class="number">1</span>)</span><br><span class="line">            predictions_filepath = file + <span class="string">&quot;.predictions.txt&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                np.savetxt(predictions_filepath, predictions, fmt=<span class="string">&quot;%.6f&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempted to save predictions to <span class="subst">&#123;predictions_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(predictions_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 CRITICAL DEBUG] Saved predictions but file <span class="subst">&#123;predictions_filepath&#125;</span> does NOT exist!&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] File <span class="subst">&#123;predictions_filepath&#125;</span> successfully created.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_pred_save:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception saving predictions file <span class="subst">&#123;predictions_filepath&#125;</span>: <span class="subst">&#123;e_pred_save&#125;</span>&quot;</span>,</span><br><span class="line">                      file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file if saving predictions fails</span></span><br><span class="line"></span><br><span class="line">            scenes = model.predictions_to_scenes(single_frame_predictions)</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 DEBUG] Scenes array for <span class="subst">&#123;os.path.basename(file)&#125;</span> (shape: <span class="subst">&#123;scenes.shape <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;None&#x27;</span>&#125;</span>):\n<span class="subst">&#123;scenes&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> scenes.size == <span class="number">0</span>:  <span class="comment"># Check if scenes array is empty</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 WARNING] Scenes array is empty or None for <span class="subst">&#123;os.path.basename(file)&#125;</span>. &quot;</span></span><br><span class="line">                      <span class="string">f&quot;No .scenes.txt will be saved, or it might be empty.&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="comment"># Depending on desired behavior, you might &#x27;continue&#x27; here or let np.savetxt handle an empty array.</span></span><br><span class="line">                <span class="comment"># np.savetxt with an empty array will create an empty file.</span></span><br><span class="line">                <span class="comment"># If an empty scenes file is problematic for the parent script, handle it here.</span></span><br><span class="line">                <span class="comment"># For now, let it try to save, which will result in an empty file if scenes is empty.</span></span><br><span class="line"></span><br><span class="line">            scenes_filepath = file + <span class="string">&quot;.scenes.txt&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                np.savetxt(scenes_filepath, scenes, fmt=<span class="string">&quot;%d&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempted to save scenes to <span class="subst">&#123;scenes_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(scenes_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] File <span class="subst">&#123;scenes_filepath&#125;</span> successfully created.&quot;</span>, file=sys.stderr)</span><br><span class="line">                    <span class="comment"># Optionally, check file size or content for empty scenes</span></span><br><span class="line">                    <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> scenes.size == <span class="number">0</span> <span class="keyword">and</span> os.path.getsize(scenes_filepath) == <span class="number">0</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] <span class="subst">&#123;scenes_filepath&#125;</span> is empty as expected for empty scenes array.&quot;</span>,</span><br><span class="line">                              file=sys.stderr)</span><br><span class="line">                    <span class="keyword">elif</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> scenes.size &gt; <span class="number">0</span> <span class="keyword">and</span> os.path.getsize(scenes_filepath) == <span class="number">0</span>:</span><br><span class="line">                        <span class="built_in">print</span>(</span><br><span class="line">                            <span class="string">f&quot;[TransNetV2 WARNING] <span class="subst">&#123;scenes_filepath&#125;</span> is unexpectedly empty despite non-empty scenes array.&quot;</span>,</span><br><span class="line">                            file=sys.stderr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 CRITICAL DEBUG] Saved scenes but file <span class="subst">&#123;scenes_filepath&#125;</span> does NOT exist afterwards!&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_save:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception during np.savetxt for .scenes.txt (<span class="subst">&#123;scenes_filepath&#125;</span>): <span class="subst">&#123;e_save&#125;</span>&quot;</span>,</span><br><span class="line">                      file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file if saving scenes fails</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> args.visualize:</span><br><span class="line">                vis_filepath = file + <span class="string">&quot;.vis.png&quot;</span></span><br><span class="line">                <span class="keyword">if</span> os.path.exists(vis_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] <span class="subst">&#123;vis_filepath&#125;</span> already exists. &quot;</span></span><br><span class="line">                          <span class="string">f&quot;Skipping visualization of video <span class="subst">&#123;file&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">                    <span class="comment"># continue # This continue was inside the loop for &#x27;file in args.files&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempting to visualize predictions for <span class="subst">&#123;os.path.basename(file)&#125;</span>&quot;</span>,</span><br><span class="line">                          file=sys.stderr)</span><br><span class="line">                    pil_image = model.visualize_predictions(</span><br><span class="line">                        video_frames, predictions=(single_frame_predictions, all_frame_predictions))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> pil_image:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            pil_image.save(vis_filepath)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Saved visualization to <span class="subst">&#123;vis_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_vis_save:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception saving visualization <span class="subst">&#123;vis_filepath&#125;</span>: <span class="subst">&#123;e_vis_save&#125;</span>&quot;</span>,</span><br><span class="line">                                  file=sys.stderr)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 WARNING] Visualization not generated for <span class="subst">&#123;os.path.basename(file)&#125;</span>.&quot;</span>,</span><br><span class="line">                              file=sys.stderr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_video_processing:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Unhandled exception during processing of video <span class="subst">&#123;file&#125;</span>: <span class="subst">&#123;e_video_processing&#125;</span>&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="comment"># Optionally, re-raise or sys.exit(1) if this should halt the script</span></span><br><span class="line">            <span class="comment"># For now, it will just print the error and attempt the next file.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 INFO] Finished processing all files.&quot;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用推理脚本处理视频">调用推理脚本处理视频</h3><ul><li>benchmark</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/model-benchmark.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/model-benchmark.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>处理输入视频为单一场景 检测视频转场并分割</li></ul><blockquote><p>自动跳过切割后视频前后500ms 去除转场动画</p></blockquote> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time:     2025/6/7 19:00  # 修改为实际时间</span></span><br><span class="line"><span class="string">Author:   ZhaoQi Cao(Clara)</span></span><br><span class="line"><span class="string">Version:  V 1.4 # 版本更新: 修正 parse_scenes_file 函数以正确解析场景文件格式</span></span><br><span class="line"><span class="string">File:     test_and_cut_video.py</span></span><br><span class="line"><span class="string">date:     2025/6/7 # 修改为实际日期</span></span><br><span class="line"><span class="string">Describe: Write during the python at Tianjin</span></span><br><span class="line"><span class="string">GitHub link: https://github.com/caozhaoqi</span></span><br><span class="line"><span class="string">Blog link: https://caozhaoqi.github.io</span></span><br><span class="line"><span class="string">WeChat Official Account: 码间拾遗（Code Snippets）</span></span><br><span class="line"><span class="string">Power by macOS on Mac mini m4(2024)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2  <span class="comment"># For getting total frames</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 用于更方便地处理路径</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm  <span class="comment"># 用于进度条</span></span><br><span class="line"><span class="keyword">import</span> shutil  <span class="comment"># 用于移动文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置日志 ---</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持的视频文件扩展名</span></span><br><span class="line">SUPPORTED_VIDEO_EXTENSIONS = [<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>, <span class="string">&#x27;.mov&#x27;</span>, <span class="string">&#x27;.mkv&#x27;</span>, <span class="string">&#x27;.flv&#x27;</span>, <span class="string">&#x27;.wmv&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_video_files</span>(<span class="params">input_dir, output_dir_to_skip=<span class="literal">None</span></span>):  <span class="comment"># 增加一个可选参数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recursively finds all video files in the given directory,</span></span><br><span class="line"><span class="string">    optionally skipping a specified output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    video_files = []</span><br><span class="line">    logger.info(<span class="string">f&quot;Searching for video files in: <span class="subst">&#123;input_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 规范化 output_dir_to_skip 以进行可靠的路径比较</span></span><br><span class="line">    normalized_output_skip_path = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> output_dir_to_skip:</span><br><span class="line">        normalized_output_skip_path = os.path.normpath(os.path.abspath(output_dir_to_skip))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        current_root_abs = os.path.normpath(os.path.abspath(root))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前遍历的目录是输出目录或其子目录，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> normalized_output_skip_path <span class="keyword">and</span> current_root_abs.startswith(normalized_output_skip_path):</span><br><span class="line">            logger.info(<span class="string">f&quot;Skipping scan of output directory: <span class="subst">&#123;root&#125;</span>&quot;</span>)</span><br><span class="line">            dirs[:] = []  <span class="comment"># 清空 dirs 列表，阻止 os.walk 进入此目录的子目录</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 过滤掉 macOS 的 ._* 文件和其他以点开头的隐藏文件</span></span><br><span class="line">            <span class="keyword">if</span> file.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(file.lower().endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> SUPPORTED_VIDEO_EXTENSIONS):</span><br><span class="line">                video_files.append(os.path.join(root, file))</span><br><span class="line">    logger.info(<span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> video file(s).&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> video_files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_transnet_inference</span>(<span class="params">video_path, transnet_script_path, model_dir, working_directory=<span class="string">&quot;.&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Runs TransNetV2 inference to get shot boundaries.</span></span><br><span class="line"><span class="string">    Returns the path to the &#x27;.scenes.txt&#x27; file located in the working_directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Running TransNetV2 inference on: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">    video_filename = os.path.basename(video_path)  <span class="comment"># e.g., &quot;myvideo.mp4&quot;</span></span><br><span class="line">    base_name = os.path.splitext(video_filename)[<span class="number">0</span>]  <span class="comment"># e.g., &quot;myvideo&quot; (for target filename in working_dir)</span></span><br><span class="line">    original_video_dir = os.path.dirname(video_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Pre-cleanup: 尝试删除原始视频目录中与该视频相关的旧输出文件 ---</span></span><br><span class="line">    <span class="comment"># This should target the names transnetv2.py actually creates</span></span><br><span class="line">    files_to_pre_cleanup = [</span><br><span class="line">        video_path + <span class="string">&quot;.scenes.txt&quot;</span>,</span><br><span class="line">        video_path + <span class="string">&quot;.predictions.txt&quot;</span>,</span><br><span class="line">        video_path + <span class="string">&quot;.vis.png&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> old_file_path <span class="keyword">in</span> files_to_pre_cleanup:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(old_file_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(old_file_path)</span><br><span class="line">                logger.info(<span class="string">f&quot;Pre-emptively removed old file: <span class="subst">&#123;old_file_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                logger.warning(<span class="string">f&quot;Could not pre-emptively remove old file <span class="subst">&#123;old_file_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># --- 预清理结束 ---</span></span><br><span class="line"></span><br><span class="line">    command = [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, transnet_script_path,</span><br><span class="line">        video_path,</span><br><span class="line">        <span class="string">&quot;--weights&quot;</span>, model_dir</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=working_directory)</span><br><span class="line">        stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line">        process_stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        process_stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;TransNetV2 inference failed for <span class="subst">&#123;video_filename&#125;</span>:&quot;</span>)</span><br><span class="line">            logger.error(<span class="string">f&quot;STDOUT: <span class="subst">&#123;process_stdout&#125;</span>&quot;</span>)</span><br><span class="line">            logger.error(<span class="string">f&quot;STDERR: <span class="subst">&#123;process_stderr&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;TransNetV2 inference successful for <span class="subst">&#123;video_filename&#125;</span> (exit code 0).&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process_stdout.strip():</span><br><span class="line">            logger.info(<span class="string">f&quot;TransNetV2 STDOUT for <span class="subst">&#123;video_filename&#125;</span>:\n<span class="subst">&#123;process_stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process_stderr.strip():</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;TransNetV2 STDERR for <span class="subst">&#123;video_filename&#125;</span> (though exit code was 0):\n<span class="subst">&#123;process_stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">        logger.error(<span class="string">f&quot;TransNetV2 inference timed out for <span class="subst">&#123;video_filename&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process:</span><br><span class="line">            process.kill()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">5</span>)</span><br><span class="line">                process_stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                process_stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> process_stdout.strip():</span><br><span class="line">                    logger.error(<span class="string">f&quot;STDOUT (on timeout): <span class="subst">&#123;process_stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> process_stderr.strip():</span><br><span class="line">                    logger.error(<span class="string">f&quot;STDERR (on timeout): <span class="subst">&#123;process_stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_comm:</span><br><span class="line">                logger.error(<span class="string">f&quot;Error getting output after timeout kill: <span class="subst">&#123;e_comm&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Exception during TransNetV2 inference for <span class="subst">&#123;video_filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 文件查找和移动逻辑 ---</span></span><br><span class="line">    target_scenes_file_in_working_dir = os.path.join(working_directory, <span class="string">f&quot;<span class="subst">&#123;base_name&#125;</span>.scenes.txt&quot;</span>)</span><br><span class="line">    target_predictions_file_in_working_dir = os.path.join(working_directory, <span class="string">f&quot;<span class="subst">&#123;base_name&#125;</span>.predictions.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    expected_scenes_file_in_original_dir = video_path + <span class="string">&quot;.scenes.txt&quot;</span></span><br><span class="line">    expected_predictions_file_in_original_dir = video_path + <span class="string">&quot;.predictions.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    scenes_file_found_path = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(target_scenes_file_in_working_dir):</span><br><span class="line">        logger.info(<span class="string">f&quot;Found scenes file directly in working directory: <span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">        scenes_file_found_path = target_scenes_file_in_working_dir</span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(expected_scenes_file_in_original_dir):</span><br><span class="line">        logger.info(<span class="string">f&quot;Found scenes file in original video directory: <span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            shutil.move(expected_scenes_file_in_original_dir, target_scenes_file_in_working_dir)</span><br><span class="line">            logger.info(<span class="string">f&quot;Moved scenes file to: <span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">            scenes_file_found_path = target_scenes_file_in_working_dir</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(expected_predictions_file_in_original_dir):</span><br><span class="line">                shutil.move(expected_predictions_file_in_original_dir, target_predictions_file_in_working_dir)</span><br><span class="line">                logger.info(<span class="string">f&quot;Moved predictions file to: <span class="subst">&#123;target_predictions_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&quot;Failed to move scenes/predictions file from &#x27;<span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>&#x27; to &#x27;<span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Scenes file not found in working directory (<span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>) &quot;</span></span><br><span class="line">                     <span class="string">f&quot;nor in original video directory (<span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>).&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scenes_file_found_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_total_frames</span>(<span class="params">video_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Gets the total number of frames in a video.&quot;&quot;&quot;</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="comment"># Log OpenCV error if available (requires newer OpenCV versions for good messages)</span></span><br><span class="line">        <span class="comment"># For older versions, this might not give much info.</span></span><br><span class="line">        <span class="comment"># cv_error = cv2.getErrorMsg() if hasattr(cv2, &#x27;getErrorMsg&#x27;) else &quot;OpenCV error&quot;</span></span><br><span class="line">        <span class="comment"># logger.error(f&quot;Could not open video: &#123;video_path&#125;. OpenCV: &#123;cv_error&#125;&quot;)</span></span><br><span class="line">        logger.error(<span class="string">f&quot;Could not open video: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    total_frames = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="keyword">return</span> total_frames</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_scenes_file</span>(<span class="params">scenes_file_path, total_frames</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Parses the .scenes.txt file which contains start and end frames for each shot,</span></span><br><span class="line"><span class="string">    one shot per line, space-separated.</span></span><br><span class="line"><span class="string">    Returns a list of (start_frame, end_frame) tuples for each shot.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(scenes_file_path):</span><br><span class="line">        logger.error(<span class="string">f&quot;Scenes file not found for parsing: <span class="subst">&#123;scenes_file_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    shots = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(scenes_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line_number, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f, <span class="number">1</span>):</span><br><span class="line">                stripped_line = line.strip()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stripped_line:  <span class="comment"># Skip empty lines</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                parts = stripped_line.split()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span> <span class="keyword">and</span> parts[<span class="number">0</span>].isdigit() <span class="keyword">and</span> parts[<span class="number">1</span>].isdigit():</span><br><span class="line">                    start_frame = <span class="built_in">int</span>(parts[<span class="number">0</span>])</span><br><span class="line">                    end_frame = <span class="built_in">int</span>(parts[<span class="number">1</span>])  <span class="comment"># This is the end frame of the shot (inclusive)</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Validate frames against total_frames</span></span><br><span class="line">                    <span class="keyword">if</span> start_frame &lt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid start_frame <span class="subst">&#123;start_frame&#125;</span> &lt; 0 in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Clamping to 0.&quot;</span>)</span><br><span class="line">                        start_frame = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># end_frame from TransNetV2 is inclusive and 0-indexed.</span></span><br><span class="line">                    <span class="comment"># If total_frames is N, valid frames are 0 to N-1.</span></span><br><span class="line">                    <span class="keyword">if</span> end_frame &gt;= total_frames <span class="keyword">and</span> total_frames &gt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;End_frame <span class="subst">&#123;end_frame&#125;</span> from scenes file is &gt;= total_frames <span class="subst">&#123;total_frames&#125;</span> in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Clamping to <span class="subst">&#123;total_frames - <span class="number">1</span>&#125;</span>.&quot;</span>)</span><br><span class="line">                        end_frame = total_frames - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total_frames == <span class="number">0</span> <span class="keyword">and</span> end_frame &gt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid end_frame <span class="subst">&#123;end_frame&#125;</span> for video with 0 total_frames in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Skipping shot.&quot;</span>)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> total_frames == <span class="number">0</span> <span class="keyword">and</span> end_frame == <span class="number">0</span> <span class="keyword">and</span> start_frame == <span class="number">0</span>:  <span class="comment"># Special case for 0-frame video if it somehow yields a (0,0) shot</span></span><br><span class="line">                        <span class="keyword">pass</span>  <span class="comment"># Allow (0,0) for a 0-frame video if that&#x27;s a possible output</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> start_frame &gt; end_frame:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid shot (start_frame <span class="subst">&#123;start_frame&#125;</span> &gt; end_frame <span class="subst">&#123;end_frame&#125;</span>) in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Skipping shot.&quot;</span>)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    shots.append((start_frame, end_frame))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># This warning will catch lines that are not two integers.</span></span><br><span class="line">                    logger.warning(</span><br><span class="line">                        <span class="string">f&quot;Malformed line in scenes file &#x27;<span class="subst">&#123;scenes_file_path&#125;</span>&#x27; line <span class="subst">&#123;line_number&#125;</span>: &#x27;<span class="subst">&#123;stripped_line&#125;</span>&#x27;. Expected two integers separated by space.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error reading or parsing scenes file <span class="subst">&#123;scenes_file_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> shots:</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;No valid shots derived from scenes file: <span class="subst">&#123;scenes_file_path&#125;</span>. Assuming single shot for the entire video.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> total_frames &gt; <span class="number">0</span>:</span><br><span class="line">            shots.append((<span class="number">0</span>, total_frames - <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># If total_frames is 0, shots will remain empty, which is correct.</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Sort shots by start frame, just in case they are not ordered in the file</span></span><br><span class="line">        shots.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        logger.info(</span><br><span class="line">            <span class="string">f&quot;Detected <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for <span class="subst">&#123;os.path.basename(scenes_file_path)&#125;</span> (start_frame, end_frame_inclusive): <span class="subst">&#123;shots&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_video_into_shots</span>(<span class="params">video_path, shots, video_output_dir, padding_ms=<span class="number">500</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Cuts the video into shots using ffmpeg based on frame numbers.</span></span><br><span class="line"><span class="string">    The start and end of each shot are REDUCED by padding_ms.</span></span><br><span class="line"><span class="string">    (Note: The &#x27;padding_ms&#x27; parameter is used here as a reduction amount).</span></span><br><span class="line"><span class="string">    Saves shots into the video_specific output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    video_basename = Path(video_path).stem</span><br><span class="line">    logger.info(<span class="string">f&quot;Starting to cut <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for video: <span class="subst">&#123;video_basename&#125;</span>, REDUCING each end by <span class="subst">&#123;padding_ms&#125;</span>ms.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get video properties (FPS and total frames) once</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        logger.error(<span class="string">f&quot;Could not open video <span class="subst">&#123;video_path&#125;</span> for properties. Skipping cutting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    video_total_frames = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    cap.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fps &gt; <span class="number">0</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Could not determine FPS for <span class="subst">&#123;video_path&#125;</span>. Skipping reduction cut.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> video_total_frames == <span class="number">0</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Video <span class="subst">&#123;video_path&#125;</span> has 0 frames. Skipping cutting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the reduction amount from milliseconds to frames</span></span><br><span class="line">    reduction_frames = <span class="built_in">round</span>(padding_ms / <span class="number">1000</span> * fps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (start_frame, end_frame) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(shots, desc=<span class="string">f&quot;Cutting shots for <span class="subst">&#123;video_basename&#125;</span>&quot;</span>, unit=<span class="string">&quot;shot&quot;</span>)):</span><br><span class="line">        start_frame = <span class="built_in">int</span>(start_frame)</span><br><span class="line">        end_frame = <span class="built_in">int</span>(end_frame)  <span class="comment"># Inclusive end frame from parse_scenes_file</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate new target start and end frames after reduction</span></span><br><span class="line">        target_start_frame = start_frame + reduction_frames</span><br><span class="line">        target_end_frame = end_frame - reduction_frames  <span class="comment"># This will also be an inclusive frame index</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the shot is too short for the reduction, making it invalid</span></span><br><span class="line">        <span class="keyword">if</span> target_end_frame &lt; target_start_frame:</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;Shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (original: <span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>) is too short to apply <span class="subst">&#123;padding_ms&#125;</span>ms reduction &quot;</span></span><br><span class="line">                <span class="string">f&quot;from both ends (would result in invalid segment: <span class="subst">&#123;target_start_frame&#125;</span>-<span class="subst">&#123;target_end_frame&#125;</span>). &quot;</span></span><br><span class="line">                <span class="string">f&quot;Original duration: <span class="subst">&#123;(end_frame - start_frame + <span class="number">1</span>) / fps:<span class="number">.2</span>f&#125;</span>s. Skipping this shot.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Clamp the target frames to the video&#x27;s actual boundaries</span></span><br><span class="line">        <span class="comment"># (0 to video_total_frames - 1)</span></span><br><span class="line">        final_start_frame = <span class="built_in">max</span>(<span class="number">0</span>, target_start_frame)</span><br><span class="line">        final_start_frame = <span class="built_in">min</span>(final_start_frame, video_total_frames - <span class="number">1</span>)  <span class="comment"># Ensure start isn&#x27;t past video end</span></span><br><span class="line"></span><br><span class="line">        final_end_frame = <span class="built_in">min</span>(video_total_frames - <span class="number">1</span>, target_end_frame)</span><br><span class="line">        final_end_frame = <span class="built_in">max</span>(<span class="number">0</span>, final_end_frame)  <span class="comment"># Ensure end isn&#x27;t before video start</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Re-check validity after clamping.</span></span><br><span class="line">        <span class="comment"># This handles cases where clamping itself might make the segment invalid.</span></span><br><span class="line">        <span class="keyword">if</span> final_end_frame &lt; final_start_frame:</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;Shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (original: <span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>) became invalid after reduction and clamping to video boundaries: &quot;</span></span><br><span class="line">                <span class="string">f&quot;intended reduced (<span class="subst">&#123;target_start_frame&#125;</span>-<span class="subst">&#123;target_end_frame&#125;</span>), &quot;</span></span><br><span class="line">                <span class="string">f&quot;clamped to (<span class="subst">&#123;final_start_frame&#125;</span>-<span class="subst">&#123;final_end_frame&#125;</span>). Skipping this shot.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        output_shot_filename = <span class="string">f&quot;<span class="subst">&#123;video_basename&#125;</span>_shot_<span class="subst">&#123;i + <span class="number">1</span>:03d&#125;</span>.mp4&quot;</span></span><br><span class="line">        output_shot_path = os.path.join(video_output_dir, output_shot_filename)</span><br><span class="line"></span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">f&quot;Preparing to cut shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>: original (<span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>), &quot;</span></span><br><span class="line">            <span class="string">f&quot;target reduced frames (<span class="subst">&#123;final_start_frame&#125;</span>-<span class="subst">&#123;final_end_frame&#125;</span>) -&gt; <span class="subst">&#123;output_shot_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        ffmpeg_command = [</span><br><span class="line">            <span class="string">&quot;ffmpeg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-loglevel&quot;</span>, <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">            <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;between(n,<span class="subst">&#123;final_start_frame&#125;</span>,<span class="subst">&#123;final_end_frame&#125;</span>)&#x27;,setpts=PTS-STARTPTS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-af&quot;</span>, <span class="string">f&quot;aselect=&#x27;between(n,<span class="subst">&#123;final_start_frame&#125;</span>,<span class="subst">&#123;final_end_frame&#125;</span>)&#x27;,asetpts=PTS-STARTPTS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-c:v&quot;</span>, <span class="string">&quot;libx264&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-preset&quot;</span>, <span class="string">&quot;ultrafast&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-crf&quot;</span>, <span class="string">&quot;23&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-c:a&quot;</span>, <span class="string">&quot;aac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-y&quot;</span>,  <span class="comment"># Overwrite output files without asking</span></span><br><span class="line">            output_shot_path</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            process = subprocess.Popen(ffmpeg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">            stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">            stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">                logger.error(<span class="string">f&quot;ffmpeg failed for shot <span class="subst">&#123;output_shot_filename&#125;</span>:&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> stderr.strip(): logger.error(<span class="string">f&quot;FFMPEG STDERR: <span class="subst">&#123;stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> stdout.strip(): logger.error(<span class="string">f&quot;FFMPEG STDOUT: <span class="subst">&#123;stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.info(<span class="string">f&quot;Successfully created <span class="subst">&#123;output_shot_filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">            logger.error(<span class="string">f&quot;ffmpeg timed out for shot <span class="subst">&#123;output_shot_filename&#125;</span>.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> process:</span><br><span class="line">                process.kill()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">5</span>)</span><br><span class="line">                    stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                    stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> stderr.strip(): logger.error(<span class="string">f&quot;FFMPEG STDERR (on timeout kill): <span class="subst">&#123;stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> stdout.strip(): logger.error(<span class="string">f&quot;FFMPEG STDOUT (on timeout kill): <span class="subst">&#123;stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e_comm_kill:</span><br><span class="line">                    logger.error(<span class="string">f&quot;Error getting output after ffmpeg timeout kill: <span class="subst">&#123;e_comm_kill&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;Exception during ffmpeg processing for shot <span class="subst">&#123;output_shot_filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Finished cutting <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for video: <span class="subst">&#123;video_basename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&quot;Process videos using TransNetV2 to detect shot boundaries and cut the videos into shots.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input_source&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Path to a directory containing video files to process.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--transnet_script&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;inference/transnetv2.py&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the transnetv2.py script.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--model_dir&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;inference/transnetv2-weights&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the TransNetV2 model directory.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--output_dir&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;./r&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Base directory to output processed videos.  A subdirectory will be created for each video.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--log_file&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;my_processing_log.txt&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the log file.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 日志文件设置 ---</span></span><br><span class="line">    log_file_path = args.log_file</span><br><span class="line">    log_dir = os.path.dirname(log_file_path)  <span class="comment"># 获取日志文件所在目录</span></span><br><span class="line">    <span class="keyword">if</span> log_dir <span class="keyword">and</span> <span class="keyword">not</span> os.path.exists(log_dir):</span><br><span class="line">        os.makedirs(log_dir)  <span class="comment"># 如果日志目录不存在，则创建它</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个file handler，将日志写入文件</span></span><br><span class="line">    file_handler = logging.FileHandler(log_file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)  <span class="comment"># 设置日志级别为INFO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个formatter并将其添加到handler</span></span><br><span class="line">    formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s&#x27;</span>,</span><br><span class="line">                                  datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将handler添加到logger</span></span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Script started.&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">f&quot;Arguments: <span class="subst">&#123;args&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    input_source = args.input_source</span><br><span class="line">    transnet_script = args.transnet_script</span><br><span class="line">    model_dir = args.model_dir</span><br><span class="line">    output_dir = args.output_dir</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">        os.makedirs(output_dir)</span><br><span class="line">        logger.info(<span class="string">f&quot;Created base output directory: <span class="subst">&#123;output_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Base output directory already exists: <span class="subst">&#123;output_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    video_files = find_video_files(input_source, output_dir_to_skip=output_dir)  <span class="comment"># 排除 output_dir</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files:</span><br><span class="line">        logger.warning(<span class="string">&quot;No video files found to process.&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">&quot;All processing complete.&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Processing <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> video(s)...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> video_path <span class="keyword">in</span> video_files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># --- 视频特定处理开始 ---</span></span><br><span class="line">            video_basename = Path(video_path).stem</span><br><span class="line">            logger.info(<span class="string">f&quot;--- Starting processing for video: <span class="subst">&#123;video_path&#125;</span> ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 为当前视频创建处理目录和输出目录</span></span><br><span class="line">            video_output_dir = os.path.join(output_dir, video_basename)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(video_output_dir):</span><br><span class="line">                os.makedirs(video_output_dir)</span><br><span class="line">                logger.info(<span class="string">f&quot;Created processing/output directory for this video: <span class="subst">&#123;video_output_dir&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.info(<span class="string">f&quot;Processing/output directory already exists: <span class="subst">&#123;video_output_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            total_frames = get_total_frames(video_path)</span><br><span class="line">            <span class="keyword">if</span> total_frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> total_frames == <span class="number">0</span>:</span><br><span class="line">                logger.error(</span><br><span class="line">                    <span class="string">f&quot;Cannot process video <span class="subst">&#123;video_path&#125;</span> as it has no frames or could not be read. Skipping.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to the next video</span></span><br><span class="line">            logger.info(<span class="string">f&quot;Total frames in <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;total_frames&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 运行 TransNetV2 推理</span></span><br><span class="line">            scenes_file = run_transnet_inference(video_path, transnet_script, model_dir,</span><br><span class="line">                                                 working_directory=video_output_dir)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> scenes_file <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                logger.error(<span class="string">f&quot;Failed to get scenes file for <span class="subst">&#123;video_path&#125;</span>. Skipping this video.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to the next video</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 解析场景文件</span></span><br><span class="line">            shots = parse_scenes_file(scenes_file, total_frames)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将视频剪切成镜头</span></span><br><span class="line">            cut_video_into_shots(video_path, shots, video_output_dir, padding_ms=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;An unexpected error occurred while processing <span class="subst">&#123;video_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;All processing complete.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>检测输出结果</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/test-result.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/test-result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="See">See</h2><ul><li>1.<a href="https://arxiv.org/pdf/2008.04838">https://arxiv.org/pdf/2008.04838</a></li><li>2.<a href="https://github.com/soCzech/TransNetV2/tree/master">https://github.com/soCzech/TransNetV2/tree/master</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TransNet-V2-模型介绍&quot;&gt;TransNet V2 模型介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;目标：&lt;br&gt;
TransNet V2 的目标是创建一个快速且准确的镜头边界检测（Shot Boundary Detection, SBD）模型。它能够识别视频中的两</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>场景检测性能优化方向与测试方法</title>
    <link href="https://caozhaoqi.github.io/2025/05/30/scene-detect-benchmark/"/>
    <id>https://caozhaoqi.github.io/2025/05/30/scene-detect-benchmark/</id>
    <published>2025-05-30T08:44:00.000Z</published>
    <updated>2025-11-25T15:05:10.347Z</updated>
    
    <content type="html"><![CDATA[<h1>场景检测性能优化方向与测试方法</h1><h2 id="1-引言">1. 引言</h2><p>本指南旨在提供一套系统化的方法，用于验证和分析视频处理项目的效率，特别是针对场景检测模块的性能。通过收集关键性能指标 (KPIs)<br>和剖析代码执行，我们可以识别性能瓶颈，并为后续的代码优化提供数据支持。</p><h2 id="2-准备工作">2. 准备工作</h2><h3 id="2-1-定义关键性能指标-KPIs">2.1. 定义关键性能指标 (KPIs)</h3><p>在开始测试前，明确需要衡量的性能指标：</p><ul><li>总处理时间 (End-to-End Time)*衡量单个视频从场景检测开始到结束的总耗时。</li><li>场景检测函数耗时<code>detect_scenes</code> 函数的精确执行时间。</li><li>CPU 使用率场景检测过程中的平均和峰值 CPU 使用率。</li><li>内存使用量 场景检测过程中的峰值和平均内存消耗。</li><li>GPU 使用率 (若启用)：GPU 计算单元和显存的使用率。</li><li>检测到的场景数作为检测结果的一个基本衡量。</li><li>检测时使用的帧率记录 <code>detect_scenes</code> 内部实际使用的视频帧率。</li></ul><h3 id="2-2-选择测试数据集">2.2. 选择测试数据集</h3><ul><li>多样性 准备一组包含不同特征的视频文件：<ul><li>不同分辨率 (例如：720p, 1080p, 4K)。</li><li>不同编码格式 (例如：H.264, HEVC)。</li><li>不同时长 (例如：短视频 &lt; 1分钟，中等视频 5-10分钟，长视频 &gt; 30分钟)。</li><li>不同场景复杂度 (例如：场景切换频繁的预告片，场景切换较少的讲座视频)。</li></ul></li><li>代表性 测试视频应能代表项目实际应用中常见的视频类型。</li><li>可重复性 使用固定的视频集进行所有测试，以便比较不同优化版本的效果。</li></ul><h3 id="2-3-搭建测试环境">2.3. 搭建测试环境</h3><ul><li>硬件一致性 所有基准测试应在同一台机器上进行，以消除硬件差异。记录测试机器的 CPU、内存、GPU型号、磁盘类型等规格。</li><li>软件环境一致性 确保 Python 版本、操作系统以及所有相关依赖库 (如 PySceneDetect, OpenCV, FFmpeg) 的版本在测试期间保持不变。可以从<br><code>requirements.txt</code> 文件中获取依赖列表。</li><li>环境隔离 测试时，尽量关闭其他不必要的应用程序，以减少对测试结果的干扰。</li></ul><h3 id="2-4-配置测试参数">2.4. 配置测试参数</h3><ul><li><code>config.ini</code> 基准测试脚本会加载此文件。确保其中的路径配置 (如 <code>ffmpeg_path</code>, <code>ffprobe_path</code>) 和默认的检测器参数是你想要测试的基础配置。</li><li>测试脚本内配置 <code>benchmark_scene_detector.py</code> 脚本允许定义多种测试配置 ( <code>configurations_to_test</code> 列表)，例如：<ul><li>CPU vs GPU 解码。</li><li>使用不同的检测器组合 (例如，仅 <code>ContentDetector</code> vs <code>MultiDetector</code> 全启用)。</li><li>不同的检测器参数 (例如，不同的 <code>threshold</code> 或 <code>min_scene_len_frames</code>)。</li></ul></li></ul><h2 id="3-测试执行">3. 测试执行</h2><h3 id="3-1-测试脚本：benchmark-scene-detector-py">3.1. 测试脚本：<code>benchmark_scene_detector.py</code></h3><ul><li>基础库安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install memory-profiler psutil snakeviz # snakeviz 用于可视化 cProfile 结果</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>基准测试脚本运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python src/video/benchmark_scene_detector.py</span><br></pre></td></tr></table></figure><ul><li>性能分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pstats profiling_results/profile_your_test_video1_Config_Default_CPU.prof</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snakeviz profiling_results/profile_your_test_video1_Config_Default_CPU.prof</span><br></pre></td></tr></table></figure><h3 id="3-2-性能剖析-Profiling">3.2. 性能剖析 (Profiling)</h3><ul><li>当测试配置中 <code>&quot;profile&quot;: True</code> 时，脚本会为该次运行生成一个 <code>.prof</code> 文件，保存在 <code>profiling_results</code> 目录下。</li><li>这些文件包含了函数调用次数、每次调用的耗时、累计耗时等详细信息。</li></ul><h3 id="3-3-资源监控">3.3. 资源监控</h3><ul><li>手动监控 在测试脚本运行时，使用操作系统自带的工具（如 Windows 的任务管理器，Linux 的 <code>top</code>/<code>htop</code>，macOS 的活动监视器）观察<br>CPU 和内存的实时使用情况。</li><li>GPU 监控 如果测试 GPU 加速，使用特定于 GPU 厂商的工具（如 NVIDIA 的 <code>nvidia-smi</code>）监控 GPU 利用率和显存使用。</li><li>脚本内监控 (可选) 可以修改 <code>benchmark_scene_detector.py</code>，使用 <code>psutil</code> 库在调用 <code>detect_scenes</code> 前后记录进程的 CPU<br>和内存快照，以获得更精确的数据。</li></ul><h3 id="3-4-比较耗时：">3.4 比较耗时：</h3><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从示例输出来看，对于“建筑家园-02.mp4”，使用 GPU (<br>Config_Default_GPU) 将处理时间从约 15.1 秒降低到了约 8.6 秒，有显著提升。</li><li>对比不同检测器组合或参数下的耗时。例如，Config_ContentDetectorOnly_CPU (仅使用 ContentDetector) 的耗时约为 5.4 秒，远快于使用<br>MultiDetector 的 Config_Default_CPU (15.1 秒)，但检测到的场景数也从 12 个减少到了 9 个。这需要在速度和检测全面性之间进行权衡。</li><li>观察不同特性视频（如时长、分辨率）对处理时间的影响（需要更多测试视频样本来分析此项）。4.2. 分析性能剖析 (.prof) 文件使用<br>Python 的 pstats 模块或 snakeviz 工具来分析 .prof 文件。使用 pstats (命令行)：</li></ul><h2 id="4-结果分析">4. 结果分析</h2><h3 id="4-1-分析基准测试日志">4.1. 分析基准测试日志</h3><blockquote><p>脚本执行完毕后，会打印一个总结报告，显示每个视频在不同配置下的处理时长和检测到的场景数。</p></blockquote><h4 id="在-pstats-交互式-shell-中，常用命令：">在 pstats 交互式 shell 中，常用命令：</h4><ul><li>sort cumulative: 按累计耗时排序。</li><li>stats 20: 显示耗时最多的前 20 个函数。</li><li>callers function_name: 查看哪些函数调用了 function_name。</li><li>callees function_name: 查看 function_name 调用了哪些函数。</li></ul><h4 id="使用-snakeviz-Web-界面，推荐-：">使用 snakeviz (Web 界面，推荐)：</h4><ul><li><p>比较耗时</p><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从示例输出来看，对于“建筑家园-02.mp4”，使用 GPU (<br><code>Config_Default_GPU</code>) 将处理时间从约 15.1 秒降低到了约 8.6 秒，有显著提升。</li><li>对比不同检测器组合或参数下的耗时。例如，<code>Config_ContentDetectorOnly_CPU</code> (仅使用 ContentDetector) 的耗时约为 5.4<br>秒，远快于使用 <code>MultiDetector</code> 的 <code>Config_Default_CPU</code> (15.1 秒)，但检测到的场景数也从 12 个减少到了 9<br>个。这需要在速度和检测全面性之间进行权衡。</li><li>观察不同特性视频（如时长、分辨率）对处理时间的影响（需要更多测试视频样本来分析此项）。</li></ul></li><li><p>比较耗时 (Updated Interpretation based on new logs)</p><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从最新的示例输出来看，对于“建筑家园-02.mp4” (一个60fps的视频):<ul><li><code>Config_Default_CPU</code> (MultiDetector, CPU decode): 433.73 秒</li><li><code>Config_Default_GPU</code> (MultiDetector, GPU decode requested): 411.56 秒</li><li>观察: 在这个特定的测试中 (macOS, <code>VideoStreamCv2</code> 被用作回退)，请求 GPU 解码相比纯 CPU 解码略有性能提升 (约<br>22 秒，或 5% 的提升)。这表明在 macOS 上，即使 PySceneDetect 回退到 <code>VideoStreamCv2</code>，底层的 OpenCV 和<br>AVFoundation/VideoToolbox 可能仍然利用了一些硬件加速。然而，这与之前日志中在非 macOS 环境下使用<br><code>VideoStreamCv2Cuda</code> 可能带来的更显著提升有所不同。文档中应指出，GPU 加速的效果高度依赖于操作系统、OpenCV<br>的编译选项、PySceneDetect 的后端选择以及具体的 GPU 硬件。</li></ul></li><li>对比不同检测器组合或参数下的耗时。例如:<ul><li><code>Config_ContentDetectorOnly_CPU</code> (仅使用 ContentDetector, CPU decode): 400.30 秒</li><li>观察: 仅使用 <code>ContentDetector</code> 仍然是最快的配置，比使用 <code>MultiDetector</code> 的 CPU 配置快了约 33 秒。但检测到的场景数从<br>214 个减少到了 164 个。这再次强调了在速度和检测全面性/准确性之间的权衡。</li></ul></li><li>重要提示:<ul><li>日志中出现 <code>Backend None not available. Trying another backend: opencv</code>，并且在请求 GPU 解码时，最终仍然是<br><code>opened with VideoStreamCv2</code>。这表明在当前的 macOS 测试环境下，<code>VideoStreamCv2Cuda</code> (如果期望使用的话)<br>并未被成功加载或使用，PySceneDetect 回退到了标准的 OpenCV 后端 (<code>VideoStreamCv2</code>)。文档应该提及这一点，并建议用户检查其<br>PySceneDetect 和 OpenCV (包括 CUDA 支持) 的安装，尤其是在非 macOS 环境下期望使用 NVIDIA GPU 加速时。</li><li>日志中出现 <code>min_delta_hsv is deprecated, use min_content_val instead.</code> 这是来自 <code>AdaptiveDetector</code><br>的一个警告。虽然不影响基准测试的耗时记录，但在文档中或代码注释中提及，并建议更新 <code>config.ini</code> 或<br><code>AdaptiveDetector</code> 的参数以使用新的 <code>min_content_val</code> 是一个好做法，以保持与库更新的兼容性。</li></ul></li></ul></li></ul><p>macOS性能测试结果解释:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/Users/zg/PycharmProjects/scene_detect_split/.venv/bin/python /Users/zg/PycharmProjects/scene_detect_split/src/tests/benchmark_scene_detector.py </span><br><span class="line">2025-05-30 10:46:40.555 | INFO     | config.config:initialize_settings:147 - Configuration successfully loaded from: /Users/zg/PycharmProjects/scene_detect_split/src/run/config.ini</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:118 - Configuration loaded from: /Users/zg/PycharmProjects/scene_detect_split/src/run/config.ini</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:210 - </span><br><span class="line">===== Processing Video: /Volumes/shared/样例/CG渲染样例/建筑家园/建筑家园-02.mp4 =====</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_CPU ---</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: MultiDetector</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 10:46:40.720 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 10:46:40.720 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: MultiDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:46:40.721 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">min_delta_hsv is deprecated, use min_content_val instead.</span><br><span class="line">2025-05-30 10:53:54.141 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 214 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:53:54.143 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 214 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 10:53:54.296 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results/profile_建筑家园_02_Config_Default_CPU.prof</span><br><span class="line">2025-05-30 10:53:54.297 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 10:53:54.297 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 214</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 433.7327 seconds</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_GPU ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: MultiDetector</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: True</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">2025-05-30 10:53:54.299 | INFO     | video.scene_detector:detect_scenes:95 - [MainThread] GPU decode (AVFoundation/VideoToolbox likely) on macOS for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: MultiDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">min_delta_hsv is deprecated, use min_content_val instead.</span><br><span class="line">2025-05-30 11:00:45.457 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 214 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:00:45.458 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 214 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results/profile_建筑家园_02_Config_Default_GPU.prof</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 214</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 411.5587 seconds</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_ContentDetectorOnly_CPU ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:07:26.007 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 164 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:07:26.011 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 164 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 164</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 400.2969 seconds</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:236 - </span><br><span class="line"></span><br><span class="line">===== Benchmark Summary =====</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:238 - </span><br><span class="line">Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_CPU             | Duration: 433.7327s | Scenes: 214</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_GPU             | Duration: 411.5587s | Scenes: 214</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_ContentDetectorOnly_CPU | Duration: 400.2969s | Scenes: 164</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:242 - </span><br><span class="line">To analyze .prof files, use a tool like &#x27;snakeviz&#x27; or Python&#x27;s pstats module.</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:243 - Example: python -m pstats profiling_results/your_profile_file.prof</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:244 - Then in pstats shell: sort cumulative, stats 20</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>macOS 上的 GPU 解码:<ul><li>在 “GPU 监控” 或 “比较耗时” 部分，可以特别说明在 macOS 上，即使没有明确的 <code>VideoStreamCv2Cuda</code>，PySceneDetect 通过<br><code>VideoStreamCv2</code> 也可能间接利用 VideoToolbox/AVFoundation 进行硬件加速解码，但效果可能与专用 CUDA 后端不同。</li></ul></li><li>PySceneDetect 后端回退:<ul><li>在 “结果分析” 或 “故障排查” (如果添加此章节) 部分，解释<br><code>Backend None not available. Trying another backend: opencv</code> 日志的含义，即 PySceneDetect<br>尝试了默认后端（可能是用户指定的或库的优选）但失败，然后回退到 OpenCV。这对于理解实际使用的解码路径很重要。</li></ul></li><li>依赖库版本的重要性:<ul><li>再次强调在 “软件环境一致性” 部分，PySceneDetect、OpenCV (及其 CUDA/OpenCL 支持的编译方式)、FFmpeg<br>的版本都会显著影响性能和功能，包括硬件加速的可用性。</li></ul></li><li><code>min_delta_hsv</code> 废弃警告:<ul><li>在 “配置测试参数” 或 “结果分析” 部分，提示用户注意 PySceneDetect 的废弃警告，并及时更新其配置文件或代码以使用推荐的新参数。</li></ul></li></ul><p>通过这些补充，<code>benchmark_test.md</code> 文档将更准确地反映实际的测试情况，并为用户提供更有价值的性能分析指导。</p><h3 id="4-2-分析性能剖析-prof-文件">4.2. 分析性能剖析 (<code>.prof</code>) 文件</h3><p>使用 Python 的 <code>pstats</code> 模块或 <code>snakeviz</code> 工具来分析 <code>.prof</code> 文件。</p><ul><li>使用 <code>pstats</code> (命令行)</li><li>snakeviz 会在浏览器中打开一个交互式的火焰图或旭日图，直观地展示函数调用栈和各部分耗时。</li><li>关注点：</li><li>耗时最多的函数：这些是首要的优化目标。通常会是 PySceneDetect 库中与视频解码、帧处理以及各检测器核心算法相关的函数。</li><li>PySceneDetect 内部函数：如果瓶颈在 PySceneDetect 库内部（如特定检测器的 process_frame<br>方法，视频解码函数），优化方向可能包括调整检测器参数、选择更快的检测器、或优化视频解码方式（如验证 GPU 解码效果，尝试帧降采样）。</li><li>自定义逻辑：如果 detect_scenes 函数中自定义的逻辑部分（例如，在 scene_detector.py 中添加检测器、调整场景列表的循环）耗时较长，需要针对性优化。</li></ul><h3 id="4-3-分析资源监控数据">4.3. 分析资源监控数据</h3><h4 id="CPU-瓶颈：">CPU 瓶颈：</h4><ul><li>如果 CPU 单核或多核长时间处于高负载状态，表明计算是瓶颈。</li><li>检查是否存在某个核心远高于其他核心的情况（可能表示并行度不足或某些操作无法有效并行，尽管 detect_scenes 本身是单线程的，但其调用的<br>OpenCV 或 FFmpeg 后端可能利用多核）。</li></ul><h4 id="内存瓶颈：">内存瓶颈：</h4><ul><li>如果内存使用持续增长或达到系统上限，可能存在内存泄漏或处理大数据时内存管理不当。</li><li>PySceneDetect 通常是流式处理，但某些配置或长视频仍可能消耗较多内存。确保 video_api_obj.reset() 被正确调用。</li></ul><h4 id="GPU-瓶颈：">GPU 瓶颈：</h4><ul><li>如果启用了 GPU 加速，但 GPU 利用率低，检查驱动、CUDA/OpenCV 配置，以及数据传输到 GPU 的开销。示例输出显示 GPU 配置 (<br>Config_Default_GPU) 速度更快，表明 GPU 在此场景下可能得到了有效利用。</li><li>如果 GPU 利用率高，但性能提升不明显，可能瓶颈在其他部分（如 Python 代码本身、磁盘 I/O）。</li></ul><h2 id="5-根据分析结果改进代码-优化方向示例">5.根据分析结果改进代码 (优化方向示例)</h2><blockquote><p>基于上述分析，可以针对性地对 scene_detector.py 及相关模块进行优化：</p></blockquote><h4 id="场景检测策略优化：">场景检测策略优化：</h4><ul><li>调整检测器：根据性能和准确度需求，在 config.ini 中启用或禁用特定的检测器，或调整其参数（如 threshold,<br>min_scene_len_frames）。从示例输出看，仅使用 ContentDetector 速度最快，但场景数略少。需要根据业务需求决定是否值得牺牲一些检测场景换取速度。</li><li>帧降采样：对于长视频，在 scene_detector.py 中为 SceneManager 设置 frame_skip 或通过<br>video_api_obj.set_downscale_factor() 来减少处理的帧数/分辨率，以大幅提升速度。将其作为可配置项。视频解码优化：</li><li>基于测试结果，确定 CPU 解码或 GPU 解码 (VideoStreamCv2Cuda) 在何种情况下更优，并相应调整配置。示例中 GPU 解码效果明显。</li></ul><h4 id="代码逻辑优化：">代码逻辑优化：</h4><ul><li>检查 detect_scenes 内部是否有可优化的循环或数据处理。确保资源（如 video_api_obj）得到正确和及时的释放。</li></ul><h4 id="长视频特定优化：">长视频特定优化：</h4><ul><li>考虑更细粒度的检查点机制（如果 detect_scenes 本身耗时过长）。</li><li>探索分块处理长视频的策略。</li></ul><h2 id="6-迭代与验证">6. 迭代与验证</h2><blockquote><p>性能优化是一个迭代过程。每次应用优化后，都应重新运行基准测试，以验证优化的效果，并确保没有引入新的性能问题或功能性缺陷。</p></blockquote><blockquote><p>通过遵循本指南，您可以系统地评估和提升视频处理项目的性能，特别是在处理计算密集的场景检测任务时。</p></blockquote><h2 id="总结">总结</h2><h3 id="macOS-场景检测性能测试总结">macOS 场景检测性能测试总结</h3><p>测试视频: <code>建筑家园-02.mp4</code> (60fps)<br>测试日期: 2025-05-30</p><h4 id="关键测试数据">关键测试数据</h4><table><thead><tr><th style="text-align:left">测试配置</th><th style="text-align:left">解码方式</th><th style="text-align:left">检测器组合</th><th style="text-align:left">处理时长 (秒)</th><th style="text-align:left">检测场景数</th><th style="text-align:left">帧率 (fps)</th></tr></thead><tbody><tr><td style="text-align:left"><code>Config_Default_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">MultiDetector</td><td style="text-align:left">433.7327</td><td style="text-align:left">214</td><td style="text-align:left">60.00</td></tr><tr><td style="text-align:left"><code>Config_Default_GPU</code></td><td style="text-align:left">GPU (请求)</td><td style="text-align:left">MultiDetector</td><td style="text-align:left">411.5587</td><td style="text-align:left">214</td><td style="text-align:left">60.00</td></tr><tr><td style="text-align:left"><code>Config_ContentDetectorOnly_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector</td><td style="text-align:left">400.2969</td><td style="text-align:left">164</td><td style="text-align:left">60.00</td></tr></tbody></table><h4 id="主要结论">主要结论</h4><ol><li><p>GPU 加速在 macOS 上的表现:</p><ul><li>当请求 GPU 解码时 (<code>Config_Default_GPU</code>)，即使 PySceneDetect 日志显示回退到标准的 <code>VideoStreamCv2</code> 后端 (而非 <code>VideoStreamCv2Cuda</code>)，处理速度相比纯 CPU 解码 (<code>Config_Default_CPU</code>) 仍有约 5% 的提升 (从 433.73 秒降至 411.56 秒)。</li><li>这表明在 macOS 上，<code>VideoStreamCv2</code> 可能间接利用了系统级的硬件加速框架 (如 AVFoundation/VideoToolbox) 进行视频解码。</li><li>需要注意的是，这种提升幅度可能不如在具有专用 NVIDIA GPU 和正确配置 CUDA 的环境中使用 <code>VideoStreamCv2Cuda</code> 时显著。</li></ul></li><li><p>检测器选择对性能和结果的显著影响:</p><ul><li>仅使用 <code>ContentDetector</code> (<code>Config_ContentDetectorOnly_CPU</code>) 的配置速度最快，处理时长为 400.30 秒。</li><li>与使用 <code>MultiDetector</code> 的 CPU 配置 (<code>Config_Default_CPU</code>) 相比，速度提升了约 7.7% (快了约 33 秒)。</li><li>然而，仅使用 <code>ContentDetector</code> 时，检测到的场景数从 214 个减少到 164 个，表明牺牲了一定的检测全面性。这需要在处理效率和检测结果的完整性之间进行权衡。</li></ul></li><li><p>PySceneDetect 后端行为:</p><ul><li>测试日志中出现 <code>Backend None not available. Trying another backend: opencv</code>，表明 PySceneDetect 在尝试使用一个（可能是用户配置的或库优选的）后端失败后，成功回退到了 OpenCV 后端 (<code>VideoStreamCv2</code>)。这对于理解实际的解码路径和排查配置问题非常重要。</li></ul></li><li><p>库的兼容性提示:</p><ul><li>日志中 <code>AdaptiveDetector</code> 相关的警告 <code>min_delta_hsv is deprecated, use min_content_val instead.</code> 提示需要更新配置文件中的参数，以确保与 PySceneDetect 库的持续兼容性和最佳实践。</li></ul></li></ol><h3 id="windows-测试结果">windows 测试结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">D:\pythonProject\venv1\Scripts\python.exe D:\pythonProject\scene-detect-split1\src\tests\benchmark_scene_detector.py </span><br><span class="line">2025-05-30 14:11:57.528 | INFO     | config.config:initialize_settings:147 - Configuration successfully loaded from: D:\pythonProject\scene-detect-split1\src\run\config.ini</span><br><span class="line">2025-05-30 14:11:57.529 | INFO     | __main__:&lt;module&gt;:118 - Configuration loaded from: D:\pythonProject\scene-detect-split1\src\run\config.ini</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:&lt;module&gt;:210 - </span><br><span class="line">===== Processing Video: Z:\样例\CG渲染样例\建筑家园\建筑家园-02.mp4 =====</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_CPU ---</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 14:11:57.870 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:45.990 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:45.990 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results\profile_建筑家园_02_Config_Default_CPU.prof</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 288.2435 seconds</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_GPU ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: True</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">2025-05-30 14:16:46.147 | WARNING  | video.scene_detector:detect_scenes:93 - [MainThread] VideoStreamCv2Cuda not available. Using CPU for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:16:46.242 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:16:46.243 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:46.243 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:35.982 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:35.982 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:20:36.101 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results\profile_建筑家园_02_Config_Default_GPU.prof</span><br><span class="line">2025-05-30 14:20:36.101 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 229.9882 seconds</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_ContentDetectorOnly_CPU ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:24:23.153 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:24:23.153 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 227.1770 seconds</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:&lt;module&gt;:236 - </span><br><span class="line"></span><br><span class="line">===== Benchmark Summary =====</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:238 - </span><br><span class="line">Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_CPU             | Duration: 288.2435s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_GPU             | Duration: 229.9882s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_ContentDetectorOnly_CPU | Duration: 227.1770s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:242 - </span><br><span class="line">To analyze .prof files, use a tool like &#x27;snakeviz&#x27; or Python&#x27;s pstats module.</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:243 - Example: python -m pstats profiling_results/your_profile_file.prof</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:244 - Then in pstats shell: sort cumulative, stats 20</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Windows-平台场景检测性能测试总结">Windows 平台场景检测性能测试总结</h4><p>测试视频: <code>建筑家园-02.mp4</code> (60fps)<br>测试日期: 2025-05-30<br>测试平台: Windows</p><h5 id="关键测试数据-2">关键测试数据</h5><table><thead><tr><th style="text-align:left">测试配置</th><th style="text-align:left">解码方式</th><th style="text-align:left">检测器设置</th><th style="text-align:left">处理时长 (秒)</th><th style="text-align:left">检测场景数</th></tr></thead><tbody><tr><td style="text-align:left"><code>Config_Default_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector*</td><td style="text-align:left">288.2435</td><td style="text-align:left">159</td></tr><tr><td style="text-align:left"><code>Config_Default_GPU</code></td><td style="text-align:left">GPU (请求)</td><td style="text-align:left">ContentDetector*</td><td style="text-align:left">229.9882</td><td style="text-align:left">159</td></tr><tr><td style="text-align:left"><code>Config_ContentDetectorOnly_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector</td><td style="text-align:left">227.1770</td><td style="text-align:left">159</td></tr></tbody></table><ul><li>重要: 日志显示所有配置（包括 <code>Config_Default_CPU</code> 和 <code>Config_Default_GPU</code>）的 <code>Detector Setup</code> 均为 <code>ContentDetector</code>。这表明 <code>benchmark_scene_detector.py</code> 中的这些 “Default” 配置可能错误地仅指定了 <code>ContentDetector</code>，而不是 <code>config.ini</code> 中定义的 <code>MultiDetector</code>。因此，以下分析基于所有测试实际上都只使用了 <code>ContentDetector</code>。</li></ul><h5 id="主要结论-2">主要结论</h5><ol><li><p>GPU 加速请求在 Windows 上的表现 (当 CUDA 后端不可用时):</p><ul><li>当请求 GPU 解码时 (<code>Config_Default_GPU</code>)，日志明确指出 <code>VideoStreamCv2Cuda not available. Using CPU...</code>。最终视频流通过标准的 <code>VideoStreamCv2</code> 后端由 CPU 完成解码。</li><li>尽管如此，<code>Config_Default_GPU</code> (229.99 秒) 仍然比 <code>Config_Default_CPU</code> (288.24 秒) 快了约 58.25 秒，性能提升约 20.2%。</li><li>这可能归因于 Windows 平台上 OpenCV 的 CPU 解码后端（如 Media Foundation 或 DirectShow）在特定路径或针对某些视频格式时，相比纯粹的 CPU 路径有更优化的表现，或者系统资源调度差异。</li></ul></li><li><p><code>ContentDetectorOnly_CPU</code> 作为最快配置:</p><ul><li><code>Config_ContentDetectorOnly_CPU</code> (227.18 秒) 是所有配置中最快的，符合预期。</li><li>它与 <code>Config_Default_GPU</code> (实际也是 ContentDetector + CPU 解码) 的性能差异较小 (约 2.8 秒)，可能在测量误差范围内。</li></ul></li><li><p>PySceneDetect 后端回退:</p><ul><li>日志清晰展示了当优选后端（如 CUDA）不可用时，PySceneDetect 回退到标准 OpenCV (<code>VideoStreamCv2</code>) 的行为。</li></ul></li><li><p>与 macOS 测试的对比 (针对同一视频，但检测器配置可能不同):</p><ul><li>在 Windows 上仅使用 <code>ContentDetector</code> (CPU) 处理此视频 (约 227-288 秒) 比之前在 macOS 上使用 <code>MultiDetector</code> (CPU) (约 433 秒) 要快。如果 macOS 也仅用 <code>ContentDetector</code> (约 400 秒)，Windows 仍然更快。这可能反映了操作系统底层视频处理框架的效率差异。</li><li>在“请求GPU但回退到CPU”的情况下，Windows 平台显示出相对更大的性能提升 (约 20.2%)，而 macOS 平台 (针对 <code>MultiDetector</code>) 约为 5%。</li></ul></li></ol><h5 id="关键问题点与后续行动建议">关键问题点与后续行动建议</h5><ol><li><p>核实并修正 <code>benchmark_scene_detector.py</code> 中的测试配置:</p><ul><li>首要任务: 确保 <code>Config_Default_CPU</code> 和 <code>Config_Default_GPU</code> 配置正确地使用了您期望的 <code>MultiDetector</code> 设置（从 <code>config.ini</code> 的 <code>[SceneDetectorSetup]</code> 加载）。如果当前它们被错误地指向了仅 <code>ContentDetector</code>，那么对 <code>MultiDetector</code> 的性能评估是不准确的。</li></ul></li><li><p>彻底排查 <code>VideoStreamCv2Cuda not available</code> 问题:</p><ul><li>检查 OpenCV-Python 版本 (确保是为 Windows 编译的、包含 CUDA 支持的版本)。</li><li>检查 CUDA Toolkit 和 cuDNN 的安装与兼容性。</li><li>检查 系统环境变量 (如 <code>PATH</code>, <code>CUDA_PATH</code>)。</li><li>检查 NVIDIA 驱动程序版本。</li><li>运行项目中的 <code>cuda_available_verify.py</code> 脚本获取直接反馈。</li></ul></li><li><p>在 CUDA 成功启用后重新进行基准测试:</p><ul><li>只有当 <code>VideoStreamCv2Cuda</code> 能够成功加载和使用时，才能真正评估 GPU 对视频解码的加速效果。</li><li>届时，重点对比 <code>MultiDetector</code> 配置下 CPU 与 GPU (CUDA) 的性能。</li></ul></li><li><p>分析 <code>.prof</code> 文件:</p><ul><li>对于修正配置后的 <code>MultiDetector</code> 测试，使用 <code>snakeviz</code> 分析 <code>.prof</code> 文件。</li><li>关注视频 I/O (<code>cv2.VideoCapture</code> 的 <code>retrieve</code> 和 <code>grab</code> 方法) 和各个子检测器在 CPU 与 GPU 配置下的耗时。</li></ul></li><li><p>继续测试帧降采样:</p><ul><li>无论 CUDA 是否成功启用，如果视频 I/O 依然是主要瓶颈，帧降采样 (<code>frame_skip</code> 和 <code>downscale_factor</code>) 都是至关重要的优化策略。</li></ul></li></ol><h2 id="后续分析建议">后续分析建议</h2><ul><li>深入剖析 <code>.prof</code> 文件: 使用 <code>snakeviz</code> 或 <code>pstats</code> 分析 <code>MultiDetector</code> 配置下各具体检测器的耗时，以精确定位性能瓶颈。</li><li>测试帧降采样: 鉴于当前处理时间较长，强烈建议测试帧降采样 (<code>frame_skip</code> 或 <code>downscale_factor</code>) 对长视频处理效率的影响。</li><li>参数调优: 针对 <code>MultiDetector</code> 中的各个检测器，细致调整其参数，寻找性能与准确度的最佳平衡点。</li><li>多样化测试: 使用更多不同类型和长度的视频进行测试，以验证当前结论的普适性。</li></ul><h4 id="测试结果如图">测试结果如图</h4><h5 id="macOS平台测试结果图示">macOS平台测试结果图示</h5><ul><li>cpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/cpu_prof.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_prof.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/cpu_profile_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_profile_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>gpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/gpu_prof.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_prof.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/gpu_prof_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_prof_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h5 id="window平台测试结果图示">window平台测试结果图示</h5><ul><li>cpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/cpu_win_pro.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_win_pro.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/cpu_win_pro_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_win_pro_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>gpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/gpu_win_pro.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_win_pro.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/gpu_win_pro_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_win_pro_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;场景检测性能优化方向与测试方法&lt;/h1&gt;
&lt;h2 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;本指南旨在提供一套系统化的方法，用于验证和分析视频处理项目的效率，特别是针对场景检测模块的性能。通过收集关键性能指标 (KPIs)&lt;br&gt;
和剖析代码执行，我们可以识别性能瓶</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PySceneDetect 中场景检测器</title>
    <link href="https://caozhaoqi.github.io/2025/05/15/scene-detect-method/"/>
    <id>https://caozhaoqi.github.io/2025/05/15/scene-detect-method/</id>
    <published>2025-05-15T02:05:41.000Z</published>
    <updated>2025-11-25T15:05:10.362Z</updated>
    
    <content type="html"><![CDATA[<h1>PySceneDetect 中场景检测器</h1><blockquote><p>主要包括：<code>ContentDetector</code>, <code>ThresholdDetector</code>, <code>AdaptiveDetector</code>的算法及参数含义、算法思想以及如何确定这些参数。</p></blockquote><h2 id="通用概念"><strong>通用概念</strong></h2><ul><li><strong>场景 (Scene):</strong> 一系列连续的、在视觉上或叙事上构成一个单元的镜头。</li><li><strong>切点 (Cut/Scene Break):</strong> 两个不同场景之间的边界。</li><li><strong>帧间差异 (Frame-to-Frame Difference):</strong> 检测器通常通过比较连续（或间隔的）视频帧之间的差异来识别潜在的切点。差异的计算方式因检测器而异。</li><li><strong>阈值 (Threshold):</strong> 一个预设的数值。当计算出的帧间差异超过这个阈值时，检测器就认为可能发生了一个场景切换。</li><li><strong>最小场景长度 (Min Scene Length / <code>min_scene_len</code>):</strong> 检测到的场景必须达到的最短持续时间（通常以帧数或时间码表示）。如果两个检测到的原始切点之间的距离小于这个值，它们可能会被合并，以避免产生过多非常短的、无意义的场景片段。<strong>为了分析和找到最佳检测参数，我们通常将这个值设为1帧，以观察检测器最原始的输出。</strong></li></ul><hr><h2 id="算法概述">算法概述</h2><p><strong>1. <code>ThresholdDetector</code> (阈值检测器)</strong></p><blockquote><p>主要检测淡入淡出到黑屏或白屏场景</p></blockquote><ul><li><p><strong>命令:</strong> <code>detect-threshold</code></p></li><li><p><strong>核心思想:</strong> 主要通过监测视频帧的<strong>平均亮度/强度</strong>是否跨越一个固定的阈值来判断淡入/淡出事件。它假设场景切换（特别是淡入淡出）会伴随着画面整体变亮或变暗到某个程度。</p></li><li><p><strong>主要参数及其含义：</strong></p><ul><li><p><strong><code>threshold</code> (或 <code>-t VAL</code>)</strong>:</p><ul><li><strong>含义:</strong> 一个 0-255 之间的整数（或浮点数）。这是判断画面是否进入“淡出”或“淡入”状态的亮度基准。</li><li><strong>算法交互:</strong> 与 <code>method</code> 参数配合使用。</li><li><strong>如何确定:</strong><ol><li><strong>使用亮度分析工具 (如我们之前编写的 <code>analyze_brightness.py</code>)</strong>：查看你的视频在发生淡入淡出到“黑屏”或“白屏”时，那些“黑/白”帧的实际平均亮度值。</li><li>如果使用 <code>method = FLOOR</code> (检测淡出到暗/从暗淡入)：<code>threshold</code> 应略高于视频中“黑屏”状态的平均亮度。例如，如果黑屏亮度在 2-5 之间，你可以尝试 <code>threshold = 5</code> 或 <code>8</code> 或 <code>10</code>。如果阈值设得太低（比如1），那么只有几乎纯黑的帧才会被识别。</li><li>如果使用 <code>method = CEILING</code> (检测淡出到亮/从亮淡入)：<code>threshold</code> 应略低于视频中“白屏”状态的平均亮度。例如，如果白屏亮度在 250-253 之间，你可以尝试 <code>threshold = 250</code> 或 <code>245</code>。</li><li><strong>实验法：</strong> 从一个相对宽松的值开始（例如，对于 FLOOR 方法，从 15-20 开始；对于 CEILING，从 230-240 开始），然后逐渐向更严格的值调整（FLOOR 向下调，CEILING 向上调），同时观察 <code>save-images</code> 的结果。</li></ol></li></ul></li><li><p><strong><code>fade_bias</code> (或 <code>-f PERCENT</code>)</strong>:</p><ul><li><strong>含义:</strong> 一个百分比值（命令行是 -100 到 100，Python 类内部是 -1.0 到 +1.0）。它调整检测到的淡入淡出切点的<strong>精确位置</strong>。</li><li><strong>算法交互:</strong> 当检测器识别到一次亮度从阈值一侧跨越到另一侧（例如，从高于阈值变为低于阈值，再恢复到高于阈值，这构成一次淡出再淡入），<code>fade_bias</code> 决定切点放在这个过程的哪个阶段。<ul><li>命令行 <code>-100</code> (Python <code>-1.0</code>): 切点尽可能靠近完全淡出到黑/白的时刻，或者刚开始从黑/白恢复的时刻（取决于具体实现和淡入/淡出方向）。</li><li>命令行 <code>0</code> (Python <code>0.0</code>): 切点放在淡出和淡入过程的中间。</li><li>命令行 <code>+100</code> (Python <code>+1.0</code>): 切点尽可能靠近刚开始淡出或完全淡入完成的时刻。</li></ul></li><li><strong>如何确定:</strong><ol><li>通常对于视频间的切换，我们希望在画面完全变黑/白之后，或者刚开始有新画面时进行切割。所以一个中等到较大的负偏置（例如命令行的 <code>30</code> 到 <code>70</code>，对应 Python 的 <code>(PERCENT/50.0) - 1.0</code>）可能是合适的，这会使切点更倾向于“黑场”的边缘。</li><li><strong>实验法：</strong> 设置一个基础的 <code>threshold</code>，然后尝试不同的 <code>fade_bias</code> 值（例如 -80, -50, 0, 50, 80），观察 <code>save-images</code> 中切点图片的位置，看哪个最符合你的期望。</li></ol></li></ul></li><li><p><strong><code>method</code> (Python 类参数，<code>ThresholdDetector.Method.FLOOR</code> 或 <code>ThresholdDetector.Method.CEILING</code>)</strong>:</p><ul><li><strong>含义:</strong> 定义了如何将帧的平均亮度与 <code>threshold</code> 进行比较来触发事件。<ul><li><code>FLOOR</code>: 当帧亮度<strong>低于 (falls below)</strong> <code>threshold</code> 时，认为是淡出（到暗）；当从低于状态恢复到<strong>高于等于</strong> <code>threshold</code> 时，认为是淡入（从暗）。</li><li><code>CEILING</code>: 当帧亮度<strong>高于 (rises above)</strong> <code>threshold</code> 时，认为是淡出（到亮）；当从高于状态恢复到<strong>低于</strong> <code>threshold</code> 时，认为是淡入（从亮）。</li></ul></li><li><strong>如何确定:</strong><ol><li>如果你的视频主要是淡入淡出到<strong>黑色</strong>，或者从黑色淡入，选择 <code>FLOOR</code>。</li><li>如果你的视频主要是淡入淡出到<strong>白色</strong>，或者从白色淡入，选择 <code>CEILING</code> (并配合非常高的 <code>threshold</code>)。</li><li>你的 <code>config.ini</code> 中 <code>method = FLOOR</code> (因为 <code>FRAME_AVERAGE</code> 会回退到 <code>FLOOR</code>)，所以当前是针对暗场景的。</li></ol></li></ul></li><li><p><strong><code>min_scene_len</code> (或 <code>-m TIMECODE</code>，命令行是 <code>-m 1</code> 表示1帧)</strong>:</p><ul><li><strong>含义:</strong> 最小场景长度。</li><li><strong>如何确定:</strong> 为了分析检测器的原始性能和找到最佳的 <code>threshold</code> / <code>fade_bias</code>，<strong>始终将其设置为 <code>1</code> (或 <code>1f</code>，根据具体命令格式)</strong>。在确定了最佳检测参数后，如果需要避免过多短片段，再在最终处理时考虑增大这个值。</li></ul></li></ul></li></ul><hr><p><strong>2. <code>ContentDetector</code> (内容检测器)</strong></p><ul><li><p><strong>命令:</strong> <code>detect-content</code></p></li><li><p><strong>核心思想:</strong> 通过比较连续帧之间<strong>视觉内容的整体差异</strong>来检测场景切换。它不仅仅看亮度，还会考虑颜色分布（色调 Hue, 饱和度 Saturation）和可能的边缘信息。对于平均亮度变化不大但内容发生显著改变的切换（如交叉淡化、某些快速剪辑）通常更有效。</p></li><li><p><strong>主要参数及其含义：</strong></p><ul><li><p><strong><code>threshold</code> (或 <code>-t VAL</code>)</strong>:</p><ul><li><strong>含义:</strong> 一个浮点数，表示帧间内容差异的阈值。这个差异值是综合了色调、饱和度、亮度（以及可能有的边缘）通道的变化计算出来的。</li><li><strong>算法交互:</strong> 当计算出的帧间内容综合差异值<strong>超过</strong>此阈值时，触发切点。</li><li><strong>如何确定:</strong><ol><li><code>ContentDetector</code> 的阈值范围和敏感度与 <code>ThresholdDetector</code> 不同。默认值通常在 20-35 之间。</li><li><strong>较低的阈值意味着更敏感。</strong> 对于平滑的交叉淡化或细微的内容变化，你可能需要将阈值降低到 15-25，甚至更低（5-15）。</li><li><strong>实验法是关键：</strong><ul><li><strong>使用 <code>threshold_explorer.py</code> 工具（代码见后）</strong>：这是最系统的方法。设定一个阈值范围（例如，从 5.0 到 30.0，步长 1.0 或 2.0），对抽样视频运行。</li><li><strong>观察图表：</strong> 查看“平均场景数 vs. 阈值”图。寻找曲线的“拐点”——即阈值再降低，场景数开始急剧增加（可能引入噪声）；或者阈值再升高，场景数急剧减少（可能遗漏切换）的那个临界区域。</li><li><strong>结合 <code>save-images</code>：</strong> 对于你在图表上找到的几个有希望的阈值点，使用 <code>--save_images_for</code> 选项（在 <code>threshold_explorer.py</code> 中）或直接用 <code>scenedetect</code> 命令行工具（配合 <code>save-images</code>）来实际查看这些阈值下的切点图片。人工判断这些切点是否符合你对交叉淡化或其他场景切换的定义。</li></ul></li><li><strong>从一个相对保守的值开始（例如 25-30），如果检测不到足够的场景，逐渐降低阈值，并观察结果。</strong></li></ol></li></ul></li><li><p><strong><code>min_scene_len</code> (或 <code>-m TIMECODE</code>，命令行通常是 <code>-m 1</code> 表示1帧)</strong>:</p><ul><li><strong>含义:</strong> 最小场景长度。</li><li><strong>如何确定:</strong> 同 <code>ThresholdDetector</code>，在参数探索阶段，<strong>始终将其设置为 <code>1</code></strong>。</li></ul></li><li><p><strong><code>weights</code> (Hue, Saturation, Luma, Edges - Python 类参数)</strong>:</p><ul><li><strong>含义:</strong> 定义在计算帧间内容差异时，色调、饱和度、亮度、边缘这几个分量各自所占的权重。</li><li><strong>算法交互:</strong> 影响最终的综合差异值。</li><li><strong>如何确定:</strong><ol><li><strong>通常从默认权重开始。</strong> PySceneDetect 的默认权重是经过一定调优的。</li><li>如果默认权重效果不佳，并且你对视频内容的特性有了解：<ul><li>如果场景切换主要体现在<strong>颜色</strong>变化上（例如，从冷色调场景交叉淡化到暖色调场景），可以尝试<strong>增加 <code>weights_hue</code> 和 <code>weights_saturation</code></strong> 的权重，同时<strong>减少 <code>weights_luma</code></strong> 的权重。</li><li>如果场景切换主要体现在<strong>结构或物体轮廓</strong>变化上，确保边缘检测被启用并且 <code>weights_edges</code> 有合适的权重。</li><li>这部分调整通常需要更多的实验和对视频内容的细致分析。你的 <code>config.ini</code> 和 <code>scene_detector.py</code> 允许你设置这些权重。</li></ul></li></ol></li></ul></li><li><p><strong><code>luma_only</code> (布尔值)</strong>:</p><ul><li><strong>含义:</strong> 如果为 <code>true</code>，则在计算内容差异时只考虑亮度通道，忽略色调和饱和度。</li><li><strong>算法交互:</strong> 相当于将 <code>weights_hue</code> 和 <code>weights_saturation</code> 设为 0。</li><li><strong>如何确定:</strong><ol><li>对于颜色信息丰富且对场景区分很重要的视频（尤其是交叉淡化），通常应将此设为 <code>false</code>（默认）。</li><li>如果视频是黑白的，或者颜色信息干扰性强且不重要，可以设为 <code>true</code>。</li></ol></li></ul></li></ul></li></ul><hr><p><strong>3. <code>AdaptiveDetector</code> (自适应检测器)</strong></p><ul><li><p><strong>命令:</strong> <code>detect-adaptive</code></p></li><li><p><strong>核心思想:</strong> 与 <code>ContentDetector</code> 类似，它也计算帧间内容的差异。但不同之处在于，它不是使用一个固定的全局阈值，而是根据最近一段视频窗口内的帧间差异动态地计算一个自适应阈值。当某一帧的差异显著高于这个动态计算出的局部平均差异时，触发切点。</p></li><li><p><strong>适用场景:</strong> 对于视频整体亮度或内容变化幅度不一致的情况可能有用。例如，一个视频可能有些部分变化剧烈，有些部分变化平缓。固定阈值可能难以同时适应这两种情况。</p></li><li><p><strong>主要参数及其含义：</strong></p><ul><li><p><strong><code>adaptive_threshold</code> (或 <code>-t VAL</code>)</strong>:</p><ul><li><strong>含义:</strong> 一个乘数因子（通常是较小的浮点数，例如 2.0-5.0，默认可能是 3.0）。</li><li><strong>算法交互:</strong> 检测器会计算一个基于滑动窗口的帧间差异的统计量（例如平均值或移动平均值）。如果当前帧的差异超过了这个统计量乘以 <code>adaptive_threshold</code>，则认为是一个切点。值越大，检测越不敏感（需要更大的相对变化）。</li><li><strong>如何确定:</strong><ol><li><strong>实验法：</strong> 从默认值（例如 3.0）开始。</li><li>如果检测到的场景太少，尝试降低此值（例如 2.5, 2.0）。</li><li>如果检测到的场景太多（噪声），尝试增加此值（例如 3.5, 4.0）。</li><li>同样，结合 <code>save-images</code> 进行人工检查。</li></ol></li></ul></li><li><p><strong><code>min_scene_len</code> (或 <code>-m TIMECODE</code>)</strong>:</p><ul><li><strong>含义:</strong> 最小场景长度。</li><li><strong>如何确定:</strong> 同上，参数探索阶段设为 <code>1</code>。</li></ul></li><li><p><strong><code>window_width</code> (或 <code>--window_width VAL</code>, 帧数)</strong>:</p><ul><li><strong>含义:</strong> 用于计算自适应阈值的滑动窗口的宽度（以帧为单位）。如果为 0，检测器通常会根据视频帧率自动设置一个合理的窗口大小。</li><li><strong>算法交互:</strong> 窗口越大，自适应阈值对局部快速变化的敏感度越低，对较长时间的平均变化更敏感。窗口越小，对局部突变越敏感。</li><li><strong>如何确定:</strong><ol><li>通常可以从默认值 (0，即自动) 开始。</li><li>如果自动设置效果不佳，可以根据视频的平均镜头长度或变化节奏来手动设置。例如，如果快速剪辑多，可以尝试较小的窗口；如果长镜头多，可以尝试较大的窗口。</li></ol></li></ul></li><li><p><strong><code>min_delta_hsv</code> (浮点数 0-255)</strong>:</p><ul><li><strong>含义:</strong> 有些版本的 <code>AdaptiveDetector</code> 可能使用这个参数。它设定了一个帧间 HSV（色调、饱和度、亮度）差异的最小绝对值。即使相对差异（通过 <code>adaptive_threshold</code> 判断）很大，但如果绝对差异本身非常小（例如，在几乎全黑的场景中微小的噪声变化），也可能不被视为切点。这有助于过滤掉在非常低对比度区域的噪声。</li><li><strong>如何确定:</strong><ol><li>如果你的视频中有非常暗或对比度非常低的区域，并且 <code>AdaptiveDetector</code> 在这些区域产生了误报，可以尝试增加此值（例如从默认的 10-15 增加到 20-25）。</li></ol></li></ul></li></ul></li></ul><h2 id="通用参数确定流程："><strong>通用参数确定流程：</strong></h2><ol><li><p><strong>选择检测器类型：</strong></p><ul><li><strong>淡入淡出到黑/白：</strong> 优先尝试 <code>ThresholdDetector</code>。</li><li><strong>交叉淡化、内容变化明显但亮度变化不大：</strong> 优先尝试 <code>ContentDetector</code>。</li><li><strong>视频内容变化特征不一致，难以用固定阈值把握：</strong> 可以尝试 <code>AdaptiveDetector</code>。</li><li><strong>不确定或想组合使用：</strong> 可以使用 <code>MultiDetector</code>，并分别配置上述检测器（在你的 <code>config.ini</code> 中将 <code>[SceneDetectorSetup]</code> 的 <code>detector_type</code> 设为 <code>MultiDetector</code>，然后在各个检测器的配置节中设置 <code>enabled = true</code> 和相应的参数）。</li></ul></li><li><p><strong>设置 <code>min_scene_len = 1</code>：</strong> 在寻找最佳检测参数的阶段，始终这样做。</p></li><li><p><strong>选择一个（或几个）代表性的抽样视频：</strong> 这些视频应该包含你期望检测到的各种场景切换效果。</p></li><li><p><strong>对于选定的检测器，系统地扫描其主要阈值参数：</strong></p><ul><li><strong><code>ThresholdDetector</code></strong>: 扫描 <code>threshold</code> 和 <code>fade_bias</code>。</li><li><strong><code>ContentDetector</code></strong>: 主要扫描 <code>threshold</code>。可以后续再调整 <code>weights</code>。</li><li><strong><code>AdaptiveDetector</code></strong>: 主要扫描 <code>adaptive_threshold</code>。可以后续再调整 <code>window_width</code>。</li><li><strong>使用你的 <code>threshold_explorer.py</code> 工具</strong> (如果它是针对 <code>ContentDetector</code> 的，你需要为其他检测器做类似的参数扫描逻辑，或者修改它使其更通用)。</li></ul></li><li><p><strong>可视化和人工检查：</strong></p><ul><li>查看场景数量随阈值变化的图表。</li><li>对于几个有希望的阈值设置，使用 <code>save-images</code> 生成的图片进行人工检查，看切点是否准确、是否有漏检或误报。</li></ul></li><li><p><strong>迭代和微调：</strong> 根据可视化和人工检查的结果，调整参数范围，进行更细致的扫描，或者尝试调整次要参数（如权重、窗口宽度等）。</p></li><li><p><strong>选择“最佳”参数：</strong> “最佳”通常是在“召回率”（找到所有想找的切换）和“精确率”（找到的切换都是正确的）之间的一个平衡。这取决于你的具体需求。可能没有一组参数对所有视频都完美，你可能需要根据视频类型选择不同的参数集，或者接受一定的折衷。</p></li></ol><h2 id="可视化确定内容检测阈值方法">可视化确定内容检测阈值方法</h2><h3 id="内容检测器阈值参考代码">内容检测器阈值参考代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scenedetect <span class="keyword">import</span> open_video, SceneManager, ContentDetector, FrameTimecode, VideoStreamCv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">    <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">    MATPLOTLIB_AVAILABLE = <span class="literal">True</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    MATPLOTLIB_AVAILABLE = <span class="literal">False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;警告: Matplotlib 或 Pandas 未安装，将无法生成可视化图表。&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请运行: pip install matplotlib pandas&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 日志设置 ---</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&quot;ThresholdExplorer&quot;</span>)</span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_video_files</span>(<span class="params">input_path: Path, extensions: <span class="type">List</span>[<span class="built_in">str</span>], recursive: <span class="built_in">bool</span></span>) -&gt; <span class="type">List</span>[Path]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从指定路径收集视频文件列表。&quot;&quot;&quot;</span></span><br><span class="line">    video_files = []</span><br><span class="line">    logger.info(<span class="string">f&quot;正在扫描目录: <span class="subst">&#123;input_path&#125;</span> (递归: <span class="subst">&#123;recursive&#125;</span>)，寻找扩展名: <span class="subst">&#123;extensions&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> ext <span class="keyword">in</span> extensions:</span><br><span class="line">        pattern = <span class="string">f&quot;**/*<span class="subst">&#123;ext&#125;</span>&quot;</span> <span class="keyword">if</span> recursive <span class="keyword">else</span> <span class="string">f&quot;*<span class="subst">&#123;ext&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">for</span> file_path <span class="keyword">in</span> input_path.glob(pattern):</span><br><span class="line">            <span class="keyword">if</span> file_path.is_file() <span class="keyword">and</span> <span class="keyword">not</span> file_path.name.startswith(<span class="string">&#x27;._&#x27;</span>):</span><br><span class="line">                video_files.append(file_path)</span><br><span class="line">    logger.info(<span class="string">f&quot;在文件系统中找到 <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> 个视频文件。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> video_files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sampled_videos</span>(<span class="params">video_list: <span class="type">List</span>[Path], sample_ratio: <span class="built_in">float</span> = -<span class="number">1.0</span>, num_samples: <span class="built_in">int</span> = -<span class="number">1</span></span>) -&gt; <span class="type">List</span>[Path]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据比例或数量对视频列表进行抽样。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_list:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num_samples &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> num_samples &gt;= <span class="built_in">len</span>(video_list):</span><br><span class="line">            <span class="keyword">return</span> video_list</span><br><span class="line">        <span class="keyword">return</span> random.sample(video_list, num_samples)</span><br><span class="line">    <span class="keyword">elif</span> <span class="number">0.0</span> &lt; sample_ratio &lt;= <span class="number">1.0</span>:</span><br><span class="line">        k = <span class="built_in">int</span>(<span class="built_in">len</span>(video_list) * sample_ratio)</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(video_list) &gt; <span class="number">0</span>: k = <span class="number">1</span>  <span class="comment"># 至少抽一个样本</span></span><br><span class="line">        <span class="keyword">return</span> random.sample(video_list, k)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 默认不抽样，处理所有</span></span><br><span class="line">        <span class="keyword">return</span> video_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_detection_for_threshold</span>(<span class="params"></span></span><br><span class="line"><span class="params">        video_path: Path,</span></span><br><span class="line"><span class="params">        threshold_value: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        min_len: <span class="built_in">int</span> = <span class="number">1</span>,  <span class="comment"># 保持为1以获得原始切点</span></span></span><br><span class="line"><span class="params">        save_images_output_dir: Path = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        save_images_for_this_run: <span class="built_in">bool</span> = <span class="literal">False</span>  <span class="comment"># 是否为本次特定的阈值运行保存图像</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对单个视频和单个阈值运行 ContentDetector。&quot;&quot;&quot;</span></span><br><span class="line">    scene_manager = SceneManager()</span><br><span class="line">    <span class="comment"># 注意：ContentDetector 的其他参数（如 weights, luma_only）这里使用默认值。</span></span><br><span class="line">    <span class="comment"># 如果需要，也可以将它们作为参数传入。</span></span><br><span class="line">    detector = ContentDetector(threshold=threshold_value, min_scene_len=min_len)</span><br><span class="line">    scene_manager.add_detector(detector)</span><br><span class="line"></span><br><span class="line">    video = <span class="literal">None</span></span><br><span class="line">    num_scenes = <span class="number">0</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        video = open_video(<span class="built_in">str</span>(video_path))</span><br><span class="line">        <span class="comment"># video.set_downscale_factor(1) # 可以考虑降采样以加速，但可能影响检测精度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取有限的帧数进行分析，而不是整个视频，以加快速度</span></span><br><span class="line">        <span class="comment"># 这里我们仍然处理整个（抽样的）视频，因为交叉淡化可能在任何地方</span></span><br><span class="line">        <span class="comment"># 如果视频非常长，可以考虑只分析视频的一部分，但这会使抽样更复杂</span></span><br><span class="line">        scene_manager.detect_scenes(video=video, show_progress=<span class="literal">False</span>)</span><br><span class="line">        scene_list = scene_manager.get_scene_list()</span><br><span class="line">        num_scenes = <span class="built_in">len</span>(scene_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> save_images_for_this_run <span class="keyword">and</span> save_images_output_dir <span class="keyword">and</span> scene_list:</span><br><span class="line">            <span class="keyword">from</span> scenedetect.video_splitter <span class="keyword">import</span> save_images <span class="keyword">as</span> save_images_func</span><br><span class="line">            video_images_dir = save_images_output_dir / <span class="string">f&quot;<span class="subst">&#123;video_path.stem&#125;</span>_thresh_<span class="subst">&#123;threshold_value:<span class="number">.1</span>f&#125;</span>&quot;</span></span><br><span class="line">            video_images_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">            logger.info(<span class="string">f&quot;为视频 <span class="subst">&#123;video_path.name&#125;</span> (阈值 <span class="subst">&#123;threshold_value:<span class="number">.1</span>f&#125;</span>) 保存场景图片到 <span class="subst">&#123;video_images_dir&#125;</span>&quot;</span>)</span><br><span class="line">            save_images_func(</span><br><span class="line">                scene_list=scene_list,</span><br><span class="line">                video_manager=video,  <span class="comment"># open_video 返回的是 VideoManager 或其后端实例</span></span><br><span class="line">                num_images=<span class="number">2</span>,  <span class="comment"># 每个切点前后各一张</span></span><br><span class="line">                output_dir=<span class="built_in">str</span>(video_images_dir),</span><br><span class="line">                image_name_template=<span class="string">&#x27;$VIDEO_NAME-Scene-$SCENE_NUMBER-$IMAGE_NUMBER&#x27;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;处理视频 <span class="subst">&#123;video_path.name&#125;</span> (阈值 <span class="subst">&#123;threshold_value&#125;</span>) 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        num_scenes = -<span class="number">1</span>  <span class="comment"># 表示错误</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> video:</span><br><span class="line">            <span class="comment"># 尝试通用的 release 方法 (适用于 VideoManager)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(video, <span class="string">&#x27;release&#x27;</span>) <span class="keyword">and</span> <span class="built_in">callable</span>(<span class="built_in">getattr</span>(video, <span class="string">&#x27;release&#x27;</span>)):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    video.release()</span><br><span class="line">                    logger.debug(<span class="string">f&quot;Released video object for <span class="subst">&#123;video_path.name&#125;</span> via .release()&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e_rel:</span><br><span class="line">                    logger.warning(<span class="string">f&quot;Error calling .release() on video object for <span class="subst">&#123;video_path.name&#125;</span>: <span class="subst">&#123;e_rel&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 针对 VideoStreamCv2 (以及继承它的 VideoStreamCv2Cuda) 的特殊处理</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">isinstance</span>(video, VideoStreamCv2):  <span class="comment"># VideoStreamCv2 是从 scenedetect.backends.opencv 导入的</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(video, <span class="string">&#x27;_cap&#x27;</span>) <span class="keyword">and</span> video._cap <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        <span class="keyword">if</span> video._cap.isOpened():</span><br><span class="line">                            video._cap.release()</span><br><span class="line">                            logger.debug(<span class="string">f&quot;Released VideoStreamCv2._cap for <span class="subst">&#123;video_path.name&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">except</span> Exception <span class="keyword">as</span> e_cap_rel:</span><br><span class="line">                        logger.warning(<span class="string">f&quot;Error releasing VideoStreamCv2._cap for <span class="subst">&#123;video_path.name&#125;</span>: <span class="subst">&#123;e_cap_rel&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(</span><br><span class="line">                    <span class="string">f&quot;Video object for <span class="subst">&#123;video_path.name&#125;</span> (type: <span class="subst">&#123;<span class="built_in">type</span>(video).__name__&#125;</span>) &quot;</span></span><br><span class="line">                    <span class="string">&quot;does not have a public .release() method and is not a known direct backend &quot;</span></span><br><span class="line">                    <span class="string">&quot;with a specific release pattern. Relying on __del__ for cleanup.&quot;</span></span><br><span class="line">                )</span><br><span class="line">    <span class="keyword">return</span> num_scenes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_thresholds</span>(<span class="params"></span></span><br><span class="line"><span class="params">        video_paths: <span class="type">List</span>[Path],</span></span><br><span class="line"><span class="params">        threshold_range: <span class="type">Tuple</span>[<span class="built_in">float</span>, <span class="built_in">float</span>, <span class="built_in">float</span>],  <span class="comment"># (start, end, step)</span></span></span><br><span class="line"><span class="params">        sample_ratio: <span class="built_in">float</span> = -<span class="number">1.0</span>,</span></span><br><span class="line"><span class="params">        num_sample_videos: <span class="built_in">int</span> = -<span class="number">1</span>,</span></span><br><span class="line"><span class="params">        min_scene_len: <span class="built_in">int</span> = <span class="number">1</span>,</span></span><br><span class="line"><span class="params">        output_dir_base: Path = Path(<span class="params"><span class="string">&quot;threshold_exploration_output&quot;</span></span>),</span></span><br><span class="line"><span class="params">        save_images_for_thresholds: <span class="type">List</span>[<span class="built_in">float</span>] = <span class="literal">None</span>  <span class="comment"># 指定哪些阈值需要保存图像</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对一批视频，在一系列阈值下运行 ContentDetector，并记录结果。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_paths:</span><br><span class="line">        logger.warning(<span class="string">&quot;没有提供视频文件进行分析。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    sampled_videos = get_sampled_videos(video_paths, sample_ratio, num_sample_videos)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sampled_videos:</span><br><span class="line">        logger.warning(<span class="string">&quot;抽样后没有视频可供分析。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;将对以下 <span class="subst">&#123;<span class="built_in">len</span>(sampled_videos)&#125;</span> 个抽样视频进行分析:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> vid_path <span class="keyword">in</span> sampled_videos:</span><br><span class="line">        logger.info(<span class="string">f&quot;  - <span class="subst">&#123;vid_path.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start_thresh, end_thresh, step_thresh = threshold_range</span><br><span class="line">    thresholds_to_test = np.arange(start_thresh, end_thresh + step_thresh / <span class="number">2</span>, step_thresh)  <span class="comment"># +step/2 确保包含 end_thresh</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;将测试以下阈值: <span class="subst">&#123;thresholds_to_test&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建主输出目录</span></span><br><span class="line">    output_dir_base.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    images_base_dir = output_dir_base / <span class="string">&quot;saved_scene_images&quot;</span></span><br><span class="line">    <span class="keyword">if</span> save_images_for_thresholds:</span><br><span class="line">        images_base_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    results = []  <span class="comment"># 存储 (video_name, threshold, num_scenes)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> video_path <span class="keyword">in</span> sampled_videos:</span><br><span class="line">        logger.info(<span class="string">f&quot;--- 开始处理视频: <span class="subst">&#123;video_path.name&#125;</span> ---&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> threshold <span class="keyword">in</span> thresholds_to_test:</span><br><span class="line">            logger.info(<span class="string">f&quot;  测试阈值: <span class="subst">&#123;threshold:<span class="number">.2</span>f&#125;</span> for <span class="subst">&#123;video_path.name&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            save_images_this_run = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> save_images_for_thresholds <span class="keyword">and</span> <span class="built_in">any</span>(</span><br><span class="line">                    <span class="built_in">abs</span>(threshold - t_save) &lt; <span class="number">1e-5</span> <span class="keyword">for</span> t_save <span class="keyword">in</span> save_images_for_thresholds):</span><br><span class="line">                save_images_this_run = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            num_scenes = run_detection_for_threshold(</span><br><span class="line">                video_path,</span><br><span class="line">                threshold,</span><br><span class="line">                min_len=min_scene_len,</span><br><span class="line">                save_images_output_dir=images_base_dir <span class="keyword">if</span> save_images_this_run <span class="keyword">else</span> <span class="literal">None</span>,</span><br><span class="line">                save_images_for_this_run=save_images_this_run</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> num_scenes != -<span class="number">1</span>:  <span class="comment"># 如果没有发生错误</span></span><br><span class="line">                results.append(&#123;</span><br><span class="line">                    <span class="string">&quot;video_name&quot;</span>: video_path.name,</span><br><span class="line">                    <span class="string">&quot;threshold&quot;</span>: threshold,</span><br><span class="line">                    <span class="string">&quot;num_scenes&quot;</span>: num_scenes</span><br><span class="line">                &#125;)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(<span class="string">f&quot;跳过记录视频 <span class="subst">&#123;video_path.name&#125;</span> 在阈值 <span class="subst">&#123;threshold:<span class="number">.2</span>f&#125;</span> 的结果，因为检测出错。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> results:</span><br><span class="line">        logger.warning(<span class="string">&quot;没有收集到任何有效的检测结果。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    results_df = pd.DataFrame(results) <span class="keyword">if</span> MATPLOTLIB_AVAILABLE <span class="keyword">and</span> pd <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存原始数据到 CSV</span></span><br><span class="line">    csv_output_path = output_dir_base / <span class="string">&quot;threshold_scan_results.csv&quot;</span></span><br><span class="line">    <span class="keyword">if</span> results_df <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            results_df.to_csv(csv_output_path, index=<span class="literal">False</span>)</span><br><span class="line">            logger.info(<span class="string">f&quot;详细扫描结果已保存到: <span class="subst">&#123;csv_output_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;无法保存扫描结果到 CSV: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># 如果 pandas 不可用，尝试手动保存</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(csv_output_path, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                writer = csv.writer(f)</span><br><span class="line">                writer.writerow([<span class="string">&#x27;video_name&#x27;</span>, <span class="string">&#x27;threshold&#x27;</span>, <span class="string">&#x27;num_scenes&#x27;</span>])</span><br><span class="line">                <span class="keyword">for</span> res_dict <span class="keyword">in</span> results:</span><br><span class="line">                    writer.writerow([res_dict[<span class="string">&#x27;video_name&#x27;</span>], res_dict[<span class="string">&#x27;threshold&#x27;</span>], res_dict[<span class="string">&#x27;num_scenes&#x27;</span>]])</span><br><span class="line">            logger.info(<span class="string">f&quot;详细扫描结果已保存到: <span class="subst">&#123;csv_output_path&#125;</span> (手动保存)&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;无法手动保存扫描结果到 CSV: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 可视化</span></span><br><span class="line">    <span class="keyword">if</span> MATPLOTLIB_AVAILABLE <span class="keyword">and</span> results_df <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 图1: 每个视频的场景数 vs 阈值</span></span><br><span class="line">            plt.figure(figsize=(<span class="number">12</span>, <span class="number">7</span>))</span><br><span class="line">            <span class="keyword">for</span> video_name, group <span class="keyword">in</span> results_df.groupby(<span class="string">&quot;video_name&quot;</span>):</span><br><span class="line">                plt.plot(group[<span class="string">&quot;threshold&quot;</span>], group[<span class="string">&quot;num_scenes&quot;</span>], marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, label=video_name)</span><br><span class="line">            plt.xlabel(<span class="string">&quot;ContentDetector Threshold&quot;</span>)</span><br><span class="line">            plt.ylabel(<span class="string">&quot;Number of Detected Scenes&quot;</span>)</span><br><span class="line">            plt.title(<span class="string">&quot;Number of Scenes vs. Threshold (Per Video)&quot;</span>)</span><br><span class="line">            plt.legend(bbox_to_anchor=(<span class="number">1.05</span>, <span class="number">1</span>), loc=<span class="string">&#x27;upper left&#x27;</span>, borderaxespad=<span class="number">0.</span>)</span><br><span class="line">            plt.grid(<span class="literal">True</span>)</span><br><span class="line">            plt.tight_layout(rect=[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.85</span>, <span class="number">1</span>])  <span class="comment"># 给 legend 留空间</span></span><br><span class="line">            plot_path1 = output_dir_base / <span class="string">&quot;scenes_vs_threshold_per_video.png&quot;</span></span><br><span class="line">            plt.savefig(plot_path1)</span><br><span class="line">            logger.info(<span class="string">f&quot;每个视频的场景数-阈值图已保存到: <span class="subst">&#123;plot_path1&#125;</span>&quot;</span>)</span><br><span class="line">            plt.close()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 图2: 平均场景数 vs 阈值</span></span><br><span class="line">            avg_scenes_df = results_df.groupby(<span class="string">&quot;threshold&quot;</span>)[<span class="string">&quot;num_scenes&quot;</span>].mean().reset_index()</span><br><span class="line">            plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">            plt.plot(avg_scenes_df[<span class="string">&quot;threshold&quot;</span>], avg_scenes_df[<span class="string">&quot;num_scenes&quot;</span>], marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            plt.xlabel(<span class="string">&quot;ContentDetector Threshold&quot;</span>)</span><br><span class="line">            plt.ylabel(<span class="string">&quot;Average Number of Detected Scenes&quot;</span>)</span><br><span class="line">            plt.title(<span class="string">&quot;Average Number of Scenes vs. Threshold (Across Sampled Videos)&quot;</span>)</span><br><span class="line">            plt.grid(<span class="literal">True</span>)</span><br><span class="line">            plot_path2 = output_dir_base / <span class="string">&quot;avg_scenes_vs_threshold.png&quot;</span></span><br><span class="line">            plt.savefig(plot_path2)</span><br><span class="line">            logger.info(<span class="string">f&quot;平均场景数-阈值图已保存到: <span class="subst">&#123;plot_path2&#125;</span>&quot;</span>)</span><br><span class="line">            plt.close()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;生成图表时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提出建议（基于启发式，用户仍需判断）</span></span><br><span class="line">    logger.info(<span class="string">&quot;--- 阈值选择建议 ---&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> results_df <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 启发式：寻找场景数开始急剧下降然后趋于平缓的“拐点”</span></span><br><span class="line">        <span class="comment"># 或者场景数在一个小范围内波动但相对稳定的区域</span></span><br><span class="line">        avg_scenes_series = results_df.groupby(<span class="string">&quot;threshold&quot;</span>)[<span class="string">&quot;num_scenes&quot;</span>].mean()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> avg_scenes_series.empty:</span><br><span class="line">            logger.info(<span class="string">&quot;请查看 &#x27;avg_scenes_vs_threshold.png&#x27; 图表。&quot;</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;理想的阈值通常位于以下区域：&quot;</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;  - 场景数量开始显著减少之前的点（如果你想捕捉更多细节）。&quot;</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;  - 场景数量趋于稳定，不再随阈值增加而大幅减少的点（如果你想更鲁棒，减少误报）。&quot;</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;  - 避免阈值过低导致场景数过多（可能是噪声或微小变化）。&quot;</span>)</span><br><span class="line">            logger.info(<span class="string">&quot;  - 避免阈值过高导致场景数过少（可能遗漏真实切换）。&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 尝试找到一个“拐点”的简单启发式</span></span><br><span class="line">            <span class="comment"># 计算二阶差分，寻找变化最大的地方，但这可能不稳定</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                diff1 = avg_scenes_series.diff().fillna(<span class="number">0</span>)</span><br><span class="line">                diff2 = diff1.diff().fillna(<span class="number">0</span>)</span><br><span class="line">                <span class="comment"># 寻找 diff2 绝对值最大的几个点，或者第一个显著的正值（表示下降趋势减缓）</span></span><br><span class="line">                <span class="comment"># 这是一个非常简化的方法，实际效果可能有限</span></span><br><span class="line">                potential_elbow_threshold = diff2.<span class="built_in">abs</span>().nlargest(<span class="number">3</span>).index.tolist()</span><br><span class="line">                <span class="keyword">if</span> potential_elbow_threshold:</span><br><span class="line">                    logger.info(</span><br><span class="line">                        <span class="string">f&quot;  根据简单的变化率分析，可以关注以下阈值附近的表现：<span class="subst">&#123;<span class="built_in">sorted</span>(potential_elbow_threshold)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span>  <span class="comment"># 启发式失败，不影响主要功能</span></span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">&quot;结合 &#x27;saved_scene_images&#x27; (如果生成了) 中的实际场景图片进行人工判断。&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&quot;未能计算平均场景数，无法提供基于图表的建议。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;请检查输出目录 &#x27;<span class="subst">&#123;output_dir_base&#125;</span>&#x27; 中的结果。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> results_df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&quot;为一批视频探索 ContentDetector 的最佳阈值。&quot;</span>,</span><br><span class="line">        formatter_class=argparse.ArgumentDefaultsHelpFormatter</span><br><span class="line">    )</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input_source&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;包含视频文件的目录路径，或单个视频文件路径。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-e&quot;</span>, <span class="string">&quot;--extensions&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;.mp4,.mkv,.mov,.avi&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;逗号分隔的视频文件扩展名 (例如: .mp4,.mov)。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-r&quot;</span>, <span class="string">&quot;--recursive&quot;</span>, action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;如果 input_source 是目录，则递归扫描子目录。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抽样参数</span></span><br><span class="line">    sample_group = parser.add_mutually_exclusive_group()</span><br><span class="line">    sample_group.add_argument(<span class="string">&quot;--sample_ratio&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=-<span class="number">1.0</span>,</span><br><span class="line">                              <span class="built_in">help</span>=<span class="string">&quot;要处理的视频占总数的比例 (0.0 到 1.0)。例如 0.1 表示 10%%。默认为-1.0 (处理所有)。&quot;</span>)</span><br><span class="line">    sample_group.add_argument(<span class="string">&quot;--num_sample_videos&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=-<span class="number">1</span>,</span><br><span class="line">                              <span class="built_in">help</span>=<span class="string">&quot;要随机抽取的视频数量。默认为-1 (处理所有或按比例)。如果指定，则优先于 sample_ratio。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ContentDetector 参数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--threshold_start&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">15.0</span>, <span class="built_in">help</span>=<span class="string">&quot;测试的 ContentDetector 阈值起始值。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--threshold_end&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">35.0</span>, <span class="built_in">help</span>=<span class="string">&quot;测试的 ContentDetector 阈值结束值。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--threshold_step&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">1.0</span>, <span class="built_in">help</span>=<span class="string">&quot;测试的 ContentDetector 阈值步长。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--min_len&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;传递给 ContentDetector 的 min_scene_len 参数 (帧数)。建议保持为1以分析原始切点。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出和可视化</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--output_dir&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&quot;threshold_exploration_output&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;保存结果 (CSV, 图表, 图片) 的主输出目录。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--save_images_for&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;逗号分隔的阈值列表，将为这些阈值下的检测结果保存场景图片。例如 &#x27;15.0,20.0,25.0&#x27;。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        parser.print_help(sys.stderr)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    input_path_obj = Path(args.input_source)</span><br><span class="line">    video_files_to_scan = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> input_path_obj.is_dir():</span><br><span class="line">        ext_list = [e.strip().lower() <span class="keyword">for</span> e <span class="keyword">in</span> args.extensions.split(<span class="string">&#x27;,&#x27;</span>) <span class="keyword">if</span> e.strip()]</span><br><span class="line">        video_files_to_scan = get_video_files(input_path_obj, ext_list, args.recursive)</span><br><span class="line">    <span class="keyword">elif</span> input_path_obj.is_file():</span><br><span class="line">        video_files_to_scan.append(input_path_obj)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;输入路径 &#x27;<span class="subst">&#123;args.input_source&#125;</span>&#x27; 不是有效的文件或目录。&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files_to_scan:</span><br><span class="line">        logger.info(<span class="string">&quot;在指定路径下没有找到符合条件的视频文件。&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    threshold_r = (args.threshold_start, args.threshold_end, args.threshold_step)</span><br><span class="line">    output_dir_base_path = Path(args.output_dir)</span><br><span class="line"></span><br><span class="line">    save_thresholds_for_images = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> args.save_images_for:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            save_thresholds_for_images = [<span class="built_in">float</span>(t.strip()) <span class="keyword">for</span> t <span class="keyword">in</span> args.save_images_for.split(<span class="string">&#x27;,&#x27;</span>)]</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            logger.error(<span class="string">&quot;`--save_images_for` 参数中的阈值列表格式错误。应为逗号分隔的数字。&quot;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    explore_thresholds(</span><br><span class="line">        video_files_to_scan,</span><br><span class="line">        threshold_r,</span><br><span class="line">        sample_ratio=args.sample_ratio,</span><br><span class="line">        num_sample_videos=args.num_sample_videos,</span><br><span class="line">        min_scene_len=args.min_len,</span><br><span class="line">        output_dir_base=output_dir_base_path,</span><br><span class="line">        save_images_for_thresholds=save_thresholds_for_images</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;阈值探索完成。&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="亮度参数选定方法参考代码">亮度参数选定方法参考代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_average_brightness</span>(<span class="params">frame_bgr</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算 BGR 帧的平均亮度。</span></span><br><span class="line"><span class="string">    一种常见的方法是先转换为灰度图，然后计算平均像素值。</span></span><br><span class="line"><span class="string">    另一种是直接计算 BGR 各通道的平均值，然后再取平均，或者使用加权平均（如亮度公式 Y = 0.299R + 0.587G + 0.114B）。</span></span><br><span class="line"><span class="string">    这里我们使用转换为灰度图的方法，因为它直接反映了人眼感知的亮度。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gray_frame = cv2.cvtColor(frame_bgr, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    average_brightness = np.mean(gray_frame)</span><br><span class="line">    <span class="keyword">return</span> average_brightness</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_video_brightness</span>(<span class="params">video_path: <span class="built_in">str</span>, output_csv_path: <span class="built_in">str</span> = <span class="literal">None</span>, frame_skip: <span class="built_in">int</span> = <span class="number">0</span>, max_frames: <span class="built_in">int</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    逐帧分析视频的平均亮度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        video_path (str): 视频文件路径。</span></span><br><span class="line"><span class="string">        output_csv_path (str, optional): CSV文件输出路径。如果提供，则将结果保存到此文件。</span></span><br><span class="line"><span class="string">        frame_skip (int, optional): 每隔多少帧分析一次（0 表示逐帧分析）。</span></span><br><span class="line"><span class="string">        max_frames (int, optional): 最多分析多少帧。如果为 None，则分析整个视频。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Path(video_path).exists():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: 视频文件未找到: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: 无法打开视频文件: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    total_frames_video = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;视频信息: <span class="subst">&#123;Path(video_path).name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  总帧数: <span class="subst">&#123;total_frames_video&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  FPS: <span class="subst">&#123;fps:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;帧号\t平均亮度&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    csv_data = []</span><br><span class="line">    frame_count = <span class="number">0</span></span><br><span class="line">    processed_frame_num = <span class="number">0</span>  <span class="comment"># 实际处理的帧的计数器，用于 max_frames</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 视频结束或读取错误</span></span><br><span class="line"></span><br><span class="line">        current_frame_num_video = <span class="built_in">int</span>(</span><br><span class="line">            cap.get(cv2.CAP_PROP_POS_FRAMES))  <span class="comment"># 获取当前帧在视频中的实际编号 (1-based for some backends, 0-based for others)</span></span><br><span class="line">        <span class="comment"># 或者直接用 frame_count 作为0-based的帧号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frame_count % (frame_skip + <span class="number">1</span>) == <span class="number">0</span>:  <span class="comment"># frame_skip=0 表示每帧都处理</span></span><br><span class="line">            avg_brightness = calculate_average_brightness(frame)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;frame_count&#125;</span>\t<span class="subst">&#123;avg_brightness:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> output_csv_path:</span><br><span class="line">                csv_data.append([frame_count, avg_brightness])</span><br><span class="line"></span><br><span class="line">            processed_frame_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> max_frames <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> processed_frame_num &gt;= max_frames:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;\n已达到最大分析帧数限制: <span class="subst">&#123;max_frames&#125;</span> 帧。&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        frame_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分析完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> output_csv_path <span class="keyword">and</span> csv_data:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            output_file = Path(output_csv_path)</span><br><span class="line">            output_file.parent.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)  <span class="comment"># 创建输出目录</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="keyword">import</span> csv</span><br><span class="line">                writer = csv.writer(f)</span><br><span class="line">                writer.writerow([<span class="string">&#x27;FrameNumber&#x27;</span>, <span class="string">&#x27;AverageBrightness&#x27;</span>])  <span class="comment"># 写入表头</span></span><br><span class="line">                writer.writerows(csv_data)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;亮度数据已保存到: <span class="subst">&#123;output_file&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;错误: 无法保存 CSV 文件到 <span class="subst">&#123;output_csv_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;分析视频每帧的平均亮度。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;video_path&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, <span class="built_in">help</span>=<span class="string">&quot;要分析的视频文件路径。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-o&quot;</span>, <span class="string">&quot;--output_csv&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;可选：将结果保存到的 CSV 文件路径。例如：brightness_data.csv&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-s&quot;</span>, <span class="string">&quot;--frame_skip&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">0</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;可选：每隔多少帧分析一次（0 表示逐帧分析，1 表示隔1帧分析1帧，即处理第0,2,4...帧）。默认为0。&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-m&quot;</span>, <span class="string">&quot;--max_frames&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;可选：最多分析的帧数。用于快速预览长视频。默认为分析整个视频。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">1</span>:  <span class="comment"># 如果没有参数，打印帮助信息并退出</span></span><br><span class="line">        parser.print_help(sys.stderr)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    analyze_video_brightness(args.video_path, args.output_csv, args.frame_skip, args.max_frames)</span><br></pre></td></tr></table></figure><h2 id="阈值选择方法">阈值选择方法</h2><blockquote><p>查看 avg_scenes_vs_threshold.png 图。通常，你会寻找一个点，在该点之后，进一步降低阈值会导致场景数量急剧增加（可能引入过多噪声或非期望的切点），或者在该点之前，提高阈值会导致场景数量急剧减少（可能遗漏真实切点）。一个“平稳”的区域或者一个明显的“拐点”可能是好的候选范围。<br>对于你在图表上选出的几个候选阈值</p></blockquote><ul><li>可视化阈值选择工具使用方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python threshold_explorer.py &quot;/Volumes/shared/czq/video/scene-detect/淡入淡出-result/无转场-result/无转场/无转场/无转场/无转场/无转场/无转场/无转场/无转场/无转场&quot; \</span><br><span class="line">   -e &quot;.mp4,.mkv&quot; \</span><br><span class="line">   -r \</span><br><span class="line">   --sample_ratio 0.2 \</span><br><span class="line">   --threshold_start 1.0 \</span><br><span class="line">   --threshold_end 30.0 \</span><br><span class="line">   --threshold_step 1.0 \</span><br><span class="line">   --min_len 1 \</span><br><span class="line">   --output_dir &quot;./content_detector_exploration&quot; \</span><br><span class="line">   --save_images_for &quot;8.0,12.0,15.0&quot;</span><br></pre></td></tr></table></figure><ul><li>亮度检测工具使用方法</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python analyze_brightness.py &#x27;/Volumes/shared/czq/video/scene-detect/淡入淡出-result/无转场-result/无转场/无转场/无转场/无转场/无转场/无转场/无转场/无转场/无转场/3 (15).mp4&#x27;</span><br></pre></td></tr></table></figure><h3 id="结果显示">结果显示</h3><blockquote><p>如图</p></blockquote><ul><li>平均阈值</li></ul><p><img src="/2025/05/15/scene-detect-method/avg_scenes_vs_threshold.png" class="lazyload placeholder" data-srcset="/2025/05/15/scene-detect-method/avg_scenes_vs_threshold.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>检测视频所有阈值</li></ul><p><img src="/2025/05/15/scene-detect-method/scenes_vs_threshold_per_video.png" class="lazyload placeholder" data-srcset="/2025/05/15/scene-detect-method/scenes_vs_threshold_per_video.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2025-05-14 19:17:47,588 - INFO - --- 阈值选择建议 ---</span><br><span class="line">2025-05-14 19:17:47,589 - INFO - 请查看 &#x27;avg_scenes_vs_threshold.png&#x27; 图表。</span><br><span class="line">2025-05-14 19:17:47,589 - INFO - 理想的阈值通常位于以下区域：</span><br><span class="line">2025-05-14 19:17:47,589 - INFO -   - 场景数量开始显著减少之前的点（如果你想捕捉更多细节）。</span><br><span class="line">2025-05-14 19:17:47,589 - INFO -   - 场景数量趋于稳定，不再随阈值增加而大幅减少的点（如果你想更鲁棒，减少误报）。</span><br><span class="line">2025-05-14 19:17:47,589 - INFO -   - 避免阈值过低导致场景数过多（可能是噪声或微小变化）。</span><br><span class="line">2025-05-14 19:17:47,589 - INFO -   - 避免阈值过高导致场景数过少（可能遗漏真实切换）。</span><br><span class="line">2025-05-14 19:17:47,590 - INFO -   根据简单的变化率分析，可以关注以下阈值附近的表现：[2.0, 3.0, 9.0]</span><br><span class="line">2025-05-14 19:17:47,590 - INFO - 结合 &#x27;saved_scene_images&#x27; (如果生成了) 中的实际场景图片进行人工判断。</span><br><span class="line">2025-05-14 19:17:47,590 - INFO - 请检查输出目录 &#x27;content_detector_exploration&#x27; 中的结果。</span><br><span class="line">2025-05-14 19:17:47,590 - INFO - 阈值探索完成。</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><ol><li><a href="https://www.scenedetect.com/docs/latest/cli.html#detect-threshold">https://www.scenedetect.com/docs/latest/cli.html#detect-threshold</a></li></ol></li><li><ol start="2"><li><a href="https://caozhaoqi.github.io/2025/04/03/video-secene-detect/">https://caozhaoqi.github.io/2025/04/03/video-secene-detect/</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PySceneDetect 中场景检测器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要包括：&lt;code&gt;ContentDetector&lt;/code&gt;, &lt;code&gt;ThresholdDetector&lt;/code&gt;, &lt;code&gt;AdaptiveDetector&lt;/cod</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于yolov8根据CVAT标注结果训练模型</title>
    <link href="https://caozhaoqi.github.io/2025/04/09/yolov8-train-model/"/>
    <id>https://caozhaoqi.github.io/2025/04/09/yolov8-train-model/</id>
    <published>2025-04-09T02:55:34.000Z</published>
    <updated>2025-11-25T15:05:10.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模型简介">模型简介</h2><blockquote><p>YOLO 是一种实时目标检测算法家族的名称。与传统的需要先进行区域提议（Region Proposal）再进行分类的两阶段检测器（如 Faster R-CNN）不同，YOLO 将目标检测视为一个回归问题，直接从整个图像中预测边界框的位置和类别概率，实现了端到端（end-to-end）的检测。</p></blockquote><ul><li><strong>核心思想:</strong><ol><li><strong>网格划分:</strong> 将输入图像划分为 S x S 的网格 (Grid Cells)。</li><li><strong>单元格负责制:</strong> 如果一个物体的中心落入某个网格单元，则该单元负责检测该物体。</li><li><strong>边界框预测:</strong> 每个网格单元预测 B 个边界框 (Bounding Boxes) 以及这些框的置信度 (Confidence Score，表示框内含有物体的概率及框的准确度)。每个边界框包含 5 个预测值：<code>x</code>, <code>y</code> (框中心相对单元格的坐标), <code>w</code>, <code>h</code> (框宽高相对整张图像的比例), 和 <code>confidence</code>。</li><li><strong>类别概率预测:</strong> 每个网格单元还预测 C 个条件类别概率 (Conditional Class Probabilities)，即在包含物体的前提下，该物体属于每个类别的概率。</li><li><strong>最终检测:</strong> 将每个边界框的置信度与对应单元格的类别概率相乘，得到每个框针对每个类别的得分。通过设置阈值过滤低分框，并使用非极大值抑制 (Non-Maximum Suppression, NMS) 消除冗余的重叠框，得到最终的检测结果。</li></ol></li></ul><h2 id="CVAT简介">CVAT简介</h2><blockquote><p>基于 Web 的、功能强大的计算机视觉数据标注工具。它支持对图像和视频进行多种类型的标注，是计算机视觉项目（尤其是监督学习）中数据准备阶段的重要工具</p></blockquote><ul><li><strong>主要功能:</strong><ul><li><strong>多种标注类型:</strong><ul><li><strong>边界框 (Bounding Boxes):</strong> 用于目标检测任务，框出物体的位置。</li><li><strong>多边形 (Polygons):</strong> 用于实例分割任务，精确勾勒物体的轮廓。</li><li><strong>关键点 (Points / Skeleton):</strong> 用于姿态估计、人脸关键点检测等任务。</li><li><strong>分割掩码 (Segmentation Masks):</strong> 用于语义分割任务，为图像中的每个像素分配类别。</li><li><strong>标签 (Tags):</strong> 用于图像分类任务，为整个图像分配类别标签。</li><li><strong>轨迹/立方体 (Tracks/Cuboids):</strong> 支持视频标注，可以跟踪物体或标注3D边界框。</li></ul></li><li><strong>图像和视频支持:</strong> 可以直接对单张图片或整个视频序列进行标注。视频标注支持插值（interpolation），可以减少手动标注的工作量。</li><li><strong>半自动和自动标注:</strong> 集成了多种 AI 模型（如目标检测、分割模型，包括 YOLO、SAM 等），可以预标注数据，然后由人工进行修正，提高效率。支持连接外部 AI 模型（如通过 Nuclio）。</li><li><strong>协作:</strong> 支持多用户协作，可以分配任务、进行审核等。</li><li><strong>数据管理:</strong> 提供项目 (Project) 和任务 (Task) 管理功能，方便组织数据。</li><li><strong>多种导出格式:</strong> 支持导出为多种常见的数据集格式，如 COCO JSON, Pascal VOC XML, YOLO, MOT, Segmentation Mask 等，方便与各种深度学习框架对接。</li><li><strong>可扩展性:</strong> 开源，可以通过插件或集成自定义工具进行扩展。</li><li><strong>部署:</strong> 可以通过 Docker 在本地、服务器或云上部署。</li></ul></li></ul><p><img src="/2025/04/09/yolov8-train-model/train_model.png" class="lazyload placeholder" data-srcset="/2025/04/09/yolov8-train-model/train_model.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="CVAT标注结果导出">CVAT标注结果导出</h2><blockquote><p>使用从 CVAT 导出的 YOLO 格式数据，并在 <strong>CPU</strong> 上训练一个新的 YOLOv8 模型（使用 Ultralytics 框架），以下详细步骤。</p></blockquote><p><strong>重要提示：</strong> 在 CPU 上训练目标检测模型（尤其是像 YOLOv8 这样较现代的模型）将会<strong>非常非常慢</strong>。根据你的数据集大小、模型大小和 CPU 性能，一个 epoch 可能需要数小时甚至更长时间。这通常只适用于非常小的数据集、快速原型验证或没有 GPU 可用的情况。请有心理准备。</p><p><strong>步骤 1：从 CVAT 导出 YOLO 格式数据</strong></p><ol><li><strong>登录 CVAT</strong> 并导航到你已完成标注的任务 (Task)。</li><li>点击任务卡片上的 <strong>“Actions”</strong> (或任务页面内的菜单按钮)。</li><li>选择 <strong>“Export task dataset”</strong>。</li><li>在弹出的窗口中：<ul><li><strong>选择格式:</strong> <strong>务必选择 <code>YOLO</code> 或 <code>YOLO ZIP</code></strong>。</li><li><strong>子集划分 (可选但推荐):</strong> 如果你在 CVAT 中已将数据分配到 <code>Train</code>, <code>Validation</code>, <code>Test</code> 子集，请确保勾选了相应的选项来导出这些子集。这会省去你手动划分的步骤。如果没划分，则导出整个数据集。</li><li><strong>保存图像:</strong> 确保勾选了 “Save images” 选项。</li></ul></li><li>点击 <strong>“OK”</strong> 或 <strong>“Export”</strong>。</li><li>等待导出任务完成，然后下载生成的 <strong>ZIP 文件</strong>。</li></ol><p><strong>步骤 2：准备数据集文件</strong></p><ol><li><strong>解压 ZIP 文件:</strong> 将下载的 ZIP 文件解压到你电脑上一个方便访问的位置，例如 <code>~/datasets/my_yolo_dataset</code>。</li><li><strong>检查文件结构:</strong> 解压后，检查里面的内容。一个典型的 YOLO 导出（特别是包含子集划分的）可能包含：<ul><li><code>data.yaml</code> (或 <code>obj.data</code> 和 <code>obj.names</code> 文件)：这是配置文件，非常重要。</li><li><code>train/</code> (或类似的名称)<ul><li><code>images/</code>: 包含训练集的图像文件 (<code>.jpg</code>, <code>.png</code> 等)。</li><li><code>labels/</code>: 包含训练集的标注文件 (<code>.txt</code>)，每个图像对应一个。</li></ul></li><li><code>valid/</code> (或 <code>val/</code>)<ul><li><code>images/</code>: 包含验证集的图像文件。</li><li><code>labels/</code>: 包含验证集的标注文件。</li></ul></li><li><code>test/</code> (可选)<ul><li><code>images/</code>: 包含测试集的图像文件。</li><li><code>labels/</code>: 包含测试集的标注文件。</li></ul></li><li><em>如果导出时没有划分:</em> 你可能只有一个 <code>images/</code> 和一个 <code>labels/</code> 文件夹，以及配置文件。</li></ul></li><li><strong>验证/修改 <code>data.yaml</code> (或创建它):</strong> 这是告诉 YOLOv8 框架如何找到你的数据的关键文件。<ul><li><strong>如果已有 <code>data.yaml</code>:</strong> 用文本编辑器打开它。它看起来类似这样：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">path:</span> <span class="string">../datasets/my_yolo_dataset</span> <span class="comment"># ！！可能需要修改：数据集根目录的相对或绝对路径</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">train/images</span>             <span class="comment"># ！！训练集图片路径 (相对于 path)</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">valid/images</span>               <span class="comment"># ！！验证集图片路径 (相对于 path)</span></span><br><span class="line"><span class="comment"># test: test/images             # 可选：测试集图片路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Classes</span></span><br><span class="line"><span class="attr">nc:</span> <span class="number">9</span>                           <span class="comment"># ！！类别数量，必须准确</span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&#x27;bus&#x27;</span>, <span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;clock&#x27;</span>, <span class="string">...</span>] <span class="comment"># ！！类别名称列表，顺序必须与 labels/*.txt 中的类别ID (0, 1, 2...) 完全对应！</span></span><br></pre></td></tr></table></figure><strong>你需要仔细检查并可能修改：</strong><ul><li><code>path</code>: 确保它正确指向你解压数据集的<strong>根目录</strong>。<strong>相对于你将要运行训练命令的位置</strong>。使用绝对路径通常更安全。例如：<code>/home/your_user/datasets/my_yolo_dataset</code>。</li><li><code>train</code>, <code>val</code>, <code>test</code>: 确保它们正确指向包含图像文件的文件夹（相对于 <code>path</code> 定义的路径）。</li><li><code>nc</code>: 确保类别数量正确无误。</li><li><code>names</code>: <strong>极其重要！</strong> 确保这个列表中的类别名称<strong>顺序</strong>与 CVAT 导出时使用的类别 ID（从 0 开始）以及 <code>labels/</code> 文件夹下 <code>.txt</code> 文件中使用的数字 ID 完全一致。CVAT 导出 YOLO 格式时通常会保证这一点，但务必检查。</li></ul></li><li><strong>如果只有 <code>obj.data</code> 和 <code>obj.names</code>:</strong> 你需要<strong>手动创建一个 <code>data.yaml</code> 文件</strong>。<ul><li>打开 <code>obj.names</code>，将里面的类别名称按顺序列入 <code>data.yaml</code> 的 <code>names</code> 字段。计算类别数量填入 <code>nc</code>。</li><li>打开 <code>obj.data</code>，它通常包含类别数量、训练集/验证集图像列表文件的路径等信息。你需要根据这些信息和你的实际文件结构来填写 <code>data.yaml</code> 中的 <code>path</code>, <code>train</code>, <code>val</code> 字段。你可能需要将 <code>obj.data</code> 中指向的图像列表文件（例如 <code>train.txt</code>, <code>valid.txt</code>）也放到你的数据集目录中，或者直接修改 <code>data.yaml</code> 指向包含图像的文件夹。创建 <code>data.yaml</code> 通常更符合现代 YOLOv8 的习惯。</li></ul></li></ul></li><li><strong>手动划分数据集 (如果导出时未划分):</strong><ul><li>如果你只有一个 <code>images/</code> 和 <code>labels/</code> 文件夹，你需要手动将其划分为训练集和验证集。</li><li>创建子目录：在数据集根目录下创建 <code>train/images</code>, <code>train/labels</code>, <code>valid/images</code>, <code>valid/labels</code>。</li><li>编写脚本或手动移动文件：<ul><li>确定划分比例（例如，80% 训练，20% 验证）。</li><li>遍历 <code>images/</code> 文件夹中的所有图像文件。</li><li>对于每个图像文件（例如 <code>image1.jpg</code>），找到其对应的标注文件（<code>labels/image1.txt</code>）。</li><li>根据随机抽样或固定规则，将这对文件（图像和标注）移动到 <code>train/</code> 或 <code>valid/</code> 下相应的 <code>images</code> 和 <code>labels</code> 文件夹中。</li><li>确保图像和它的 <code>.txt</code> 标注文件始终在同一集合（train 或 valid）中。</li></ul></li><li>更新 <code>data.yaml</code> 中的 <code>train</code> 和 <code>val</code> 路径指向你新创建的 <code>train/images</code> 和 <code>valid/images</code> 文件夹。</li></ul></li></ol><p><strong>步骤 3：设置 Python 和 Ultralytics 环境</strong></p><ol><li><strong>安装 Python:</strong> 确保你安装了较新版本的 Python（推荐 3.8 - 3.11）。</li><li><strong>创建虚拟环境 (强烈推荐):</strong> 这可以避免库版本冲突。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 venv (Python 内置)</span></span><br><span class="line">python -m venv yolo_cpu_env</span><br><span class="line"><span class="built_in">source</span> yolo_cpu_env/bin/activate  <span class="comment"># Linux/macOS</span></span><br><span class="line"><span class="comment"># yolo_cpu_env\Scripts\activate  # Windows</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 Conda</span></span><br><span class="line"><span class="comment"># conda create -n yolo_cpu_env python=3.9</span></span><br><span class="line"><span class="comment"># conda activate yolo_cpu_env</span></span><br></pre></td></tr></table></figure></li><li><strong>安装 Ultralytics YOLOv8:</strong> 在激活的虚拟环境中运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ultralytics</span><br></pre></td></tr></table></figure>这会自动安装 PyTorch 的 CPU 版本（因为它检测不到兼容的 GPU/CUDA）以及其他必要的依赖库。</li></ol><p><strong>步骤 4：配置训练参数</strong></p><ol><li><strong>选择预训练模型:</strong> 为了利用迁移学习并加快（相对而言）收敛速度，你需要从一个预训练模型开始。对于 CPU 训练，<strong>强烈建议从小模型开始</strong>：<ul><li><code>yolov8n.pt</code> (Nano): 最快，占用资源最少，但精度相对较低。<strong>CPU 训练的首选起点。</strong></li><li><code>yolov8s.pt</code> (Small): 稍大，稍慢，精度稍高。如果 <code>yolov8n</code> 效果不佳且你的 CPU 尚可承受，可以尝试。</li><li>更大的模型 (<code>m</code>, <code>l</code>, <code>x</code>) 在 CPU 上训练几乎不可行。</li><li>Ultralytics 会在你第一次使用模型时自动下载 <code>.pt</code> 文件。</li></ul></li><li><strong>确定训练参数:</strong><ul><li><strong><code>model</code>:</strong> 你选择的预训练模型，例如 <code>yolov8n.pt</code>。</li><li><strong><code>data</code>:</strong> 指向你准备好的 <code>data.yaml</code> 文件的路径。</li><li><strong><code>epochs</code>:</strong> 训练的总轮数。对于 CPU，可以先设置一个较小的值（例如 10-50）来测试流程和观察初步结果，后续再增加。完整训练可能需要 100-300 轮甚至更多，但这在 CPU 上会耗费极长时间。</li><li><strong><code>batch</code>:</strong> 批处理大小。<strong>CPU 训练的关键参数</strong>。由于 CPU 计算能力和内存带宽限制，你需要设置一个<strong>非常小</strong>的值，例如 <code>2</code>, <code>4</code>, <code>8</code>。可以从 4 或 8 开始尝试，如果内存不足 (OOM) 或 CPU 占用过高导致系统卡顿，则需要减小。</li><li><strong><code>imgsz</code>:</strong> 输入图像的尺寸。通常设置为 640。更大的尺寸会显著增加 CPU 计算负担和内存占用。CPU 训练建议保持 640 或更小。</li><li><strong><code>device</code>:</strong> <strong>必须设置为 <code>cpu</code></strong>。<code>device=cpu</code>。</li><li><strong><code>workers</code>:</strong> 数据加载时使用的 CPU 核心数。可以设置为你 CPU 核心数的一部分，例如 <code>2</code>, <code>4</code>。不一定越多越好，过高可能导致 CPU 争用。</li></ul></li></ol><p><strong>步骤 5：执行训练</strong></p><ol><li><p><strong>打开终端或命令行。</strong></p></li><li><p><strong>激活你的虚拟环境</strong> (如 <code>source yolo_cpu_env/bin/activate</code>)。</p></li><li><p><strong>导航到你的项目目录</strong> (通常是你存放 <code>data.yaml</code> 或打算运行脚本的地方，确保 <code>data.yaml</code> 中的路径相对于此位置是正确的)。</p></li><li><p><strong>运行训练命令:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo train model=yolov8n.pt data=/path/to/your/data.yaml epochs=50 batch=4 imgsz=640 device=cpu workers=4</span><br></pre></td></tr></table></figure><ul><li><strong>请将 <code>/path/to/your/data.yaml</code> 替换为你的 <code>data.yaml</code> 文件的实际路径。</strong></li><li><strong>根据需要调整 <code>epochs</code>, <code>batch</code>, <code>workers</code> 的值。</strong></li><li><strong>再次强调：请有耐心！</strong> 你会看到训练开始，并显示每个 epoch 的进度、损失值等，但这会非常慢。</li></ul></li><li><p><strong>或者使用 Python 脚本进行训练:</strong> 创建一个 Python 文件（例如 <code>train_cpu.py</code>）:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> torch <span class="comment"># 导入 torch 以便检查</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 检查 PyTorch 是否确实在使用 CPU</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;PyTorch device: <span class="subst">&#123;torch.cuda.is_available() <span class="keyword">and</span> torch.device(<span class="string">&#x27;cuda&#x27;</span>) <span class="keyword">or</span> torch.device(<span class="string">&#x27;cpu&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载一个预训练模型 (例如 yolov8n.pt)</span></span><br><span class="line">    <span class="comment"># 模型文件如果本地没有，首次运行时会自动下载</span></span><br><span class="line">    model = YOLO(<span class="string">&#x27;yolov8n.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始训练</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        results = model.train(</span><br><span class="line">            data=<span class="string">&#x27;/path/to/your/data.yaml&#x27;</span>,  <span class="comment"># ！！替换为你的 data.yaml 路径</span></span><br><span class="line">            epochs=<span class="number">50</span>,                      <span class="comment"># 训练轮数</span></span><br><span class="line">            batch=<span class="number">4</span>,                        <span class="comment"># 批大小 (根据CPU和内存调整)</span></span><br><span class="line">            imgsz=<span class="number">640</span>,                      <span class="comment"># 图像尺寸</span></span><br><span class="line">            device=<span class="string">&#x27;cpu&#x27;</span>,                   <span class="comment"># ！！指定使用 CPU</span></span><br><span class="line">            workers=<span class="number">4</span>,                      <span class="comment"># 数据加载进程数 (根据CPU核心数调整)</span></span><br><span class="line">            <span class="comment"># 其他可选参数:</span></span><br><span class="line">            <span class="comment"># project=&#x27;runs/train_cpu&#x27;,     # 自定义保存结果的项目名</span></span><br><span class="line">            <span class="comment"># name=&#x27;exp_cpu_run1&#x27;,          # 自定义本次运行的名称</span></span><br><span class="line">            <span class="comment"># patience=20,                  # 早停轮数 (如果验证集指标在20轮内没有提升则停止)</span></span><br><span class="line">            <span class="comment"># lr0=0.01,                     # 初始学习率 (通常用默认值)</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;训练完成！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;结果保存在: <span class="subst">&#123;results.save_dir&#125;</span>&quot;</span>) <span class="comment"># results 对象在 v8 中不直接包含 save_dir，需要从 model 或 trainer 获取，或者直接查找 runs/train 目录</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;训练过程中发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后运行脚本：<code>python train_cpu.py</code></p></li></ol><ul><li>GPU版本</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pip install ultralytics</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> torch <span class="comment"># Import torch to check CUDA availability first</span></span><br><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> os <span class="comment"># Import os for path joining if needed</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># --- Verify CUDA Availability ---</span></span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        device_to_use = <span class="number">0</span> <span class="comment"># Use the first available GPU (index 0)</span></span><br><span class="line">        <span class="comment"># device_to_use = &#x27;cuda&#x27; # Alternative way to specify default GPU</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;CUDA is available! Training on GPU device: <span class="subst">&#123;torch.cuda.get_device_name(device_to_use)&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：未检测到兼容的 NVIDIA GPU 或 CUDA 配置不正确。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请检查驱动、CUDA Toolkit、cuDNN 和 GPU 版本的 PyTorch 是否已正确安装。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;将尝试在 CPU 上运行，但这会非常慢...&quot;</span>)</span><br><span class="line">        device_to_use = <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Configuration ---</span></span><br><span class="line">    <span class="comment"># ！！确保 data.yaml 路径正确！！ (使用 os.path.join 或 pathlib 更佳)</span></span><br><span class="line">    data_yaml_path = <span class="string">r&#x27;C:\Users\DELL\Desktop\test_data\test_data\data.yaml&#x27;</span></span><br><span class="line">    model_to_load = <span class="string">&#x27;yolov8x.pt&#x27;</span> <span class="comment"># Using the extra-large model</span></span><br><span class="line">    num_epochs = <span class="number">50</span>            <span class="comment"># Number of training epochs</span></span><br><span class="line">    batch_size = <span class="number">16</span>            <span class="comment"># !! Batch size for GPU (Adjust based on VRAM: 8, 16, 32, etc.)</span></span><br><span class="line">    image_size = <span class="number">640</span>           <span class="comment"># Input image size</span></span><br><span class="line">    num_workers = <span class="number">4</span>            <span class="comment"># Data loading workers (Adjust based on CPU cores)</span></span><br><span class="line">    project_name = <span class="string">&#x27;runs/train_gpu&#x27;</span> <span class="comment"># Directory to save results</span></span><br><span class="line">    run_name = <span class="string">&#x27;exp_gpu_yolov8x&#x27;</span>    <span class="comment"># Specific name for this run</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Load Model ---</span></span><br><span class="line">    <span class="comment"># Model file will be downloaded automatically if not present locally</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Loading model: <span class="subst">&#123;model_to_load&#125;</span>&quot;</span>)</span><br><span class="line">    model = YOLO(model_to_load)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Start Training ---</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始训练...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Data YAML: <span class="subst">&#123;data_yaml_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Epochs: <span class="subst">&#123;num_epochs&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Batch Size: <span class="subst">&#123;batch_size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Image Size: <span class="subst">&#123;image_size&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Device: <span class="subst">&#123;device_to_use&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Workers: <span class="subst">&#123;num_workers&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        results = model.train(</span><br><span class="line">            data=data_yaml_path,</span><br><span class="line">            epochs=num_epochs,</span><br><span class="line">            batch=batch_size,</span><br><span class="line">            imgsz=image_size,</span><br><span class="line">            device=device_to_use,   <span class="comment"># !! Use the determined device (e.g., 0 or &#x27;cpu&#x27;)</span></span><br><span class="line">            workers=num_workers,</span><br><span class="line">            project=project_name,   <span class="comment"># Specify project directory</span></span><br><span class="line">            name=run_name,          <span class="comment"># Specify run name</span></span><br><span class="line">            <span class="comment"># Other potentially useful optional parameters for GPU:</span></span><br><span class="line">            <span class="comment"># cache=True,           # Cache images in RAM/disk for faster loading (if RAM/disk allows)</span></span><br><span class="line">            <span class="comment"># patience=20,          # Early stopping patience</span></span><br><span class="line">            <span class="comment"># lr0=0.01,             # Initial learning rate</span></span><br><span class="line">            <span class="comment"># optimizer=&#x27;AdamW&#x27;,    # Optimizer (e.g., &#x27;AdamW&#x27;, &#x27;SGD&#x27;)</span></span><br><span class="line">            <span class="comment"># amp=True,             # Use Automatic Mixed Precision (can speed up training, reduce memory, requires compatible GPU)</span></span><br><span class="line">        )</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;训练完成！&quot;</span>)</span><br><span class="line">        <span class="comment"># Note: The &#x27;results&#x27; object itself might not directly contain the save path in all versions/contexts.</span></span><br><span class="line">        <span class="comment"># The results are reliably saved in the project/name directory.</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;训练结果和模型权重保存在: <span class="subst">&#123;os.path.join(project_name, run_name)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> torch.cuda.OutOfMemoryError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;错误：GPU 显存不足 (Out of Memory)！&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;尝试减小批处理大小 (batch=<span class="subst">&#123;batch_size&#125;</span>)。例如，尝试 batch=8 或 batch=4。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;如果显存仍然不足，可以考虑减小图像尺寸 (imgsz) 或使用更小的模型 (如 yolov8l.pt, yolov8m.pt)。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：找不到文件或目录: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请仔细检查 data.yaml 文件中的路径配置是否正确，特别是 &#x27;path&#x27;, &#x27;train&#x27;, &#x27;val&#x27; 字段。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;确保 data.yaml 文件本身位于: <span class="subst">&#123;data_yaml_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;训练过程中发生意外错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">import</span> traceback</span><br><span class="line">        traceback.print_exc() <span class="comment"># Print detailed traceback for debugging</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/04/09/yolov8-train-model/train_model_cycle.png" class="lazyload placeholder" data-srcset="/2025/04/09/yolov8-train-model/train_model_cycle.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>步骤 6：监控训练和评估结果</strong></p><ol><li><strong>观察终端输出:</strong> 查看每个 epoch 的进度、损失函数值（box_loss, cls_loss, dfl_loss）是否在下降，以及在验证集上的指标（如 P, R, mAP50, mAP50-95）是否在提升。</li><li><strong>查找结果:</strong> 训练过程和结果默认会保存在 <code>runs/train/exp&lt;N&gt;</code> 目录下（例如 <code>runs/train/exp</code>, <code>runs/train/exp2</code> 等）。里面包含：<ul><li><code>weights/</code>: 保存的模型权重文件。<code>best.pt</code> 是基于验证集指标最佳的模型，<code>last.pt</code> 是最后一个 epoch 的模型。<strong><code>best.pt</code> 通常是你需要的模型。</strong></li><li>日志文件 (TensorBoard logs)。</li><li>配置文件副本。</li><li>验证结果图表和图片（例如 <code>confusion_matrix.png</code>, <code>results.png</code>, <code>val_batch0_pred.jpg</code> 等）。</li></ul></li><li><strong>验证模型:</strong> 训练完成后（或中途），你可以使用 <code>best.pt</code> 在验证集上进行评估：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yolo val model=runs/train/exp&lt;N&gt;/weights/best.pt data=/path/to/your/data.yaml device=cpu</span><br></pre></td></tr></table></figure></li></ol><p><strong>步骤 7：使用训练好的模型</strong></p><p>训练完成后，你可以使用 <code>best.pt</code> 文件进行推理（目标检测）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yolo predict model=runs/train/exp&lt;N&gt;/weights/best.pt <span class="built_in">source</span>=/path/to/image.jpg device=cpu</span><br><span class="line"><span class="comment"># 或者对视频进行推理 (CPU上会很慢)</span></span><br><span class="line"><span class="comment"># yolo predict model=runs/train/exp&lt;N&gt;/weights/best.pt source=/path/to/video.mp4 device=cpu</span></span><br></pre></td></tr></table></figure><p>或者在 Python 脚本中使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载你训练好的模型</span></span><br><span class="line">model = YOLO(<span class="string">&#x27;runs/train/exp&lt;N&gt;/weights/best.pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行预测</span></span><br><span class="line">results = model.predict(source=<span class="string">&#x27;/path/to/image.jpg&#x27;</span>, device=<span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理结果 (例如，绘制边界框)</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">    boxes = r.boxes  <span class="comment"># Boxes object for bounding box outputs</span></span><br><span class="line">    masks = r.masks  <span class="comment"># Masks object for segmentation masks outputs</span></span><br><span class="line">    keypoints = r.keypoints  <span class="comment"># Keypoints object for pose outputs</span></span><br><span class="line">    probs = r.probs  <span class="comment"># Probs object for classification outputs</span></span><br><span class="line">    <span class="comment"># r.show()  # display to screen</span></span><br><span class="line">    r.save(filename=<span class="string">&#x27;result.jpg&#x27;</span>) <span class="comment"># save to disk</span></span><br></pre></td></tr></table></figure><p><strong>CPU训练的局限性:</strong></p><ul><li><strong>速度极慢:</strong></li><li><strong>内存限制:</strong> 小心 RAM 耗尽，特别是使用较大的 <code>batch</code> 或 <code>imgsz</code> 时。</li><li><strong>可行性:</strong> 对于非常大的数据集或需要高精度（需要训练更长时间或更大模型）的任务，CPU 训练可能实际上不可行。考虑使用 Google Colab（提供免费 GPU）、Kaggle Kernels 或其他云 GPU 服务可能是更好的选择。</li></ul><h2 id="验证数据集获取">验证数据集获取</h2><blockquote><p>获取验证数据集（Validation Set）是训练过程中非常重要的一步，用于评估模型在未见过数据上的表现并调整超参数。当你的数据来自 CVAT 并导出了 YOLO 格式时，有以下几种主要方法来获取或指定验证数据集：</p></blockquote><p><strong>方法一：在 CVAT 中划分并导出 (推荐)</strong></p><p>这是最方便、最不容易出错的方法，推荐优先考虑。</p><ol><li><strong>在 CVAT 中分配子集 (Subset):</strong><ul><li>在你 CVAT 的任务 (Task) 中，你可以将标注好的数据帧或图片分配到不同的子集。默认情况下，所有数据都在 <code>Default</code> 或 <code>Train</code> 子集中。</li><li>进入你的任务，选择一些帧或图片（例如，随机选择总数据的 10-20%）。</li><li>点击 “Actions” -&gt; “Change subset”。</li><li>在弹出的对话框中，选择 <code>Validation</code> 作为目标子集，然后确认。</li><li>这样你就告诉 CVAT，这些选中的数据属于验证集。你也可以同样地分配 <code>Test</code> 子集（如果需要）。</li></ul></li><li><strong>导出时包含子集:</strong><ul><li>在你导出任务数据集时，选择 <code>YOLO</code> 或 <code>YOLO ZIP</code> 格式。</li><li><strong>关键:</strong> 在导出选项中，确保你选择了导出所有子集，或者该格式默认就会将不同的子集分开导出。例如，<code>YOLO ZIP</code> 格式通常会自动创建 <code>train/</code>, <code>valid/</code>, <code>test/</code> 这样的子目录结构。</li></ul></li><li><strong>检查导出的文件:</strong><ul><li>解压下载的 ZIP 文件。</li><li>检查里面是否已经包含了类似 <code>train/</code> 和 <code>valid/</code> (或 <code>val/</code>) 的文件夹，每个文件夹下又分别有 <code>images/</code> 和 <code>labels/</code> 子目录。</li><li>同时检查 <code>data.yaml</code> 文件，它应该已经自动配置好了 <code>train:</code> 和 <code>val:</code> 指向这些对应的文件夹（例如 <code>train: train/images</code>, <code>val: valid/images</code>）。</li><li>如果导出文件已经是这种结构，那么你<strong>不需要</strong>再做任何事情，直接使用这个 <code>data.yaml</code> 文件进行训练即可。</li></ul></li></ol><p><strong>方法二：手动划分已导出的数据集</strong></p><p>如果你从 CVAT 导出时没有划分小子集，或者导出的格式没有自动区分，那么你只有一个包含所有图像和标签的集合。你需要手动将其划分为训练集和验证集。</p><ol><li><strong>确定划分比例:</strong> 根据你的总数据量，决定一个合适的划分比例。常见的比例是 80% 训练 / 20% 验证，或者 70% / 30%。如果数据量很大，验证集比例可以适当降低。</li><li><strong>创建目录结构:</strong> 在你的数据集根目录下（例如 <code>/home/user/my_dataset</code>），创建如下结构：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_dataset/</span><br><span class="line">├── train/</span><br><span class="line">│   ├── images/</span><br><span class="line">│   └── labels/</span><br><span class="line">├── valid/</span><br><span class="line">│   ├── images/</span><br><span class="line">│   └── labels/</span><br><span class="line">└── data.yaml  # 你需要创建或修改的文件</span><br></pre></td></tr></table></figure>（可能还需要保留原始的 <code>images/</code> 和 <code>labels/</code> 文件夹，或者直接从那里移动文件）。</li><li><strong>编写脚本或手动移动文件 (推荐脚本):</strong><ul><li><strong>核心原则:</strong> 必须保证<strong>同一张图片</strong> (<code>.jpg</code>, <code>.png</code> 等) 和其<strong>对应的标注文件</strong> (<code>.txt</code>) <strong>始终被划分到同一个集合</strong> (要么都在 <code>train</code>，要么都在 <code>valid</code>)。文件名通常是一一对应的（除了扩展名）。</li><li><strong>脚本方法 (Python 示例):</strong></li></ul></li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> yaml  <span class="comment"># 需要安装 PyYAML: pip install pyyaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置 ---</span></span><br><span class="line"><span class="comment"># ！！修改这里为你解压后的 CVAT 导出数据集的根目录！！</span></span><br><span class="line"><span class="comment"># 使用 Path 对象处理路径</span></span><br><span class="line">dataset_root = Path(<span class="string">r&#x27;/Users/zg/Downloads/task_13&#x27;</span>).resolve() <span class="comment"># &lt;&lt;--- 修改这里，并确保是绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ！！指定你想要创建的新数据集根目录（如果想分开存放）！！</span></span><br><span class="line"><span class="comment"># 如果设为 None，则在原 dataset_root 下创建 train/valid 目录</span></span><br><span class="line"><span class="comment"># 使用 Path 对象处理路径</span></span><br><span class="line">output_root = dataset_root <span class="comment"># &lt;&lt;--- 可以修改为新的路径，例如 Path(&#x27;./yolov8_dataset&#x27;).resolve()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Path 对象定义源路径</span></span><br><span class="line">source_data_dir = dataset_root / <span class="string">&#x27;obj_train_data&#x27;</span> <span class="comment"># 包含图像和标签的源文件夹</span></span><br><span class="line">obj_names_file = dataset_root / <span class="string">&#x27;obj.names&#x27;</span>       <span class="comment"># 类别名称文件</span></span><br><span class="line">train_txt_file = dataset_root / <span class="string">&#x27;train.txt&#x27;</span>       <span class="comment"># 原始图像列表文件</span></span><br><span class="line"></span><br><span class="line">train_ratio = <span class="number">0.8</span>  <span class="comment"># 训练集比例 (例如 0.8 表示 80%)</span></span><br><span class="line">random_seed = <span class="number">42</span>   <span class="comment"># 设置随机种子以保证每次划分结果一致 (可选)</span></span><br><span class="line"><span class="comment"># ------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置随机种子</span></span><br><span class="line"><span class="keyword">if</span> random_seed:</span><br><span class="line">    random.seed(random_seed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 检查输入文件/目录是否存在 ---</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> dataset_root.is_dir():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：数据集根目录不存在: <span class="subst">&#123;dataset_root&#125;</span>&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> source_data_dir.is_dir():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：源数据目录不存在: <span class="subst">&#123;source_data_dir&#125;</span>&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> obj_names_file.is_file():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;错误：类别文件不存在: <span class="subst">&#123;obj_names_file&#125;</span>&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">image_paths_from_txt = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> train_txt_file.is_file():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;警告：原始 train.txt 文件不存在: <span class="subst">&#123;train_txt_file&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;将尝试直接扫描源数据目录中的图像文件...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># --- 从 train.txt 读取图像路径 ---</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;正在从 <span class="subst">&#123;train_txt_file&#125;</span> 读取图像路径...&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(train_txt_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 读取原始路径行</span></span><br><span class="line">            raw_paths = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">if</span> line.strip()]</span><br><span class="line"></span><br><span class="line">        image_paths_from_txt = []</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在验证 train.txt 中的图像路径...&quot;</span>)</span><br><span class="line">        processed_raw_paths_count = <span class="number">0</span> <span class="comment"># 计数器</span></span><br><span class="line">        <span class="keyword">for</span> raw_path <span class="keyword">in</span> raw_paths:</span><br><span class="line">            processed_raw_paths_count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># --- 修复逻辑开始 ---</span></span><br><span class="line">            <span class="comment"># 1. 提取文件名 (例如 &#x27;frame_000000.png&#x27;)</span></span><br><span class="line">            filename = Path(raw_path).name</span><br><span class="line">            <span class="comment"># 2. 构建预期应该存在的路径 (在已知的 source_data_dir 下)</span></span><br><span class="line">            <span class="comment">#    使用 resolve() 确保是绝对路径</span></span><br><span class="line">            expected_path = (source_data_dir / filename).resolve()</span><br><span class="line">            <span class="comment"># --- 修复逻辑结束 ---</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3. 验证这个构建出的预期路径是否存在</span></span><br><span class="line">            <span class="keyword">if</span> expected_path.is_file():</span><br><span class="line">                image_paths_from_txt.append(expected_path) <span class="comment"># 添加 *正确且存在的* 路径</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 打印更具体的警告，显示原始行和尝试查找的位置</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;警告：在 <span class="subst">&#123;source_data_dir&#125;</span> 中找不到 train.txt 行 &#x27;<span class="subst">&#123;raw_path&#125;</span>&#x27; 对应的文件 &#x27;<span class="subst">&#123;filename&#125;</span>&#x27; (预期路径: <span class="subst">&#123;expected_path&#125;</span>)，将跳过。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;从 <span class="subst">&#123;train_txt_file&#125;</span> 原始读取 <span class="subst">&#123;<span class="built_in">len</span>(raw_paths)&#125;</span> 行。&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> image_paths_from_txt:</span><br><span class="line">             <span class="comment"># 如果修正后仍然没有有效路径，则触发后备扫描</span></span><br><span class="line">             <span class="keyword">raise</span> ValueError(<span class="string">&quot;train.txt 文件中没有找到任何有效且存在的图像文件。&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;验证后，有效图像路径数量: <span class="subst">&#123;<span class="built_in">len</span>(image_paths_from_txt)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;处理 train.txt 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;将尝试直接扫描源数据目录中的图像文件...&quot;</span>)</span><br><span class="line">        image_paths_from_txt = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 如果无法从 train.txt 读取或验证失败，则扫描目录 ---</span></span><br><span class="line"><span class="keyword">if</span> image_paths_from_txt <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;正在扫描目录 <span class="subst">&#123;source_data_dir&#125;</span> 中的图像文件...&quot;</span>)</span><br><span class="line">    <span class="comment"># 直接使用 source_data_dir (已经是 Path 对象)</span></span><br><span class="line">    image_paths_from_dir = <span class="built_in">list</span>(source_data_dir.glob(<span class="string">&#x27;*.jpg&#x27;</span>)) + \</span><br><span class="line">                           <span class="built_in">list</span>(source_data_dir.glob(<span class="string">&#x27;*.png&#x27;</span>)) + \</span><br><span class="line">                           <span class="built_in">list</span>(source_data_dir.glob(<span class="string">&#x27;*.jpeg&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> image_paths_from_dir:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：在 <span class="subst">&#123;source_data_dir&#125;</span> 中未找到任何图像文件。&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="comment"># 确保路径是绝对路径</span></span><br><span class="line">    image_paths = [p.resolve() <span class="keyword">for</span> p <span class="keyword">in</span> image_paths_from_dir]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;在目录中找到 <span class="subst">&#123;<span class="built_in">len</span>(image_paths)&#125;</span> 个图像文件。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果从 train.txt 成功读取并验证了路径，则使用这个列表</span></span><br><span class="line">    image_paths = image_paths_from_txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在继续之前，最终检查 image_paths 是否为空</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> image_paths:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误：未能收集到任何有效的图像路径来继续处理。&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 读取类别名称 ---</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(obj_names_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        class_names = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">if</span> line.strip()]</span><br><span class="line">    num_classes = <span class="built_in">len</span>(class_names)</span><br><span class="line">    <span class="keyword">if</span> num_classes == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误：类别文件 <span class="subst">&#123;obj_names_file&#125;</span> 为空。&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取到 <span class="subst">&#123;num_classes&#125;</span> 个类别: <span class="subst">&#123;class_names&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;读取类别文件 <span class="subst">&#123;obj_names_file&#125;</span> 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 创建输出目录 ---</span></span><br><span class="line"><span class="comment"># 确保 output_root 是 Path 对象</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(output_root, Path):</span><br><span class="line">    output_root = Path(output_root).resolve()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Path 对象定义目标目录</span></span><br><span class="line">train_img_dir = output_root / <span class="string">&#x27;train&#x27;</span> / <span class="string">&#x27;images&#x27;</span></span><br><span class="line">train_lbl_dir = output_root / <span class="string">&#x27;train&#x27;</span> / <span class="string">&#x27;labels&#x27;</span></span><br><span class="line">valid_img_dir = output_root / <span class="string">&#x27;valid&#x27;</span> / <span class="string">&#x27;images&#x27;</span></span><br><span class="line">valid_lbl_dir = output_root / <span class="string">&#x27;valid&#x27;</span> / <span class="string">&#x27;labels&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># exist_ok=True 避免目录已存在时报错</span></span><br><span class="line">train_img_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">train_lbl_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">valid_img_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">valid_lbl_dir.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 划分数据集 ---</span></span><br><span class="line"><span class="comment"># 打乱图像路径列表 (Path 对象列表)</span></span><br><span class="line">random.shuffle(image_paths)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算训练集和验证集的分割点</span></span><br><span class="line">split_index = <span class="built_in">int</span>(<span class="built_in">len</span>(image_paths) * train_ratio)</span><br><span class="line">train_image_paths = image_paths[:split_index]</span><br><span class="line">valid_image_paths = image_paths[split_index:]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;总有效图像数: <span class="subst">&#123;<span class="built_in">len</span>(image_paths)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;划分后训练集图像数: <span class="subst">&#123;<span class="built_in">len</span>(train_image_paths)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;划分后验证集图像数: <span class="subst">&#123;<span class="built_in">len</span>(valid_image_paths)&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 复制或移动文件函数 ---</span></span><br><span class="line"><span class="comment"># copy_mode=True 复制文件, copy_mode=False 移动文件</span></span><br><span class="line">copy_mode = <span class="literal">True</span> <span class="comment"># 建议使用复制以保留原始数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_files</span>(<span class="params">source_img_paths, target_img_dir, target_lbl_dir, copy=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将源图像和对应的标签文件复制或移动到目标目录&quot;&quot;&quot;</span></span><br><span class="line">    processed_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> img_path <span class="keyword">in</span> source_img_paths: <span class="comment"># img_path 是 Path 对象</span></span><br><span class="line">        <span class="comment"># 构建对应的标签文件路径 (.txt)，标签文件在源目录 source_data_dir 下</span></span><br><span class="line">        <span class="comment"># 使用 img_path.stem 获取不带扩展名的文件名</span></span><br><span class="line">        lbl_path = source_data_dir / (img_path.stem + <span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图像和标签文件是否存在</span></span><br><span class="line">        <span class="comment"># 图像路径 img_path 已经验证过存在</span></span><br><span class="line">        <span class="keyword">if</span> lbl_path.is_file():</span><br><span class="line">            <span class="comment"># 目标路径</span></span><br><span class="line">            target_img_path = target_img_dir / img_path.name</span><br><span class="line">            target_lbl_path = target_lbl_dir / lbl_path.name</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> copy:</span><br><span class="line">                    shutil.copy2(<span class="built_in">str</span>(img_path), <span class="built_in">str</span>(target_img_path)) <span class="comment"># copy2 接收字符串路径</span></span><br><span class="line">                    shutil.copy2(<span class="built_in">str</span>(lbl_path), <span class="built_in">str</span>(target_lbl_path))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    shutil.move(<span class="built_in">str</span>(img_path), <span class="built_in">str</span>(target_img_path)) <span class="comment"># move 接收字符串路径</span></span><br><span class="line">                    shutil.move(<span class="built_in">str</span>(lbl_path), <span class="built_in">str</span>(target_lbl_path))</span><br><span class="line">                processed_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;处理文件 <span class="subst">&#123;img_path.name&#125;</span> 时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 图像文件应该存在，因为我们是从验证过的列表处理的</span></span><br><span class="line">            <span class="comment"># if not img_path.is_file():</span></span><br><span class="line">            <span class="comment">#      print(f&quot;警告：找不到图像文件 &#123;img_path&#125;，跳过。&quot;)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;警告：找不到对应的标签文件 <span class="subst">&#123;lbl_path&#125;</span>，跳过图像 <span class="subst">&#123;img_path.name&#125;</span>。&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> processed_count</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 执行文件处理 ---</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在<span class="subst">&#123;<span class="string">&#x27;复制&#x27;</span> <span class="keyword">if</span> copy_mode <span class="keyword">else</span> <span class="string">&#x27;移动&#x27;</span>&#125;</span>训练集文件...&quot;</span>)</span><br><span class="line">train_processed = process_files(train_image_paths, train_img_dir, train_lbl_dir, copy=copy_mode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成功处理 <span class="subst">&#123;train_processed&#125;</span> 个训练集文件对。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正在<span class="subst">&#123;<span class="string">&#x27;复制&#x27;</span> <span class="keyword">if</span> copy_mode <span class="keyword">else</span> <span class="string">&#x27;移动&#x27;</span>&#125;</span>验证集文件...&quot;</span>)</span><br><span class="line">valid_processed = process_files(valid_image_paths, valid_img_dir, valid_lbl_dir, copy=copy_mode)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;成功处理 <span class="subst">&#123;valid_processed&#125;</span> 个验证集文件对。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 生成 data.yaml 文件 ---</span></span><br><span class="line">yaml_path = output_root / <span class="string">&#x27;data.yaml&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用相对于 output_root 的路径</span></span><br><span class="line">yaml_data = &#123;</span><br><span class="line">    <span class="comment"># 使用 resolve() 获取绝对路径字符串</span></span><br><span class="line">    <span class="string">&#x27;path&#x27;</span>: <span class="built_in">str</span>(output_root.resolve()),</span><br><span class="line">    <span class="comment"># 相对路径指向新创建的目录</span></span><br><span class="line">    <span class="string">&#x27;train&#x27;</span>: <span class="string">&#x27;train/images&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;val&#x27;</span>: <span class="string">&#x27;valid/images&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;test&#x27;: &#x27;test/images&#x27;, # 如果有测试集</span></span><br><span class="line">    <span class="string">&#x27;nc&#x27;</span>: num_classes,</span><br><span class="line">    <span class="string">&#x27;names&#x27;</span>: class_names</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(yaml_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        yaml.dump(yaml_data, f, sort_keys=<span class="literal">False</span>, default_flow_style=<span class="literal">False</span>) <span class="comment"># default_flow_style=False 更好看</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;data.yaml 文件已生成: <span class="subst">&#123;yaml_path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;内容:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(yaml.dump(yaml_data, sort_keys=<span class="literal">False</span>, default_flow_style=<span class="literal">False</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;数据集划分完成！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;生成 data.yaml 文件时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><p>你需要根据你的实际情况修改 <code>dataset_root</code>, <code>source_images_dir</code>, <code>source_labels_dir</code> 和 <code>train_ratio</code>。</p></li><li><p>这个脚本会将文件<strong>移动</strong>到新目录。如果你想保留原始文件，可以将 <code>shutil.move</code> 改为 <code>shutil.copy</code>。</p></li><li><p><strong>手动方法 (仅适用于少量数据):</strong> 创建 <code>train</code> 和 <code>valid</code> 子目录，然后手动将图像和对应的 <code>.txt</code> 文件拖拽到相应的 <code>images</code> 和 <code>labels</code> 文件夹中，确保比例大致正确且配对无误。非常容易出错。</p></li></ul><ol start="4"><li><strong>修改/创建 <code>data.yaml</code> 文件:</strong><ul><li>在你手动创建了 <code>train/</code> 和 <code>valid/</code> 目录结构后，你需要像下面这样配置 <code>data.yaml</code>：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">path:</span> <span class="string">/home/user/my_dataset</span>   <span class="comment"># 数据集根目录</span></span><br><span class="line"><span class="attr">train:</span> <span class="string">train/images</span>          <span class="comment"># 指向训练图像文件夹</span></span><br><span class="line"><span class="attr">val:</span> <span class="string">valid/images</span>            <span class="comment"># 指向验证图像文件夹</span></span><br><span class="line"><span class="comment"># test: test/images          # 如果有测试集</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nc:</span> <span class="number">3</span>                        <span class="comment"># 你的类别数量</span></span><br><span class="line"><span class="attr">names:</span> [<span class="string">&#x27;car&#x27;</span>, <span class="string">&#x27;person&#x27;</span>, <span class="string">&#x27;truck&#x27;</span>] <span class="comment"># 你的类别名称列表</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>方法三：使用 <code>.txt</code> 文件列表 (如果你选择了方案A来创建<code>data.yaml</code>)</strong></p><p>如果你是根据 <code>obj.data</code> 文件中的 <code>train = .../train.txt</code> 和 <code>valid = .../valid.txt</code> 来配置 <code>data.yaml</code> 的，那么你需要确保：</p><ol><li><code>train.txt</code> 文件确实存在，并且里面列出了所有<strong>训练集</strong>图像的<strong>正确路径</strong>（绝对路径或相对于 <code>data.yaml</code> 中 <code>path</code> 的路径）。</li><li>你有一个类似的 <code>valid.txt</code> 文件，里面列出了所有<strong>验证集</strong>图像的<strong>正确路径</strong>。</li><li><code>data.yaml</code> 文件中的 <code>train:</code> 和 <code>val:</code> 字段正确指向了这两个 <code>.txt</code> 文件。</li></ol><p>如果你只有一个包含所有图像路径的 <code>.txt</code> 文件，你需要像方法二中划分文件一样，将这个 <code>.txt</code> 文件也<strong>划分成两个文件</strong>：<code>train.txt</code> 和 <code>valid.txt</code>，确保划分比例合适。</p><p><strong>总结:</strong></p><ul><li><strong>最佳方式:</strong> 在 CVAT 中就使用 “Subset” 功能区分好训练集和验证集，然后导出 <code>YOLO ZIP</code> 格式，通常 <code>data.yaml</code> 就配置好了。</li><li><strong>次佳方式:</strong> 如果导出的数据未划分，使用脚本（如上例）将其自动划分为 <code>train/</code> 和 <code>valid/</code> 目录结构，然后相应地配置 <code>data.yaml</code> 指向这些目录。</li><li><strong>如果依赖 <code>.txt</code> 列表:</strong> 确保你有分别列出训练图像和验证图像路径的 <code>train.txt</code> 和 <code>valid.txt</code> 文件，并在 <code>data.yaml</code> 中正确引用它们。</li></ul><p>无论哪种方法，最终目标都是要有一个明确区分的训练数据集和一个验证数据集，并且 <code>data.yaml</code> 文件能够准确地告诉 YOLOv8 框架去哪里找到它们。</p><h3 id="训练结果">训练结果</h3><p><img src="/2025/04/09/yolov8-train-model/gpu_train_model.png" class="lazyload placeholder" data-srcset="/2025/04/09/yolov8-train-model/gpu_train_model.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">python train_model.py </span><br><span class="line">PyTorch device: cpu</span><br><span class="line">Ultralytics 8.3.105 🚀 Python-3.12.3 torch-2.6.0+cu124 CPU (Intel Xeon E5-2690 v3 2.60GHz)</span><br><span class="line">engine/trainer: task=detect, mode=train, model=yolov8n.pt, data=/home/czq2/test_data/data.yaml, epochs=50, time=None, patience=100, batch=4, imgsz=640, save=True, save_period=-1, cache=False, device=cpu, workers=4, project=None, name=train2, exist_ok=False, pretrained=True, optimizer=auto, verbose=True, seed=0, deterministic=True, single_cls=False, rect=False, cos_lr=False, close_mosaic=10, resume=False, amp=True, fraction=1.0, profile=False, freeze=None, multi_scale=False, overlap_mask=True, mask_ratio=4, dropout=0.0, val=True, split=val, save_json=False, conf=None, iou=0.7, max_det=300, half=False, dnn=False, plots=True, source=None, vid_stride=1, stream_buffer=False, visualize=False, augment=False, agnostic_nms=False, classes=None, retina_masks=False, embed=None, show=False, save_frames=False, save_txt=False, save_conf=False, save_crop=False, show_labels=True, show_conf=True, show_boxes=True, line_width=None, format=torchscript, keras=False, optimize=False, int8=False, dynamic=False, simplify=True, opset=None, workspace=None, nms=False, lr0=0.01, lrf=0.01, momentum=0.937, weight_decay=0.0005, warmup_epochs=3.0, warmup_momentum=0.8, warmup_bias_lr=0.1, box=7.5, cls=0.5, dfl=1.5, pose=12.0, kobj=1.0, nbs=64, hsv_h=0.015, hsv_s=0.7, hsv_v=0.4, degrees=0.0, translate=0.1, scale=0.5, shear=0.0, perspective=0.0, flipud=0.0, fliplr=0.5, bgr=0.0, mosaic=1.0, mixup=0.0, copy_paste=0.0, copy_paste_mode=flip, auto_augment=randaugment, erasing=0.4, crop_fraction=1.0, cfg=None, tracker=botsort.yaml, save_dir=runs/detect/train2</span><br><span class="line">Downloading https://ultralytics.com/assets/Arial.Unicode.ttf to &#x27;/home/czq2/.config/Ultralytics/Arial.Unicode.ttf&#x27;...</span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">|████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 22.2M/22.2M [00:01&lt;00:00, 21.2MB/s]</span></span><br><span class="line">Overriding model.yaml nc=80 with nc=4</span><br><span class="line"></span><br><span class="line">                   from  n    params  module                                       arguments                     </span><br><span class="line">  0                  -1  1       464  ultralytics.nn.modules.conv.Conv             [3, 16, 3, 2]                 </span><br><span class="line">  1                  -1  1      4672  ultralytics.nn.modules.conv.Conv             [16, 32, 3, 2]                </span><br><span class="line">  2                  -1  1      7360  ultralytics.nn.modules.block.C2f             [32, 32, 1, True]             </span><br><span class="line">  3                  -1  1     18560  ultralytics.nn.modules.conv.Conv             [32, 64, 3, 2]                </span><br><span class="line">  4                  -1  2     49664  ultralytics.nn.modules.block.C2f             [64, 64, 2, True]             </span><br><span class="line">  5                  -1  1     73984  ultralytics.nn.modules.conv.Conv             [64, 128, 3, 2]               </span><br><span class="line">  6                  -1  2    197632  ultralytics.nn.modules.block.C2f             [128, 128, 2, True]           </span><br><span class="line">  7                  -1  1    295424  ultralytics.nn.modules.conv.Conv             [128, 256, 3, 2]              </span><br><span class="line">  8                  -1  1    460288  ultralytics.nn.modules.block.C2f             [256, 256, 1, True]           </span><br><span class="line">  9                  -1  1    164608  ultralytics.nn.modules.block.SPPF            [256, 256, 5]                 </span><br><span class="line"> 10                  -1  1         0  torch.nn.modules.upsampling.Upsample         [None, 2, &#x27;nearest&#x27;]          </span><br><span class="line"> 11             [-1, 6]  1         0  ultralytics.nn.modules.conv.Concat           [1]                           </span><br><span class="line"> 12                  -1  1    148224  ultralytics.nn.modules.block.C2f             [384, 128, 1]                 </span><br><span class="line"> 13                  -1  1         0  torch.nn.modules.upsampling.Upsample         [None, 2, &#x27;nearest&#x27;]          </span><br><span class="line"> 14             [-1, 4]  1         0  ultralytics.nn.modules.conv.Concat           [1]                           </span><br><span class="line"> 15                  -1  1     37248  ultralytics.nn.modules.block.C2f             [192, 64, 1]                  </span><br><span class="line"> 16                  -1  1     36992  ultralytics.nn.modules.conv.Conv             [64, 64, 3, 2]                </span><br><span class="line"> 17            [-1, 12]  1         0  ultralytics.nn.modules.conv.Concat           [1]                           </span><br><span class="line"> 18                  -1  1    123648  ultralytics.nn.modules.block.C2f             [192, 128, 1]                 </span><br><span class="line"> 19                  -1  1    147712  ultralytics.nn.modules.conv.Conv             [128, 128, 3, 2]              </span><br><span class="line"> 20             [-1, 9]  1         0  ultralytics.nn.modules.conv.Concat           [1]                           </span><br><span class="line"> 21                  -1  1    493056  ultralytics.nn.modules.block.C2f             [384, 256, 1]                 </span><br><span class="line"> 22        [15, 18, 21]  1    752092  ultralytics.nn.modules.head.Detect           [4, [64, 128, 256]]           </span><br><span class="line">Model summary: 129 layers, 3,011,628 parameters, 3,011,612 gradients, 8.2 GFLOPs</span><br><span class="line"></span><br><span class="line">Transferred 319/355 items from pretrained weights</span><br><span class="line">Freezing layer &#x27;model.22.dfl.conv.weight&#x27;</span><br><span class="line">train: Scanning /home/czq2/test_data/train/labels... 495 images, 201 backgrounds, 0 corrupt: 100%|██████████| 495/495 [00:14&lt;00:00, 34.44it/s]</span><br><span class="line">train: New cache created: /home/czq2/test_data/train/labels.cache</span><br><span class="line">val: Scanning /home/czq2/test_data/valid/labels... 124 images, 47 backgrounds, 0 corrupt: 100%|██████████| 124/124 [00:03&lt;00:00, 37.91it/s]</span><br><span class="line">val: New cache created: /home/czq2/test_data/valid/labels.cache</span><br><span class="line">Plotting labels to runs/detect/train2/labels.jpg... </span><br><span class="line">/home/czq2/yolo_cpu_env/lib/python3.12/site-packages/ultralytics/utils/plotting.py:587: UserWarning: Glyph 35270 (\N&#123;CJK UNIFIED IDEOGRAPH-89C6&#125;) missing from font(s) DejaVu Sans.</span><br><span class="line">  plt.savefig(fname, dpi=200)</span><br><span class="line">/home/czq2/yolo_cpu_env/lib/python3.12/site-packages/ultralytics/utils/plotting.py:587: UserWarning: Glyph 39057 (\N&#123;CJK UNIFIED IDEOGRAPH-9891&#125;) missing from font(s) DejaVu Sans.</span><br><span class="line">optimizer: &#x27;optimizer=auto&#x27; found, ignoring &#x27;lr0=0.01&#x27; and &#x27;momentum=0.937&#x27; and determining best &#x27;optimizer&#x27;, &#x27;lr0&#x27; and &#x27;momentum&#x27; automatically... </span><br><span class="line">optimizer: AdamW(lr=0.00125, momentum=0.9) with parameter groups 57 weight(decay=0.0), 64 weight(decay=0.0005), 63 bias(decay=0.0)</span><br><span class="line">Image sizes 640 train, 640 val</span><br><span class="line">Using 0 dataloader workers</span><br><span class="line">Logging results to runs/detect/train2</span><br><span class="line">Starting training for 50 epochs...</span><br><span class="line"></span><br><span class="line">      Epoch    GPU_mem   box_loss   cls_loss   dfl_loss  Instances       Size</span><br><span class="line">       1/50         0G     0.6873      4.307      1.265          5        640:   2%|▏         | 2/124 [00:02&lt;02:20,  1.15s/it]Downloading https://ultralytics.com/assets/Arial.ttf to &#x27;/home/czq2/.config/Ultralytics/Arial.ttf&#x27;...</span><br><span class="line"><span class="meta prompt_">100%</span><span class="language-bash">|██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 755k/755k [00:00&lt;00:00, 2.17MB/s]</span></span><br><span class="line">       1/50         0G      1.137      2.561      1.378          7        640: 100%|██████████| 124/124 [02:08&lt;00:00,  1.03s/it]                   | 512k/755k [00:00&lt;00:00, 1.86MB/s]</span><br><span class="line">                 Class     Images  Instances      Box(P          R      mAP50  mAP50-95): 100%|██████████| 16/16 [00:19&lt;00:00,  1.24s/it]</span><br><span class="line">                   all        124         77        0.7      0.948      0.802      0.538</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>参数定义</p></li><li><p>我们来详细解释一下 YOLOv8 训练过程中这一行输出的含义：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Epoch    GPU_mem   box_loss   cls_loss   dfl_loss  Instances       Size</span><br><span class="line">12/50         0G     0.8517     0.8027      1.157          4        640: 100%|██████████| 124/124 [02:08&lt;00:00,  1.04s/it]</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class     Images  Instances      Box(P          R      mAP50  mAP50-95): 100%|██████████| 16/16 [00:19&lt;00:00,  1.23s/it]</span><br><span class="line">  all        124         77          1      0.999      0.995      0.853</span><br></pre></td></tr></table></figure><p><strong>第一部分：训练进度和损失 (Training Progress and Loss)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Epoch    GPU_mem   box_loss   cls_loss   dfl_loss  Instances       Size</span><br><span class="line">12/50         0G     0.8517     0.8027      1.157          4        640: 100%|██████████| 124/124 [02:08&lt;00:00,  1.04s/it]</span><br></pre></td></tr></table></figure><ul><li><strong><code>Epoch</code></strong>: <code>12/50</code><ul><li>表示当前训练正在进行第 <strong>12</strong> 轮 (epoch)，总共计划训练 <strong>50</strong> 轮。一个 epoch 指的是模型完整地看过一遍所有的训练数据。</li></ul></li><li><strong><code>GPU_mem</code></strong>: <code>0G</code><ul><li>显示当前 <strong>GPU 显存 (VRAM) 的使用量</strong>。这里显示 <code>0G</code> <strong>非常奇怪</strong>，尤其是如果你指定了使用 GPU 进行训练。<ul><li><strong>可能的原因 1 (最可能):</strong> 训练实际上是在 <strong>CPU</strong> 上运行的，即使你可能指定了 <code>device=0</code> 或 <code>device='cuda'</code>。这通常发生在 PyTorch 无法正确检测或使用你的 GPU 时（驱动、CUDA、cuDNN 或 PyTorch 版本问题）。<strong>你需要回过头去验证你的 GPU 环境是否配置正确，以及 PyTorch 是否能真正使用 GPU (<code>torch.cuda.is_available()</code> 必须为 <code>True</code>)。</strong></li><li><strong>可能的原因 2 (不太可能):</strong> 你的模型和批次大小非常小，以至于显存占用可以忽略不计（对于 YOLOv8 尤其是 <code>x</code> 模型和 <code>batch=4</code> 来说几乎不可能）。</li><li><strong>可能的原因 3 (极少):</strong> 监控显存的工具或接口暂时失效。</li></ul></li><li><strong>正常的 GPU 训练</strong> 应该会显示一个非零的显存使用值，例如 <code>5.8G</code>, <code>10.2G</code> 等，具体取决于模型大小、批大小和图像尺寸。</li></ul></li><li><strong><code>box_loss</code></strong>: <code>0.8517</code><ul><li><strong>边界框损失 (Bounding Box Loss)</strong>。这个值衡量的是模型预测的边界框位置/大小与真实边界框之间的差异。值越低越好。</li></ul></li><li><strong><code>cls_loss</code></strong>: <code>0.8027</code><ul><li><strong>分类损失 (Classification Loss)</strong>。这个值衡量的是模型预测的物体类别与真实类别之间的差异。值越低越好。</li></ul></li><li><strong><code>dfl_loss</code></strong>: <code>1.157</code><ul><li><strong>分布焦点损失 (Distribution Focal Loss)</strong>。这是 YOLOv8（尤其是 v8 及更新版本）引入的一种用于边界框回归的损失，它将边界框的连续坐标回归问题转化为离散的概率分布预测问题，有助于提高定位精度。值越低越好。</li></ul></li><li><strong><code>Instances</code></strong>: <code>4</code><ul><li>当前正在处理的这个批次 (batch) 中包含的<strong>目标实例 (objects) 的数量</strong>。这里是 4 个。注意这不是批大小（batch size，即图像数量）。</li></ul></li><li><strong><code>Size</code></strong>: <code>640</code><ul><li>训练时输入模型的<strong>图像尺寸</strong> (通常是 height 和 width 都设为这个值，即 640x640)。</li></ul></li><li><strong><code>100%|██████████| 124/124 [02:08&lt;00:00, 1.04s/it]</code></strong>:<ul><li>这是一个<strong>进度条</strong>，显示当前 epoch 内训练数据的处理进度。</li><li><code>100%</code>: 表示当前 epoch 的训练数据已全部处理完毕。</li><li><code>124/124</code>: 表示当前 epoch 共处理了 124 个批次 (batches)，现在已经完成了第 124 个批次。 (总批次数 = 总训练图像数 / batch_size)</li><li><code>[02:08&lt;00:00</code>]: 当前 epoch 已用时 2 分 8 秒，预计剩余时间 0 秒。</li><li><code>1.04s/it]</code>: 处理一个批次 (iteration) 平均需要 1.04 秒。这个速度<strong>对于 GPU 来说相当慢</strong>，进一步印证了可能是在 CPU 上运行。GPU 训练通常是 <code>ms/it</code> (毫秒每迭代)。</li></ul></li></ul><p><strong>第二部分：验证结果评估 (Validation Results Evaluation)</strong></p><p>这部分通常在每个 epoch 的训练结束后（或者根据设置的频率）运行，使用验证集 (Validation Set) 来评估当前模型的性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class     Images  Instances      Box(P          R      mAP50  mAP50-95): 100%|██████████| 16/16 [00:19&lt;00:00,  1.23s/it]</span><br><span class="line">  all        124         77          1      0.999      0.995      0.853</span><br></pre></td></tr></table></figure><ul><li><strong><code>Class</code></strong>: <code>all</code><ul><li>表示这一行显示的是<strong>所有类别</strong>的平均性能指标。如果你的数据集有多个类别，通常还会在这里或下面几行列出每个单独类别的指标。</li></ul></li><li><strong><code>Images</code></strong>: <code>124</code><ul><li>你的<strong>验证集</strong>中包含 <strong>124</strong> 张图像。</li></ul></li><li><strong><code>Instances</code></strong>: <code>77</code><ul><li>你的<strong>验证集</strong>中所有图像总共包含 <strong>77</strong> 个已标注的目标实例。</li></ul></li><li><strong><code>Box(P R mAP50 mAP50-95)</code></strong>: 这是目标检测任务最核心的评估指标：<ul><li><strong><code>P</code> (Precision / 精确率):</strong> <code>1</code><ul><li>指模型预测为正例（检测到物体）的样本中，<strong>真正是正例</strong>的比例。计算公式：<code>TP / (TP + FP)</code> (真阳性 / (真阳性 + 假阳性))。</li><li>值为 <code>1</code> 意味着所有模型检测到的物体都是正确的（没有误报）。这个值通常在 IoU (Intersection over Union) 阈值为 0.5 时计算，并且可能是针对某个最优置信度阈值得出的。</li></ul></li><li><strong><code>R</code> (Recall / 召回率):</strong> <code>0.999</code><ul><li>指所有<strong>真实的</strong>正例（所有实际存在的物体）中，被模型<strong>成功预测出来</strong>的比例。计算公式：<code>TP / (TP + FN)</code> (真阳性 / (真阳性 + 假阴性))。</li><li>值 <code>0.999</code> 意味着模型找回了验证集中几乎所有（99.9%）的真实物体（漏报非常少）。这个值通常也是在 IoU 阈值为 0.5 时计算，并且可能是针对某个最优置信度阈值得出的。</li></ul></li><li><strong><code>mAP50</code> (mean Average Precision @ IoU=0.5):</strong> <code>0.995</code><ul><li>IoU (交并比) 阈值设置为 0.5 时，计算所有类别的平均精度 (Average Precision, AP)，然后对所有类别求平均值 (mean AP)。AP 是综合了精确率和召回率的指标，它衡量的是 PR 曲线下的面积。</li><li><code>0.995</code> 是一个非常高的值，表示在 IoU=0.5 的标准下，模型性能非常好。</li></ul></li><li><strong><code>mAP50-95</code> (mean Average Precision @ IoU=0.5:0.95):</strong> <code>0.853</code><ul><li>这是更严格、也是 COCO 数据集竞赛等场景中更常用的标准。它计算了 IoU 阈值从 0.5 到 0.95、步长为 0.05 的一系列 IoU 值下的 mAP，然后对这些 mAP 求平均。</li><li>这个指标对检测框的定位精度要求更高。<code>0.853</code> (即 85.3%) 是一个相当不错的性能，表明模型不仅能检测到物体，而且定位也比较准确。</li></ul></li></ul></li><li><strong><code>100%|██████████| 16/16 [00:19&lt;00:00, 1.23s/it]</code></strong>:<ul><li>这是<strong>验证过程</strong>的进度条。</li><li><code>16/16</code>: 表示验证集被分成了 16 个批次进行处理，现在已经处理完了。 (验证批次数 = 总验证图像数 / 验证批大小，验证批大小可能与训练批大小不同)。</li><li><code>[00:19&lt;00:00</code>]: 整个验证过程用时 19 秒。</li><li><code>1.23s/it]</code>: 处理一个验证批次平均需要 1.23 秒。这个速度同样说明很可能是在 CPU 上运行。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模型简介&quot;&gt;模型简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;YOLO 是一种实时目标检测算法家族的名称。与传统的需要先进行区域提议（Region Proposal）再进行分类的两阶段检测器（如 Faster R-CNN）不同，YOLO 将目标检测视为一个回归问</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nuclio与CVAT使用yolov8目标检测模型实现半自动化标注</title>
    <link href="https://caozhaoqi.github.io/2025/04/07/nuclio-build-use/"/>
    <id>https://caozhaoqi.github.io/2025/04/07/nuclio-build-use/</id>
    <published>2025-04-07T07:19:21.000Z</published>
    <updated>2025-11-25T15:05:10.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nuclio Dashboard 是 Nuclio Serverless 平台的一个基于 Web 的图形用户界面（GUI），它允许用户方便地管理（创建、查看、编辑、删除、部署）Nuclio 函数、项目、事件源（Triggers）等资源。</p></blockquote><p><strong>核心概念：</strong></p><ol><li><p><strong>部署 (Deployment) vs 构建 (Building from Source):</strong></p><ul><li><strong>部署:</strong> 对于大多数用户来说，“构建” Nuclio Dashboard 意味着<strong>部署</strong>预先构建好的 Docker 镜像。这是最常见和推荐的方式。你不需要从源代码编译它。</li><li><strong>从源码构建:</strong> 这是指获取 Nuclio Dashboard 的源代码并自行编译生成可执行文件或 Docker 镜像。这通常只在开发 Nuclio 本身或需要特殊定制时才需要，对于普通用户不推荐。</li></ul></li><li><p><strong>运行环境:</strong> Nuclio（及其 Dashboard）可以在多种环境中运行，最常见的是：</p><ul><li><strong>Standalone Docker:</strong> 在单个 Docker 主机上运行。</li><li><strong>Kubernetes:</strong> 在 Kubernetes 集群中运行，这是生产环境中最常见的方式。</li></ul></li></ol><p><strong>部署</strong> Nuclio Dashboard 的方法以及如何<strong>使用</strong>它。</p><hr><h3 id="一、部署-Nuclio-Dashboard">一、部署 Nuclio Dashboard</h3><p>Nuclio Dashboard 通常与 Nuclio Controller 一起部署。Controller 是 Nuclio 的核心控制平面，而 Dashboard 是其 UI。</p><p><strong>方法一：在 Standalone Docker 环境中部署</strong></p><p>这是最简单的方法，适合本地测试和开发。通常，当你运行 Nuclio Controller 容器时，它已经包含了 Dashboard。</p><ol><li><p><strong>拉取并运行 Nuclio Controller 镜像:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8070:8070 -v /var/run/docker.sock:/var/run/docker.sock --name nuclio-dashboard quay.io/nuclio/dashboard:stable-amd64</span><br></pre></td></tr></table></figure><ul><li><code>-d</code>: 后台运行容器。</li><li><code>-p 8070:8070</code>: 将主机的 8070 端口映射到容器的 8070 端口（Nuclio Dashboard 默认监听此端口）。</li><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>: 允许 Nuclio Controller 与宿主机的 Docker守护进程通信，以便构建和运行函数容器。<strong>（注意安全风险）</strong></li><li><code>-v /tmp:/tmp</code>: 提供临时文件存储。</li><li><code>--name nuclio-controller</code>: 给容器命名。</li><li><code>nuclio/controller:stable</code>: 使用的镜像。</li><li><code>--platform-kind &quot;local&quot;</code> 或 <code>&quot;docker&quot;</code>: 指定平台类型为本地 Docker 环境。</li></ul></li><li><p><strong>访问 Dashboard:</strong><br>部署成功后，在浏览器中打开 <code>http://&lt;你的主机IP&gt;:8070</code> 或 <code>http://localhost:8070</code> 即可访问 Nuclio Dashboard。</p></li></ol><p><strong>方法二：在 Kubernetes 环境中部署</strong></p><p>这是在生产或集群环境中最常用的方法。推荐使用 Helm Chart 来部署 Nuclio。</p><ol><li><p><strong>添加 Nuclio Helm 仓库 (如果尚未添加):</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm repo add nuclio https://nuclio.github.io/nuclio/charts</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 Nuclio Chart:</strong><br>这将同时部署 Nuclio Controller（包含 Dashboard）和其他必要的组件（如 CRDs）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 namespace (推荐)</span></span><br><span class="line">kubectl create namespace nuclio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Helm 安装</span></span><br><span class="line">helm install nuclio nuclio/nuclio --namespace nuclio</span><br></pre></td></tr></table></figure><ul><li>你可以通过创建 <code>values.yaml</code> 文件或使用 <code>--set</code> 参数来自定义安装选项（例如，指定 Service 类型、资源限制等）。</li></ul></li><li><p><strong>访问 Dashboard:</strong><br>部署后，需要一种方式从集群外部访问 Dashboard Service。常用方法有：</p><ul><li><strong>Port Forwarding (用于临时访问/调试):</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到 Nuclio Dashboard Pod 的名称 (通常包含 &#x27;controller&#x27;)</span></span><br><span class="line">kubectl get pods -n nuclio</span><br><span class="line"><span class="comment"># 假设 pod 名称为 nuclio-controller-xxxxxxxxxx-yyyyy</span></span><br><span class="line">kubectl port-forward -n nuclio &lt;nuclio-controller-pod-name&gt; 8070:8070</span><br></pre></td></tr></table></figure>然后在浏览器中访问 <code>http://localhost:8070</code>。</li><li><strong>LoadBalancer Service:</strong> 如果你的 Kubernetes 集群支持 LoadBalancer 类型的 Service，并且你在 Helm 安装时配置了 Dashboard Service 为 LoadBalancer 类型，你可以获取其外部 IP 地址来访问。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc -n nuclio <span class="comment"># 查找 dashboard service 的 EXTERNAL-IP</span></span><br></pre></td></tr></table></figure>然后在浏览器中访问 <code>http://&lt;EXTERNAL-IP&gt;:8070</code>。</li><li><strong>NodePort Service:</strong> 如果配置为 NodePort，你可以通过 <code>http://&lt;任意节点IP&gt;:&lt;NodePort端口&gt;</code> 访问。</li><li><strong>Ingress:</strong> 配置 Ingress 资源，通过 Ingress Controller 提供的域名或路径来访问 Dashboard。这是生产环境中最推荐的方式。</li></ul></li></ol><p><img src="/2025/04/07/nuclio-build-use/nuclio_ui.png" class="lazyload placeholder" data-srcset="/2025/04/07/nuclio-build-use/nuclio_ui.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h3 id="二、使用-Nuclio-Dashboard">二、使用 Nuclio Dashboard</h3><p>当你成功访问 Nuclio Dashboard 后，你会看到一个用户友好的界面。以下是主要功能区域和常见操作：</p><ol><li><p><strong>概览 (Overview / Dashboard):</strong></p><ul><li>通常是进入后的首页，显示项目和函数的摘要信息，例如总数、运行状态等。</li></ul></li><li><p><strong>项目 (Projects):</strong></p><ul><li>Nuclio 使用项目来组织函数。一个项目可以包含多个函数。</li><li><strong>创建项目:</strong> 点击 “New Project” 或类似按钮，输入项目名称和可选的描述、标签。</li><li><strong>查看项目:</strong> 点击项目名称进入项目详情页，可以看到该项目下的所有函数。</li><li><strong>编辑/删除项目:</strong> 在项目列表或详情页通常有编辑和删除的操作按钮。</li></ul></li><li><p><strong>函数 (Functions):</strong></p><ul><li>这是 Nuclio 的核心。你可以在项目内部创建和管理函数。</li><li><strong>创建函数:</strong><ul><li>进入一个项目，点击 “New Function” 或 “Create Function”。</li><li><strong>模板选择:</strong> 你可以选择一个预定义的模板（例如，Go 的 HTTP 处理、Python 的事件处理等），或者从头开始。</li><li><strong>配置:</strong><ul><li><strong>Function Name:</strong> 函数的唯一名称。</li><li><strong>Description/Labels:</strong> 可选的描述和标签。</li><li><strong>Runtime:</strong> 选择函数的运行时语言（Go, Python, Node.js, Java, .NET Core, Shell, Binary）。</li><li><strong>Source Code:</strong><ul><li><strong>Inline Editor:</strong> 直接在 Web 编辑器中编写代码。</li><li><strong>Upload:</strong> 上传代码文件或压缩包 (zip, jar)。</li><li><strong>Git Repository:</strong> 从 Git 仓库拉取代码（需要配置）。</li><li><strong>Image:</strong> 使用一个已经包含函数代码和依赖的 Docker 镜像。</li></ul></li><li><strong>Handler:</strong> 指定函数入口点（例如，Python 文件名:函数名，<code>main:handler</code>）。</li><li><strong>Dependencies:</strong> 如果代码有外部依赖，需要在这里指定（例如，Python 的 <code>requirements.txt</code> 内容，Go 的 <code>go.mod</code> 等）。Nuclio 会在构建过程中安装它们。</li><li><strong>Triggers:</strong> 配置触发函数的方式。最常见的是 <code>http</code>（通过 HTTP 请求触发），但也支持 Kafka, Kinesis, RabbitMQ, Cron (定时任务) 等多种事件源。需要配置触发器的详细信息（如 HTTP 路径、方法，Kafka 主题等）。</li><li><strong>Environment Variables:</strong> 设置函数运行时可以访问的环境变量。</li><li><strong>Volumes:</strong> (Kubernetes 环境) 挂载存储卷到函数 Pod。</li><li><strong>Resources:</strong> 配置函数的资源请求和限制（CPU, Memory）。</li><li><strong>Scaling:</strong> 配置自动伸缩参数（最小/最大副本数，目标 CPU 使用率等）。</li><li><strong>Build Settings:</strong> 配置构建过程的参数，例如基础镜像、构建命令等。</li></ul></li></ul></li><li><strong>部署函数:</strong> 配置完成后，点击 “Deploy” 或 “Create”。Nuclio Controller 会开始构建函数镜像（如果需要）并将其实例化（在 Docker 中是启动容器，在 Kubernetes 中是创建 Deployment/Pod）。部署状态会显示在函数列表中（例如：Building, Ready, Error）。</li><li><strong>查看函数详情:</strong> 点击函数名称进入详情页。<ul><li><strong>Code &amp; Configuration:</strong> 查看或编辑函数的代码和配置。</li><li><strong>Triggers:</strong> 查看触发器信息，特别是 HTTP 触发器的调用 URL。</li><li><strong>Logs:</strong> 查看函数的实时或历史日志输出。</li><li><strong>Monitoring:</strong> 查看函数的调用次数、延迟、成功/失败率等指标（可能需要集成监控系统）。</li><li><strong>Versions:</strong> 查看函数的部署历史版本。</li></ul></li><li><strong>调用/测试函数:</strong> 对于 HTTP 触发器，可以直接在浏览器或使用 <code>curl</code> 等工具访问其 URL 来调用函数。Dashboard 有时也提供简单的调用测试界面。</li><li><strong>编辑/删除函数:</strong> 在函数列表或详情页进行操作。编辑后需要重新部署才能生效。</li></ul></li><li><p><strong>API Gateways:</strong> (如果使用了 Nuclio 的 API Gateway 功能)</p><ul><li>用于创建和管理 API 网关，将外部请求路由到不同的 Nuclio 函数。</li><li>可以配置路径、方法、认证、限流等。</li></ul></li><li><p><strong>设置/平台配置 (Settings / Platform Configuration):</strong> (可能在某些版本或模式下可见)</p><ul><li>查看 Nuclio 平台的配置信息。</li></ul></li></ol><h2 id="基于yolov8模型部署函数计算到nuclio">基于yolov8模型部署函数计算到nuclio</h2><h3 id="yml">yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">nuclio.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Function</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">yolov8-detector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">nuclio</span> <span class="comment"># Or your preferred namespace</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">nuclio.io/project-name:</span> <span class="comment"># Add your project name if using Nuclio projects</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">&quot;YOLOv8 Object Detection Function using model copied during build&quot;</span></span><br><span class="line">  <span class="attr">runtime:</span> <span class="string">python:3.9</span> <span class="comment"># Ensure this matches the Python version you need</span></span><br><span class="line">  <span class="attr">handler:</span> <span class="string">main:handler</span> <span class="comment"># Points to main.py -&gt; handler function</span></span><br><span class="line">  <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HTTP_PROXY</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://192.168.10.123:7890</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">HTTPS_PROXY</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">http://192.168.10.123:7890</span> <span class="comment"># 或者 https://... 如果代理本身用https</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NO_PROXY</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">localhost,127.0.0.1,kubernetes.default.svc</span> <span class="comment"># 添加其他内部地址</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">.</span> <span class="comment"># Build context is still copied somewhere by Nuclio, just maybe not where expected.</span></span><br><span class="line">    <span class="attr">commands:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;apt-get update &amp;&amp; apt-get install -y --no-install-recommends libgl1-mesa-glx libglib2.0-0&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;pip install --default-timeout=600 --no-cache-dir torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cpu&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;pip install -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple --default-timeout=600 --no-cache-dir ultralytics Pillow nuclio-sdk numpy&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ---- Runtime Configuration ----</span></span><br><span class="line">  <span class="comment"># (Optional but Recommended) Set resource limits, especially memory for large models</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">limits:</span></span><br><span class="line">      <span class="attr">memory:</span> <span class="string">&quot;4Gi&quot;</span>   <span class="comment"># Adjust memory limit based on yolov8x needs (e.g., 4Gi, 6Gi, 8Gi)</span></span><br></pre></td></tr></table></figure><h3 id="python-code">python code</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> nuclio_sdk</span><br><span class="line"><span class="keyword">from</span> ultralytics <span class="keyword">import</span> YOLO</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_context</span>(<span class="params">context: nuclio_sdk.Context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化函数上下文，加载模型&quot;&quot;&quot;</span></span><br><span class="line">    context.logger.info(<span class="string">&quot;Initializing YOLOv8 model...&quot;</span>)</span><br><span class="line">    <span class="comment"># 从函数工作目录加载模型文件 (假设 .pt 文件和 main.py 在同一目录)</span></span><br><span class="line">    <span class="comment"># 或者提供模型的绝对路径（如果在 function.yaml 中挂载了）</span></span><br><span class="line">    model_path = <span class="string">&quot;/detect/yolov8/yolov8x.pt&quot;</span></span><br><span class="line">    model = YOLO(model_path)</span><br><span class="line">    context.user_data.model = model</span><br><span class="line">    context.logger.info(<span class="string">&quot;Model loaded successfully.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handler</span>(<span class="params">context: nuclio_sdk.Context, event: nuclio_sdk.Event</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理输入的 HTTP 请求&quot;&quot;&quot;</span></span><br><span class="line">    context.logger.info(<span class="string">&quot;Received event.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查请求体类型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(event.body, <span class="built_in">bytes</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = json.loads(event.body.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            context.logger.error(<span class="string">f&quot;Failed to decode JSON body: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> context.Response(body=<span class="string">f&quot;Bad request: <span class="subst">&#123;e&#125;</span>&quot;</span>, status_code=<span class="number">400</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(event.body, <span class="built_in">dict</span>):</span><br><span class="line">        data = event.body</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> context.Response(body=<span class="string">&quot;Unsupported event body type&quot;</span>, status_code=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从请求中获取 base64 编码的图像数据</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;image&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">return</span> context.Response(body=<span class="string">&quot;Missing &#x27;image&#x27; field in request body&quot;</span>, status_code=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image_b64 = data[<span class="string">&#x27;image&#x27;</span>]</span><br><span class="line">        image_bytes = base64.b64decode(image_b64)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(io.BytesIO(image_bytes)).convert(<span class="string">&#x27;RGB&#x27;</span>) <span class="comment"># 确保是 RGB</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        context.logger.error(<span class="string">f&quot;Failed to decode base64 image: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> context.Response(body=<span class="string">f&quot;Invalid image data: <span class="subst">&#123;e&#125;</span>&quot;</span>, status_code=<span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用加载的模型进行预测</span></span><br><span class="line">    context.logger.info(<span class="string">&quot;Performing inference...&quot;</span>)</span><br><span class="line">    model = context.user_data.model</span><br><span class="line">    results = model(image) <span class="comment"># results 是一个列表，通常包含一个 Results 对象</span></span><br><span class="line">    context.logger.info(<span class="string">&quot;Inference complete.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理预测结果</span></span><br><span class="line">    detections = []</span><br><span class="line">    <span class="keyword">if</span> results <span class="keyword">and</span> results[<span class="number">0</span>]:</span><br><span class="line">        result = results[<span class="number">0</span>] <span class="comment"># 获取第一个图像的结果</span></span><br><span class="line">        boxes = result.boxes  <span class="comment"># Boxes object</span></span><br><span class="line">        names = result.names  <span class="comment"># Class names dict &#123;id: name&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(boxes)):</span><br><span class="line">            box = boxes[i]</span><br><span class="line">            xyxy = box.xyxy.cpu().numpy().flatten().tolist() <span class="comment"># [x1, y1, x2, y2]</span></span><br><span class="line">            conf = <span class="built_in">float</span>(box.conf.cpu().numpy()) <span class="comment"># 置信度</span></span><br><span class="line">            cls_id = <span class="built_in">int</span>(box.cls.cpu().numpy())   <span class="comment"># 类别 ID</span></span><br><span class="line">            label = names[cls_id]                 <span class="comment"># 类别名称</span></span><br><span class="line"></span><br><span class="line">            detections.append(&#123;</span><br><span class="line">                <span class="string">&quot;label&quot;</span>: label,</span><br><span class="line">                <span class="string">&quot;confidence&quot;</span>: conf,</span><br><span class="line">                <span class="comment"># CVAT 通常需要 [xtl, ytl, xbr, ybr] 格式的整数坐标</span></span><br><span class="line">                <span class="string">&quot;points&quot;</span>: [<span class="built_in">int</span>(xyxy[<span class="number">0</span>]), <span class="built_in">int</span>(xyxy[<span class="number">1</span>]), <span class="built_in">int</span>(xyxy[<span class="number">2</span>]), <span class="built_in">int</span>(xyxy[<span class="number">3</span>])]</span><br><span class="line">                <span class="comment"># 或者根据需要返回归一化坐标或其他格式</span></span><br><span class="line">                <span class="comment"># &quot;xtl&quot;: xyxy[0], &quot;ytl&quot;: xyxy[1], &quot;xbr&quot;: xyxy[2], &quot;ybr&quot;: xyxy[3]</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">    context.logger.info(<span class="string">f&quot;Detected <span class="subst">&#123;<span class="built_in">len</span>(detections)&#125;</span> objects.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回 JSON 格式的检测结果</span></span><br><span class="line">    <span class="keyword">return</span> context.Response(body=json.dumps(detections),</span><br><span class="line">                            content_type=<span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">                            status_code=<span class="number">200</span>)</span><br></pre></td></tr></table></figure><h2 id="web-http-调用-yolov8模型">web http 调用 yolov8模型</h2><blockquote><p>可输出 cvat v1.1格式的标注后xml文件，根据输入视频输出目标检测标注结果生成代码 获得标注结果后 压缩标注结果文件 导入cvat对应项目对应task</p></blockquote><ul><li>代码如下：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom <span class="comment"># 用于美化打印XML</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置区 ---</span></span><br><span class="line">VIDEO_PATH = <span class="string">&quot;/Users/zg/PycharmProjects/CVAT_model_nuclio/src/run/data/1.mp4&quot;</span>  <span class="comment"># &lt;&lt;&lt;--- 修改这里: 你的视频文件的完整路径</span></span><br><span class="line">NUCLIO_FUNCTION_URL = <span class="string">&quot;http://192.168.10.158:32774&quot;</span> <span class="comment"># YOLOv8检测器的端口</span></span><br><span class="line">OUTPUT_DIR = <span class="string">&quot;./data/&quot;</span>  <span class="comment"># 输出XML文件的目录</span></span><br><span class="line">LOG_FILE = <span class="string">&quot;./logs/video_processing_cvat_images_cn.log&quot;</span>  <span class="comment"># 日志文件名</span></span><br><span class="line">FRAME_SKIP = <span class="number">5</span>  <span class="comment"># 处理每 N 帧 (1 = 处理所有帧, 5 = 每5帧处理1帧)</span></span><br><span class="line">REQUEST_TIMEOUT = <span class="number">30</span>  <span class="comment"># 等待Nuclio响应的超时时间（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志和数据目录（如果不存在）</span></span><br><span class="line">os.makedirs(<span class="string">&#x27;./logs/&#x27;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">os.makedirs(OUTPUT_DIR, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 设置日志记录 ---</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.INFO, <span class="comment"># 日志级别</span></span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>, <span class="comment"># 日志格式</span></span><br><span class="line">    handlers=[</span><br><span class="line">        logging.FileHandler(LOG_FILE, encoding=<span class="string">&#x27;utf-8&#x27;</span>),  <span class="comment"># 输出日志到文件，使用utf-8编码</span></span><br><span class="line">        logging.StreamHandler()  <span class="comment"># 同时输出日志到控制台</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 辅助函数 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_frame_to_base64</span>(<span class="params">frame</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将OpenCV读取的帧(NumPy数组)编码为Base64字符串。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将帧编码为内存中的JPEG格式</span></span><br><span class="line">        is_success, buffer = cv2.imencode(<span class="string">&quot;.jpg&quot;</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_success:</span><br><span class="line">            logging.error(<span class="string">&quot;无法将帧编码为JPEG。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将字节缓冲区编码为Base64字符串</span></span><br><span class="line">        b64_string = base64.b64encode(buffer).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> b64_string</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;帧编码过程中出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_nuclio_detector</span>(<span class="params">base64_image_string, frame_number</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将Base64编码的图像发送给Nuclio函数并返回检测结果。&quot;&quot;&quot;</span></span><br><span class="line">    payload = json.dumps(&#123;<span class="string">&quot;image&quot;</span>: base64_image_string&#125;)</span><br><span class="line">    headers = &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 发送POST请求</span></span><br><span class="line">        response = requests.post(NUCLIO_FUNCTION_URL, headers=headers, data=payload, timeout=REQUEST_TIMEOUT)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        logging.info(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: Nuclio请求耗时 <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> 秒。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查响应状态码</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                detections = response.json()</span><br><span class="line">                <span class="comment"># 验证检测结果的基本结构</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(detections, <span class="built_in">list</span>):</span><br><span class="line">                     logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: Nuclio响应不是列表。收到类型: <span class="subst">&#123;<span class="built_in">type</span>(detections)&#125;</span>&quot;</span>)</span><br><span class="line">                     <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">                valid_detections = []</span><br><span class="line">                <span class="keyword">for</span> det <span class="keyword">in</span> detections:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">isinstance</span>(det, <span class="built_in">dict</span>) <span class="keyword">and</span> <span class="string">&#x27;label&#x27;</span> <span class="keyword">in</span> det <span class="keyword">and</span> <span class="string">&#x27;points&#x27;</span> <span class="keyword">in</span> det <span class="keyword">and</span> <span class="string">&#x27;confidence&#x27;</span> <span class="keyword">in</span> det:</span><br><span class="line">                         <span class="keyword">if</span> <span class="built_in">isinstance</span>(det[<span class="string">&#x27;points&#x27;</span>], <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">len</span>(det[<span class="string">&#x27;points&#x27;</span>]) == <span class="number">4</span>:</span><br><span class="line">                              valid_detections.append(det)</span><br><span class="line">                         <span class="keyword">else</span>:</span><br><span class="line">                              logging.warning(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 跳过无效&#x27;points&#x27;的检测结果: <span class="subst">&#123;det.get(<span class="string">&#x27;points&#x27;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                         logging.warning(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 跳过缺少键或类型错误的检测结果: <span class="subst">&#123;det&#125;</span>&quot;</span>)</span><br><span class="line">                logging.info(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 收到 <span class="subst">&#123;<span class="built_in">len</span>(valid_detections)&#125;</span> 个有效检测结果。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> valid_detections</span><br><span class="line">            <span class="keyword">except</span> json.JSONDecodeError:</span><br><span class="line">                logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 解析Nuclio的JSON响应失败。状态码: <span class="subst">&#123;response.status_code&#125;</span>, 响应体(前200字符): <span class="subst">&#123;response.text[:<span class="number">200</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_val:</span><br><span class="line">                 logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 验证Nuclio响应结构时出错: <span class="subst">&#123;e_val&#125;</span>&quot;</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: Nuclio函数返回错误。状态码: <span class="subst">&#123;response.status_code&#125;</span>, 响应体(前200字符): <span class="subst">&#123;response.text[:<span class="number">200</span>]&#125;</span>...&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.Timeout:</span><br><span class="line">        logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 请求Nuclio函数超时 (<span class="subst">&#123;REQUEST_TIMEOUT&#125;</span>秒)。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 请求Nuclio函数失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;帧 <span class="subst">&#123;frame_number&#125;</span>: 调用Nuclio时发生意外错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- XML 生成 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pretty_print_xml</span>(<span class="params">elem</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回包含声明且格式化（美化）的XML字符串。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将ElementTree元素转换为utf-8字节字符串</span></span><br><span class="line">        rough_string = ET.tostring(elem, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="comment"># 使用minidom解析字节字符串</span></span><br><span class="line">        reparsed = minidom.parseString(rough_string)</span><br><span class="line">        <span class="comment"># 使用toprettyxml进行格式化，包含缩进和XML声明</span></span><br><span class="line">        <span class="comment"># 确保它返回utf-8编码的字节字符串，然后解码为python字符串</span></span><br><span class="line">        xml_str = reparsed.toprettyxml(indent=<span class="string">&quot;  &quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> xml_str</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;XML美化打印过程中出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 返回None，表示需要调用函数中的后备方案</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_results_to_cvat_image_xml</span>(<span class="params">all_results, xml_output_path, video_filename, frame_width, frame_height, total_processed_frames, original_total_frames</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将检测结果保存为 CVAT XML 1.1 for Images 格式。&quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">f&quot;正在为 <span class="subst">&#123;<span class="built_in">len</span>(all_results)&#125;</span> 个处理过的帧构建CVAT图像XML输出...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 构建XML结构 ---</span></span><br><span class="line">    root = ET.Element(<span class="string">&quot;annotations&quot;</span>)</span><br><span class="line">    ET.SubElement(root, <span class="string">&quot;version&quot;</span>).text = <span class="string">&quot;1.1&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Meta元信息</span></span><br><span class="line">    meta = ET.SubElement(root, <span class="string">&quot;meta&quot;</span>)</span><br><span class="line">    task = ET.SubElement(meta, <span class="string">&quot;task&quot;</span>)</span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;id&quot;</span>).text = <span class="string">&quot;N/A&quot;</span> <span class="comment"># 占位符</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;name&quot;</span>).text = video_filename <span class="comment"># 使用视频名作为任务名</span></span><br><span class="line">    <span class="comment"># 注意: size在这里表示标注的图像数量 (即处理过的帧数)</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;size&quot;</span>).text = <span class="built_in">str</span>(total_processed_frames)</span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;mode&quot;</span>).text = <span class="string">&quot;annotation&quot;</span> <span class="comment"># 模式改为 annotation (图像模式)</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;overlap&quot;</span>).text = <span class="string">&quot;0&quot;</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;bugtracker&quot;</span>).text = <span class="string">&quot;&quot;</span></span><br><span class="line">    current_time_utc = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)[:-<span class="number">3</span>] + <span class="string">&quot;+00:00&quot;</span> <span class="comment"># 当前UTC时间</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;created&quot;</span>).text = current_time_utc</span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;updated&quot;</span>).text = current_time_utc</span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;start_frame&quot;</span>).text = <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="comment"># stop_frame对应最后一帧的索引(0-based)</span></span><br><span class="line">    <span class="comment"># 我们基于处理过的帧来计算，找到最大的帧号</span></span><br><span class="line">    last_processed_frame_num = <span class="built_in">max</span>(all_results.keys()) <span class="keyword">if</span> all_results <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;stop_frame&quot;</span>).text = <span class="built_in">str</span>(last_processed_frame_num - <span class="number">1</span> <span class="keyword">if</span> last_processed_frame_num &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;frame_filter&quot;</span>).text = <span class="string">&quot;&quot;</span> <span class="comment"># 如果有跳帧，可以写在这里，但通常导入时不需要</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取并添加标签信息</span></span><br><span class="line">    labels = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">if</span> all_results:</span><br><span class="line">        <span class="keyword">for</span> frame_dets <span class="keyword">in</span> all_results.values():</span><br><span class="line">            <span class="keyword">if</span> frame_dets:</span><br><span class="line">                <span class="keyword">for</span> det <span class="keyword">in</span> frame_dets:</span><br><span class="line">                    labels.add(<span class="built_in">str</span>(det.get(<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">    labels_elem = ET.SubElement(task, <span class="string">&quot;labels&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> labels: <span class="comment"># 如果没有检测到任何标签，添加一个默认标签</span></span><br><span class="line">        logging.warning(<span class="string">&quot;在检测结果中未找到标签，添加默认&#x27;unknown&#x27;标签。&quot;</span>)</span><br><span class="line">        labels.add(<span class="string">&#x27;unknown&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> label_name <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">list</span>(labels)):</span><br><span class="line">         label_elem = ET.SubElement(labels_elem, <span class="string">&quot;label&quot;</span>)</span><br><span class="line">         ET.SubElement(label_elem, <span class="string">&quot;name&quot;</span>).text = label_name</span><br><span class="line">         ET.SubElement(label_elem, <span class="string">&quot;color&quot;</span>).text = <span class="string">&quot;&quot;</span> <span class="comment"># CVAT会自动分配颜色</span></span><br><span class="line">         ET.SubElement(label_elem, <span class="string">&quot;type&quot;</span>).text = <span class="string">&quot;rectangle&quot;</span> <span class="comment"># 假设都是矩形框</span></span><br><span class="line">         ET.SubElement(label_elem, <span class="string">&quot;attributes&quot;</span>) <span class="comment"># 这里不定义属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加最小化的 segments 信息 (CVAT格式要求)</span></span><br><span class="line">    segments = ET.SubElement(task, <span class="string">&quot;segments&quot;</span>)</span><br><span class="line">    segment = ET.SubElement(segments, <span class="string">&quot;segment&quot;</span>)</span><br><span class="line">    ET.SubElement(segment, <span class="string">&quot;id&quot;</span>).text = <span class="string">&quot;0&quot;</span></span><br><span class="line">    ET.SubElement(segment, <span class="string">&quot;start&quot;</span>).text = <span class="string">&quot;0&quot;</span></span><br><span class="line">    ET.SubElement(segment, <span class="string">&quot;stop&quot;</span>).text = <span class="built_in">str</span>(original_total_frames - <span class="number">1</span>) <span class="comment"># 使用原始视频的总帧数</span></span><br><span class="line">    ET.SubElement(segment, <span class="string">&quot;url&quot;</span>).text = <span class="string">&quot;N/A&quot;</span> <span class="comment"># 占位符</span></span><br><span class="line"></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;owner&quot;</span>) <span class="comment"># 空的 owner</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;assignee&quot;</span>) <span class="comment"># 空的 assignee</span></span><br><span class="line">    ET.SubElement(task, <span class="string">&quot;subset&quot;</span>).text = <span class="string">&quot;Default&quot;</span> <span class="comment"># 默认子集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 原始尺寸信息 (需要)</span></span><br><span class="line">    original_size = ET.SubElement(meta, <span class="string">&quot;original_size&quot;</span>)</span><br><span class="line">    ET.SubElement(original_size, <span class="string">&quot;width&quot;</span>).text = <span class="built_in">str</span>(frame_width)</span><br><span class="line">    ET.SubElement(original_size, <span class="string">&quot;height&quot;</span>).text = <span class="built_in">str</span>(frame_height)</span><br><span class="line"></span><br><span class="line">    ET.SubElement(meta, <span class="string">&quot;dumped&quot;</span>).text = current_time_utc <span class="comment"># 导出时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为每个处理过的帧添加 &lt;image&gt; 标注</span></span><br><span class="line">    <span class="keyword">if</span> all_results:</span><br><span class="line">        <span class="keyword">for</span> frame_number <span class="keyword">in</span> <span class="built_in">sorted</span>(all_results.keys()): <span class="comment"># 按帧号排序</span></span><br><span class="line">            detections = all_results[frame_number]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> detections: <span class="comment"># 如果该帧没有检测结果，跳过（理论上不应发生，因为我们只存储有结果的帧）</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 创建 &lt;image&gt; 元素</span></span><br><span class="line">            image_elem = ET.SubElement(root, <span class="string">&quot;image&quot;</span>)</span><br><span class="line">            <span class="comment"># CVAT 使用 0-based 索引作为 id</span></span><br><span class="line">            image_elem.<span class="built_in">set</span>(<span class="string">&quot;id&quot;</span>, <span class="built_in">str</span>(frame_number - <span class="number">1</span>))</span><br><span class="line">            <span class="comment"># 生成一个规范的帧名 (可选，但推荐)</span></span><br><span class="line">            image_elem.<span class="built_in">set</span>(<span class="string">&quot;name&quot;</span>, <span class="string">f&quot;frame_<span class="subst">&#123;frame_number:06d&#125;</span>&quot;</span>) <span class="comment"># 格式化帧号，如 frame_000123</span></span><br><span class="line">            image_elem.<span class="built_in">set</span>(<span class="string">&quot;width&quot;</span>, <span class="built_in">str</span>(frame_width))</span><br><span class="line">            image_elem.<span class="built_in">set</span>(<span class="string">&quot;height&quot;</span>, <span class="built_in">str</span>(frame_height))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在 &lt;image&gt; 元素内部添加 &lt;box&gt; 元素</span></span><br><span class="line">            <span class="keyword">for</span> det <span class="keyword">in</span> detections:</span><br><span class="line">                box_elem = ET.SubElement(image_elem, <span class="string">&quot;box&quot;</span>)</span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;label&quot;</span>, <span class="built_in">str</span>(det.get(<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">                points = det.get(<span class="string">&#x27;points&#x27;</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">                <span class="comment"># 坐标使用两位小数的浮点数格式</span></span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;xtl&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">float</span>(points[<span class="number">0</span>]):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;ytl&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">float</span>(points[<span class="number">1</span>]):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;xbr&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">float</span>(points[<span class="number">2</span>]):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;ybr&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;<span class="built_in">float</span>(points[<span class="number">3</span>]):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 对于图像格式，通常不需要 outside，但 occluded 可以保留</span></span><br><span class="line">                box_elem.<span class="built_in">set</span>(<span class="string">&quot;occluded&quot;</span>, <span class="string">&quot;0&quot;</span>) <span class="comment"># 0 表示未遮挡 (假设)</span></span><br><span class="line">                <span class="comment"># 在 CVAT for Images 格式中，不需要 keyframe 和 outside</span></span><br><span class="line">                <span class="comment"># box_elem.set(&quot;outside&quot;, &quot;0&quot;) # 通常不需要为图像设置outside</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 将置信度添加为属性</span></span><br><span class="line">                attr_conf = ET.SubElement(box_elem, <span class="string">&quot;attribute&quot;</span>, name=<span class="string">&quot;confidence&quot;</span>)</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    confidence_val = <span class="built_in">float</span>(det.get(<span class="string">&#x27;confidence&#x27;</span>, <span class="number">0.0</span>))</span><br><span class="line">                <span class="keyword">except</span> (ValueError, TypeError):</span><br><span class="line">                    confidence_val = <span class="number">0.0</span></span><br><span class="line">                attr_conf.text = <span class="string">f&quot;<span class="subst">&#123;confidence_val:<span class="number">.4</span>f&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 结束构建XML结构 ---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 写入 XML 文件 ---</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获取包含声明且格式化的完整XML字符串</span></span><br><span class="line">        full_xml_string = pretty_print_xml(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> full_xml_string:</span><br><span class="line">            <span class="comment"># 在写入前确保字符串以 &lt;?xml 开头</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> full_xml_string.strip().startswith(<span class="string">&quot;&lt;?xml&quot;</span>):</span><br><span class="line">                 logging.error(<span class="string">&quot;美化打印未能生成有效的XML开头。&quot;</span>)</span><br><span class="line">                 <span class="keyword">raise</span> ValueError(<span class="string">&quot;美化打印失败。&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(xml_output_path, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># 直接写入完整的字符串</span></span><br><span class="line">                f.write(full_xml_string)</span><br><span class="line">            logging.info(<span class="string">f&quot;检测结果已保存至 CVAT 图像 XML: <span class="subst">&#123;xml_output_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果 pretty_print_xml 返回 None，使用后备方案</span></span><br><span class="line">            logging.warning(<span class="string">&quot;美化打印失败，回退到基础XML写入器。&quot;</span>)</span><br><span class="line">            tree = ET.ElementTree(root)</span><br><span class="line">            <span class="comment"># 如果 Python &gt;= 3.9, 可以使用 ET.indent 添加基本缩进</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(ET, <span class="string">&#x27;indent&#x27;</span>):</span><br><span class="line">                 ET.indent(tree, space=<span class="string">&quot;  &quot;</span>, level=<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 使用 ElementTree 写入，并请求 XML 声明</span></span><br><span class="line">            tree.write(xml_output_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>, xml_declaration=<span class="literal">True</span>)</span><br><span class="line">            logging.info(<span class="string">f&quot;检测结果已保存至基础 CVAT XML (后备方案): <span class="subst">&#123;xml_output_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;保存结果到 CVAT XML 文件失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主处理逻辑 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    logging.info(<span class="string">f&quot;开始处理视频: <span class="subst">&#123;VIDEO_PATH&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Nuclio 函数 URL: <span class="subst">&#123;NUCLIO_FUNCTION_URL&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;处理帧间隔: 每 <span class="subst">&#123;FRAME_SKIP&#125;</span> 帧&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(VIDEO_PATH):</span><br><span class="line">        logging.error(<span class="string">f&quot;视频文件未找到: <span class="subst">&#123;VIDEO_PATH&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    cap = cv2.VideoCapture(VIDEO_PATH)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        logging.error(<span class="string">f&quot;打开视频文件错误: <span class="subst">&#123;VIDEO_PATH&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取视频元数据</span></span><br><span class="line">    original_total_frames = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    frame_width = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_WIDTH))</span><br><span class="line">    frame_height = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))</span><br><span class="line">    <span class="keyword">if</span> original_total_frames &lt;= <span class="number">0</span>:</span><br><span class="line">        logging.error(<span class="string">f&quot;视频文件似乎为空或元数据错误 (总帧数: <span class="subst">&#123;original_total_frames&#125;</span>)。&quot;</span>)</span><br><span class="line">        cap.release()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    logging.info(<span class="string">f&quot;视频信息: 总帧数: <span class="subst">&#123;original_total_frames&#125;</span>, FPS: <span class="subst">&#123;fps:<span class="number">.2</span>f&#125;</span>, 尺寸: <span class="subst">&#123;frame_width&#125;</span>x<span class="subst">&#123;frame_height&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    frame_count = <span class="number">0</span> <span class="comment"># 已读取的帧计数 (1-based for logging)</span></span><br><span class="line">    processed_frame_count = <span class="number">0</span> <span class="comment"># 实际处理的帧计数</span></span><br><span class="line">    all_results = &#123;&#125; <span class="comment"># 存储结果: &#123;帧号 (1-based): [检测列表]&#125;</span></span><br><span class="line">    start_process_time = time.time() <span class="comment"># 开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取一帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否成功读取</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            <span class="keyword">if</span> frame_count &lt; original_total_frames:</span><br><span class="line">                logging.warning(<span class="string">f&quot;无法读取帧 <span class="subst">&#123;frame_count + <span class="number">1</span>&#125;</span> (总帧数 <span class="subst">&#123;original_total_frames&#125;</span>)，假定视频结束。&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                 logging.info(<span class="string">&quot;视频处理到达结尾。&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span> <span class="comment"># 退出循环</span></span><br><span class="line"></span><br><span class="line">        frame_count += <span class="number">1</span> <span class="comment"># 更新已读取帧计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 跳帧逻辑 ---</span></span><br><span class="line">        <span class="keyword">if</span> FRAME_SKIP &gt; <span class="number">1</span> <span class="keyword">and</span> frame_count % FRAME_SKIP != <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment"># 跳过当前帧</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 处理当前帧 ---</span></span><br><span class="line">        processed_frame_count += <span class="number">1</span> <span class="comment"># 更新已处理帧计数</span></span><br><span class="line">        logging.info(<span class="string">f&quot;正在处理帧 <span class="subst">&#123;frame_count&#125;</span>/<span class="subst">&#123;original_total_frames&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 编码帧</span></span><br><span class="line">        b64_string = encode_frame_to_base64(frame)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> b64_string:</span><br><span class="line">            logging.warning(<span class="string">f&quot;因编码错误跳过帧 <span class="subst">&#123;frame_count&#125;</span>。&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用 Nuclio 检测器</span></span><br><span class="line">        detections = call_nuclio_detector(b64_string, frame_count)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储检测结果 (仅当检测结果非空时存储)</span></span><br><span class="line">        <span class="keyword">if</span> detections:</span><br><span class="line">            all_results[frame_count] = detections <span class="comment"># 使用 1-based 帧号作为键</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 进度估计 (可选) ---</span></span><br><span class="line">        <span class="keyword">if</span> processed_frame_count &gt; <span class="number">0</span> <span class="keyword">and</span> processed_frame_count % <span class="number">10</span> == <span class="number">0</span>: <span class="comment"># 每处理10帧更新一次进度</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                elapsed_time = time.time() - start_process_time</span><br><span class="line">                <span class="comment"># 估计总共需要处理的帧数</span></span><br><span class="line">                estimated_total_to_process = (original_total_frames // FRAME_SKIP) <span class="keyword">if</span> FRAME_SKIP &gt; <span class="number">1</span> <span class="keyword">else</span> original_total_frames</span><br><span class="line">                <span class="keyword">if</span> estimated_total_to_process &gt; <span class="number">0</span>:</span><br><span class="line">                    fraction_done = processed_frame_count / estimated_total_to_process</span><br><span class="line">                    <span class="comment"># 避免除零错误和进度超过100%的情况</span></span><br><span class="line">                    <span class="keyword">if</span> fraction_done &gt; <span class="number">0</span> <span class="keyword">and</span> fraction_done &lt;= <span class="number">1</span>:</span><br><span class="line">                        total_estimated_time = elapsed_time / fraction_done</span><br><span class="line">                        estimated_remaining_time = <span class="built_in">max</span>(<span class="number">0</span>, total_estimated_time - elapsed_time) <span class="comment"># 确保不为负</span></span><br><span class="line">                        logging.info(</span><br><span class="line">                            <span class="string">f&quot;进度: 帧 <span class="subst">&#123;frame_count&#125;</span>/<span class="subst">&#123;original_total_frames&#125;</span>。已处理 <span class="subst">&#123;processed_frame_count&#125;</span> 帧。预计剩余时间: <span class="subst">&#123;timedelta(seconds=<span class="built_in">int</span>(estimated_remaining_time))&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">                logging.warning(<span class="string">&quot;无法估计剩余时间 (除零错误)。&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_est:</span><br><span class="line">                logging.warning(<span class="string">f&quot;无法估计剩余时间: <span class="subst">&#123;e_est&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 清理与保存 ---</span></span><br><span class="line">    cap.release() <span class="comment"># 释放视频捕获对象</span></span><br><span class="line">    logging.info(<span class="string">&quot;视频捕获已释放。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定输出XML文件名</span></span><br><span class="line">    video_basename = os.path.basename(VIDEO_PATH)</span><br><span class="line">    video_name_no_ext, _ = os.path.splitext(video_basename)</span><br><span class="line">    <span class="comment"># 文件名表明是CVAT图像格式</span></span><br><span class="line">    xml_output_filename = <span class="string">f&quot;<span class="subst">&#123;video_name_no_ext&#125;</span>_cvat_images.xml&quot;</span></span><br><span class="line">    xml_output_path = os.path.join(OUTPUT_DIR, xml_output_filename)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存为 CVAT 图像 XML</span></span><br><span class="line">    <span class="keyword">if</span> all_results:</span><br><span class="line">         <span class="comment"># 传递处理过的帧数给size字段</span></span><br><span class="line">         save_results_to_cvat_image_xml(</span><br><span class="line">             all_results,</span><br><span class="line">             xml_output_path,</span><br><span class="line">             video_basename,</span><br><span class="line">             frame_width,</span><br><span class="line">             frame_height,</span><br><span class="line">             processed_frame_count, <span class="comment"># 传递处理过的帧数</span></span><br><span class="line">             original_total_frames <span class="comment"># 传递原始总帧数</span></span><br><span class="line">         )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         logging.warning(<span class="string">&quot;没有记录到任何检测结果，将不会创建CVAT XML文件。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 结束处理 ---</span></span><br><span class="line">    end_process_time = time.time()</span><br><span class="line">    total_time = <span class="built_in">max</span>(<span class="number">0</span>, end_process_time - start_process_time) <span class="comment"># 确保总时间非负</span></span><br><span class="line">    logging.info(<span class="string">f&quot;视频处理完成。总耗时: <span class="subst">&#123;timedelta(seconds=<span class="built_in">int</span>(total_time))&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;总共读取帧数: <span class="subst">&#123;frame_count&#125;</span>。实际处理帧数: <span class="subst">&#123;processed_frame_count&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 程序入口 ---</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="see">see</h2><ul><li>1.<a href="https://github.com/nuclio/nuclio?tab=readme-ov-file#quick-start-steps">https://github.com/nuclio/nuclio?tab=readme-ov-file#quick-start-steps</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Nuclio Dashboard 是 Nuclio Serverless 平台的一个基于 Web 的图形用户界面（GUI），它允许用户方便地管理（创建、查看、编辑、删除、部署）Nuclio 函数、项目、事件源（Triggers）等资源。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg分割视频与音频中的处理问题分析</title>
    <link href="https://caozhaoqi.github.io/2025/04/07/ffmpeg-problem-video/"/>
    <id>https://caozhaoqi.github.io/2025/04/07/ffmpeg-problem-video/</id>
    <published>2025-04-07T03:25:47.000Z</published>
    <updated>2025-11-25T15:05:10.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><blockquote><p>ffmpeg is a universal media converter. It can read a wide variety of inputs - including live grabbing/recording devices - filter, and transcode them into a plethora of output formats.</p></blockquote><blockquote><p>ffmpg包含了一整套用于处理音频、视频、字幕以及其他多média数据流的库（libraries）和程序（programs）。</p></blockquote><h2 id="视频处理">视频处理</h2><h3 id="视频帧">视频帧</h3><blockquote><p>如图</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/kf.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/kf.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li><strong>I 帧 (关键帧)</strong>: 完整的图像，独立解码，是解码起点和参考基准，压缩率最低，数据量最大。</li><li><strong>P 帧</strong>: 存储与前一帧的差异，依赖前一帧解码，压缩率较高，数据量中等。</li><li><strong>B 帧</strong>: 存储与前、后帧的差异，依赖前后帧解码，压缩率最高，数据量最小。</li><li><strong>GOP</strong>: 由一个 I 帧和若干 P/B 帧组成的序列，其长度影响压缩率和随机访问性能。</li></ul><h3 id="帧构成">帧构成</h3><blockquote><p>如图</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/gop.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/gop.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li><p><strong>I 帧 (Intra-coded Picture / Keyframe / 关键帧)</strong></p></li><li><p><strong>构成</strong>: I 帧是一帧<strong>完整</strong>的图像。它不依赖于任何其他帧来进行解码。它本身包含了在该时间点显示完整画面所需的所有信息。</p></li><li><p><strong>编码方式</strong>: 它只利用了<strong>空间冗余</strong>进行压缩，其编码方式类似于静态图像压缩（如 JPEG）。它不对前后帧进行参考。</p></li><li><p><strong>作用</strong>:</p></li><li><p><strong>解码起点</strong>: 播放器可以从任何一个 I 帧开始解码并正确显示视频，因此 I 帧是视频随机访问（快进、快退、定位播放）的基础。</p></li><li><p><strong>参考基准</strong>: 它作为后续 P 帧和 B 帧进行预测和参考的“基准帧”。</p></li><li><p><strong>错误隔离</strong>: 如果传输或存储中出现错误，错误的影响通常只持续到下一个 I 帧，I 帧可以阻止错误的进一步传播。</p></li><li><p><strong>特点</strong>: 数据量最大，压缩率最低（相比 P/B 帧）。</p></li><li><p><strong>P 帧 (Predicted Picture / 前向预测帧)</strong></p></li><li><p><strong>构成</strong>: P 帧不是一个完整的图像。它存储的是当前画面与<strong>之前</strong>的某个 I 帧或 P 帧之间的<strong>差异信息</strong>。</p></li><li><p><strong>编码方式</strong>: 它利用了<strong>时间冗余</strong>。编码器会分析当前 P 帧与它参考的前一帧（I 或 P）之间的区别，主要是物体的运动（通过<strong>运动矢量 (Motion Vectors</strong> 描述物体移动的方向和距离）以及运动补偿后的残差信息（预测不完全准确的部分）。</p></li><li><p><strong>作用</strong>: 大大提高压缩率，因为只存储变化的部分，数据量远小于 I 帧。</p></li><li><p><strong>依赖性</strong>: 解码 P 帧<strong>必须</strong>先解码它所参考的那个前面的 I 帧或 P 帧。</p></li><li><p><strong>特点</strong>: 数据量介于 I 帧和 B 帧之间，压缩率较高。</p></li><li><p><strong>B 帧 (Bi-directionally Predicted Picture / 双向预测帧)</strong></p></li><li><p><strong>构成</strong>: B 帧也不是一个完整的图像。它存储的是当前画面与它<strong>前面</strong>的一个参考帧（I 或 P）以及<strong>后面</strong>的一个参考帧（I 或 P）之间的差异信息。</p></li><li><p><strong>编码方式</strong>: 它利用了更充分的<strong>时间冗余</strong>。编码器可以同时参考过去和未来的帧来预测当前 B 帧的内容，通常能找到更相似的块，从而更有效地描述差异（运动矢量和残差）。</p></li><li><p><strong>作用</strong>: 提供最高的压缩率，数据量通常是最小的。</p></li><li><p><strong>依赖性</strong>: 解码 B 帧<strong>必须</strong>先解码它所参考的前、后两个参考帧。这意味着解码器需要先解码未来的参考帧，才能回头解码当前的 B 帧，这会引入一定的解码延迟。</p></li><li><p><strong>特点</strong>: 数据量最小，压缩率最高。</p></li></ul><h3 id="图像序列">图像序列</h3><ul><li><strong>GOP (Group of Pictures / 图像组)</strong></li></ul><blockquote><p>这些 I、P、B 帧通常被组织成一个称为 GOP 的序列。一个 GOP 以一个 I 帧开始，后面跟着一系列 P 帧和 B 帧，直到下一个 I 帧。</p></blockquote><ul><li><strong>结构示例</strong>: 一个常见的 GOP 结构可能是 <code>I B B P B B P B B I</code>。这个序列会重复出现。</li><li><strong>GOP 长度</strong>: 指两个连续 I 帧之间的距离（以帧数或时间衡量）。</li><li><strong>长 GOP</strong>: 包含更多的 P 和 B 帧，压缩率更高，但随机访问性能差（定位播放时需要找到更久之前的 I 帧），错误恢复慢。</li><li><strong>短 GOP</strong>: I 帧更频繁，压缩率较低，但随机访问快，错误恢复快。直播或需要频繁编辑的场景通常使用较短的 GOP。</li></ul><blockquote><p>由于 B 帧需要参考后面的帧，所以解码器处理帧的顺序（解码顺序）可能与最终屏幕上播放的顺序（显示顺序）不同。解码器需要先解码 B 帧所依赖的后面的参考帧，然后才能解码 B 帧本身，上述视频帧在解码与显示视频时关系如下图所示：</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/keyframe.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/keyframe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="主要功能及构成">主要功能及构成</h2><h3 id="功能">功能</h3><ol><li><strong>格式转换 (Transcoding / Format Conversion):</strong> FFmpeg 最常用的功能之一。它可以轻松地将视频或音频文件从一种格式转换为另一种格式（例如，MP4 转 AVI，WAV 转 MP3）。</li><li><strong>编码与解码 (Encoding / Decoding):</strong> 支持几乎所有已知的音频和视频编解码器（Codecs）。你可以用它来压缩媒体文件（编码）或播放/处理它们（解码）。</li><li><strong>封装与解封装 (Muxing / Demuxing):</strong> 可以将单独的音频流和视频流合并到一个容器文件（如 MP4, MKV）中（封装），或者从一个容器文件中提取出单独的音频、视频或字幕流（解封装）。</li><li><strong>流媒体处理 (Streaming):</strong> FFmpeg 可以捕捉、编码并将音视频流实时推送到流媒体服务器（如 RTMP, HLS），也可以作为客户端接收和处理流。</li><li><strong>编辑与处理 (Editing &amp; Filtering):</strong><ul><li><strong>裁剪 (Cropping):</strong> 截取视频画面的特定区域。</li><li><strong>缩放 (Scaling):</strong> 改变视频分辨率。</li><li><strong>旋转/翻转 (Rotating/Flipping):</strong> 调整视频方向。</li><li><strong>合并/分割 (Concatenating/Splitting):</strong> 连接或切分媒体文件。</li><li><strong>添加水印/字幕 (Watermarking/Subtitles):</strong> 在视频上叠加图片或文字。</li><li><strong>调整速度 (Speed Adjustment):</strong> 快放或慢放。</li><li><strong>应用滤镜 (Applying Filters):</strong> 调整亮度、对比度、饱和度，添加模糊、锐化等各种视觉效果，以及音频效果如音量调整、降噪等。</li></ul></li><li><strong>屏幕录制与设备捕捉 (Screen Recording &amp; Device Capture):</strong> 可以录制桌面屏幕、摄像头输入或麦克风音频。</li><li><strong>媒体信息分析 (Media Information Analysis):</strong> 通过 <code>ffprobe</code> 工具，可以详细分析媒体文件的各种参数，如编码格式、分辨率、比特率、帧率、时长等。</li></ol><h3 id="关键流程解读">关键流程解读</h3><ul><li>FFmpeg 的基本工作流程可以理解为一个处理管线：</li></ul><blockquote><p>解复用 (Demuxing): ffmpeg 读取输入文件 (-i input.mkv)。解复用器 (Demuxer) 负责解析容器格式 (如 MKV, MP4, AVI)，并将其中包含的各个基本流 (Elementary Streams, ES) 分离出来，这些流是编码过的数据包 (Packets)。</p></blockquote><blockquote><p>解码 (Decoding): 对于需要处理或重新编码的流，其数据包会被送入相应的解码器 (Decoder)。解码器将压缩的编码数据还原成原始的、未压缩的帧 (Frames) - 视频帧或音频采样。如果使用了 -c copy (流复制)，则跳过此步骤。</p></blockquote><blockquote><p>滤镜 (Filtering): 解码后的原始帧可以被送入滤镜图 (Filtergraph) (-vf, -af, -filter_complex) 进行处理。滤镜可以修改帧的内容，例如：<br>视频滤镜：缩放、裁剪、旋转、叠加水印、调色、去隔行等。<br>音频滤镜：重采样、改变音量、混音、降噪等。<br>如果未使用滤镜，则跳过此步骤。</p></blockquote><blockquote><p>编码 (Encoding): 经过滤镜处理（或直接来自解码器）的原始帧被送入指定的编码器 (Encoder) (-c:v libx264, -c:a aac 等)。编码器将原始帧压缩成编码后的数据包 (Packets)。如果使用了 -c copy (流复制)，则跳过此步骤。</p></blockquote><blockquote><p>复用 (Muxing): 编码后的数据包（或者从流复制直接过来的数据包）被送入复用器 (Muxer) (-f mp4 等指定格式)。复用器负责将来自不同流的数据包按照目标容器格式 (如 MP4, MKV, FLV) 的规范，交织写入到输出文件中 (output.mp4)。</p></blockquote><h3 id="构成">构成</h3><ul><li><strong><code>ffmpeg</code>:</strong> 核心的命令行工具，用于执行上述大部分的转换、处理任务。</li><li><strong><code>ffplay</code>:</strong> 一个基于 SDL 和 FFmpeg 库的简单媒体播放器。</li><li><strong><code>ffprobe</code>:</strong> 一个命令行工具，用于分析媒体文件并以文本、JSON、XML 等多种格式输出详细信息。</li><li><strong><code>libavcodec</code>:</strong> 包含了所有音频/视频编码器和解码器的库。</li><li><strong><code>libavformat</code>:</strong> 包含了处理各种媒体容器格式（封装/解封装）的库。</li><li><strong><code>libavfilter</code>:</strong> 包含了各种音频和视频滤镜的库。</li><li><strong><code>libswscale</code>:</strong> 用于图像缩放和颜色空间/像素格式转换的库。</li><li><strong><code>libswresample</code>:</strong> 用于音频重采样、格式转换和通道布局管理的库。</li><li><strong><code>libavutil</code>:</strong> 包含各种辅助工具函数的基础库。</li></ul><h2 id="选项指定">选项指定</h2><ul><li><strong><code>-i url</code></strong>: 指定输入文件或来源。可以有多个 <code>-i</code>。</li><li><strong><code>-f fmt</code></strong>: 强制指定输出文件格式 (如 <code>-f mp4</code>, <code>-f flv</code>)。通常 FFmpeg 能根据扩展名自动判断，但有时需要强制指定。</li><li><strong><code>-map [-]input_file_id[:stream_specifier][?]</code></strong>: <strong>极其重要</strong>。用于手动控制哪些输入流被包含到哪个输出文件中。<ul><li><code>0:v</code> 选择第一个输入文件的所有视频流。</li><li><code>0:a:1</code> 选择第一个输入文件的第二个音频流 (索引从0开始)。</li><li><code>1:s?</code> 选择第二个输入文件的第一个字幕流（如果存在）。</li><li><code>-map 0</code> 选择第一个输入文件的所有流。</li><li><code>-map -0:a</code> 从自动选择中排除第一个输入文件的所有音频流。</li></ul></li><li><strong><code>-c[:stream_specifier] codec</code></strong>: <strong>极其重要</strong>。选择编码器。<ul><li><code>-c copy</code>: 进行流复制 (Stream Copy)，不重新编码。</li><li><code>-c:v libx264</code>: 为视频流选择 H.264 (libx264) 编码器。</li><li><code>-c:a aac</code>: 为音频流选择 AAC 编码器。</li><li><code>-c:s mov_text</code>: 为字幕流选择 mov_text 编码器。</li><li><code>-vn</code>, <code>-an</code>, <code>-sn</code>: 分别是 <code>-c:v copy -an -sn</code>、<code>-c:a copy -vn -sn</code>、<code>-c:s copy -vn -an</code> 的简写，但更常用的含义是完全<strong>禁用</strong>视频/音频/字幕的录制/输出 (相当于映射到 /dev/null)。</li></ul></li><li><strong><code>-t duration</code></strong>: 指定输出文件的时长。</li><li><strong><code>-to position</code></strong>: 指定输出文件的结束时间点。</li><li><strong><code>-ss position</code></strong>: 指定输出文件的<strong>开始时间点</strong> (如果放在输出选项位置，通常会进行精确查找，但可能较慢；放在输入选项 <code>-i</code> 之前则查找更快但不精确)。</li><li><strong><code>-vf filtergraph</code></strong>: 设置视频滤镜链 (简单滤镜图)。</li><li><strong><code>-af filtergraph</code></strong>: 设置音频滤镜链 (简单滤镜图)。</li><li><strong><code>-filter_complex filtergraph</code></strong>: 设置复杂滤镜图，用于处理多个输入/输出流或需要复杂连接的滤镜。</li><li><strong>比特率/质量控制</strong>:<ul><li><code>-b:v bitrate</code>: 设置视频目标比特率 (如 <code>-b:v 1M</code> 表示 1 Mbps)。</li><li><code>-b:a bitrate</code>: 设置音频目标比特率 (如 <code>-b:a 128k</code> 表示 128 kbps)。</li><li><code>-crf value</code> (Constant Rate Factor): 恒定质量因子，是 x264/x265 等编码器常用的质量控制模式，数值越低质量越好，文件越大。</li><li><code>-q:v value</code> / <code>-qscale:v value</code>: 控制视频质量（某些编码器）。</li></ul></li><li><strong>视频选项</strong>:<ul><li><code>-r fps</code>: 设置帧率 (如 <code>-r 25</code>)。</li><li><code>-s WxH</code>: 设置视频分辨率 (如 <code>-s 1280x720</code>)。</li><li><code>-aspect ratio</code>: 设置画面宽高比 (如 <code>-aspect 16:9</code>)。</li><li><code>-pix_fmt format</code>: 设置像素格式。</li></ul></li><li><strong>音频选项</strong>:<ul><li><code>-ar freq</code>: 设置音频采样率 (如 <code>-ar 44100</code>)。</li><li><code>-ac channels</code>: 设置音频通道数 (如 <code>-ac 2</code> 表示立体声)。</li><li><code>-vol volume</code>: 调整音量 (如 <code>-vol 512</code> 表示 2 倍音量)。</li></ul></li></ul><p><strong>流指定符 (Stream Specifiers):</strong></p><p>这是一个强大的机制，允许你将选项精确地应用到特定的流上。格式通常是 <code>选项名:流类型[:流索引]</code>。</p><ul><li><code>-c:v libx264</code>: 将编码器 <code>libx264</code> 应用于所有视频流。</li><li><code>-b:a:1 192k</code>: 将比特率 <code>192k</code> 应用于第二个音频流。</li><li><code>-disposition:s:0 default</code>: 将第一个字幕流的 disposition 设置为 default。</li><li><code>-map 0:v -map 0:a:0</code>: 选择第一个输入文件的所有视频流和第一个音频流。</li></ul><h2 id="问题">问题</h2><h3 id="视频切割中存在的问题">视频切割中存在的问题</h3><ul><li>切割视频后存在开始前几秒为黑屏</li></ul><blockquote><p>问题分析</p></blockquote><blockquote><p>常见的原因是剪辑的起始点 (-ss) 没有落在关键帧 (Keyframe / I-frame) 上。</p></blockquote><blockquote><p>流拷贝模式直接复制视频数据包，而不进行解码和重新编码。视频播放器通常需要从一个关键帧开始解码，如果剪辑后的视频片段开头不是关键帧，而是 P 帧或 B 帧（它们依赖于之前的帧进行解码），播放器就无法正确显示画面，导致黑屏或花屏，直到遇到第一个关键帧为止；重新编码可解决此问题。</p></blockquote><ul><li>按照n秒切割，大批量切割时存在：n-1或n+1秒视频存在</li></ul><blockquote><p>问题分析</p></blockquote><ol><li><strong>流拷贝 (<code>-c copy</code>)</strong>: 此模式不解码和重新编码视频。它直接复制原始视频流的数据包。</li><li><strong>关键帧 (Keyframes)</strong>: 视频压缩（如 H.264, H.265）依赖于关键帧。只有关键帧可以独立解码，后续的 P 帧和 B 帧需要依赖关键帧或其他帧才能解码。因此，一个独立的、可播放的视频片段<strong>必须</strong>以关键帧开始。</li><li><strong>分割点</strong>: 当指定按 <code>n</code> 秒分割时，<code>ffmpeg</code>（特别是使用 <code>segment</code> muxer 或类似的切割逻辑配合 <code>-c copy</code> 时）会寻找时间戳接近 <code>n</code>, <code>2n</code>, <code>3n</code>… 的位置。但是，为了确保输出的每个片段都能独立播放，它<strong>不能</strong>在任意帧（如 P 帧或 B 帧）处切割，而必须在分割点<strong>之前或之后最近的关键帧</strong>处进行实际切割。</li><li><strong>时长偏差</strong>:<ul><li>如果 <code>n</code> 秒处恰好是关键帧，那么分割可能比较准确。</li><li>如果 <code>n</code> 秒处不是关键帧，<code>ffmpeg</code> 通常会回溯到<strong>之前</strong>的那个关键帧作为上一个片段的结束点，并从这个关键帧开始新的片段。</li><li>这就导致了实际分割点与理论上的 <code>n</code> 秒点有偏差。这个偏差取决于关键帧之间的距离（GOP size）。如果关键帧间隔很大（比如 10 秒），偏差可能会很明显。如果关键帧间隔小（比如 1 秒），偏差通常较小，但仍可能导致 <code>n-1</code> 或 <code>n+1</code> 秒的情况。</li></ul></li></ol><ul><li>command 如下：</li></ul> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> = [</span><br><span class="line">    <span class="string">&#x27;ffmpeg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;-i&#x27;</span>, str(input_path),         <span class="comment"># Input file</span></span><br><span class="line">    <span class="string">&#x27;-ss&#x27;</span>, start_timecode_str,     <span class="comment"># Start time</span></span><br><span class="line">    <span class="string">&#x27;-to&#x27;</span>, end_timecode_str,       <span class="comment"># End time</span></span><br><span class="line">    <span class="string">&#x27;-copyts&#x27;</span>,                     <span class="comment"># Copy timestamps</span></span><br><span class="line">    <span class="string">&#x27;-avoid_negative_ts&#x27;</span>, <span class="string">&#x27;make_zero&#x27;</span>, <span class="comment"># Handle timestamp issues</span></span><br><span class="line">    <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>,                  <span class="comment"># Copy codecs (no re-encoding)</span></span><br><span class="line">    <span class="string">&#x27;-y&#x27;</span>,                          <span class="comment"># Overwrite output file if it exists</span></span><br><span class="line">    str(output_path)               <span class="comment"># Output file</span></span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用上述command切割视频后存在黑屏、分段视频时长小于目标时长问题 command采用copy视频流</p></blockquote><ul><li>更换以下command 重新编码视频流</li></ul> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> = [</span><br><span class="line">    ffmpeg_path,</span><br><span class="line">    <span class="string">&#x27;-y&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;-ss&#x27;</span>, str(start_segment_time),</span><br><span class="line">    <span class="string">&#x27;-i&#x27;</span>, video_file,</span><br><span class="line">    <span class="string">&#x27;-t&#x27;</span>, str(end_segment_time - start_segment_time),</span><br><span class="line">    <span class="string">&#x27;-c:v&#x27;</span>, <span class="string">&#x27;h264_nvenc&#x27;</span> <span class="keyword">if</span> gpu_available <span class="keyword">else</span> <span class="string">&#x27;libx264&#x27;</span>, <span class="comment"># 使用NVIDIA GPU加速的编码器, 如果没有GPU，则使用CPU</span></span><br><span class="line">    <span class="string">&#x27;-preset&#x27;</span>, preset,</span><br><span class="line">    <span class="string">&#x27;-crf&#x27;</span>, str(crf),  <span class="comment"># 指定视觉质量</span></span><br><span class="line">    <span class="string">&#x27;-pix_fmt&#x27;</span>, <span class="string">&#x27;yuv420p&#x27;</span>,  <span class="comment"># 指定像素格式</span></span><br><span class="line">    <span class="string">&#x27;-c:a&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;-avoid_negative_ts&#x27;</span>, <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    output_file</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="ffmpeg-转码">ffmpeg 转码</h2><ul><li>转码过程如下</li></ul><blockquote><p>转码是指先解码 (decode) 一个流得到原始数据（如视频帧或音频样本），然后再用指定的编码器重新编码 (encode) 这些数据的过程</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/decode.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/decode.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>复制数据流（流复制）</li></ul><blockquote><p>流复制是指直接从输入文件中“提取”媒体流（如视频流、音频流）的数据包 (packets)，然后原封不动地将这些数据包“放入”输出文件中，整个过程不经过解码和重新编码。</p></blockquote><blockquote><p>图中用流复制合并视频与音频流 流复制可用于合并、分割、提取数据流</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/encode.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/encode.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>流复制用于视频分割过程</li></ul><blockquote><p>demuxer 分离出两个流，流 0 被送到 muxer 0 生成 OUTPUT0.mp4，流 1 被送到 muxer 1 生成 OUTPUT1.mp4</p></blockquote><p><img src="/2025/04/07/ffmpeg-problem-video/encode_split.png" class="lazyload placeholder" data-srcset="/2025/04/07/ffmpeg-problem-video/encode_split.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="参考">参考</h2><ul><li>1.<a href="https://www.ffmpeg.org/ffmpeg.html">https://www.ffmpeg.org/ffmpeg.html</a></li><li>2.<a href="https://www.ffmpeg.org/ffprobe.html">https://www.ffmpeg.org/ffprobe.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;ffmpeg is a universal media converter. It can read a wide variety of inputs - including live grabbing/re</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>视频场景切换检测</title>
    <link href="https://caozhaoqi.github.io/2025/04/03/video-secene-detect/"/>
    <id>https://caozhaoqi.github.io/2025/04/03/video-secene-detect/</id>
    <published>2025-04-03T06:02:33.000Z</published>
    <updated>2025-11-25T15:05:10.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>一个摄像机连续拍摄的一段视频片段，没有进行中断。一个镜头通常是视频叙事的基本单位。</p><p><strong>2. 镜头识别的意义：</strong></p><ul><li><strong>视频分析和理解：</strong> 镜头识别是视频分析和理解的基础，可以帮助提取视频内容，进行结构化分析，例如场景检测、故事分割等。</li><li><strong>视频检索：</strong> 可以用于基于内容的视频检索，例如查找包含特定对象的镜头。</li><li><strong>视频摘要：</strong> 可以用于生成视频摘要，选取关键镜头来代表视频内容。</li><li><strong>视频编辑：</strong> 方便视频编辑人员对视频进行分割、重组等操作。</li><li><strong>视频监控：</strong> 异常事件检测，行为分析等。</li></ul><p><strong>3. 镜头识别的主要方法：</strong></p><p>镜头识别主要基于分析连续帧之间的变化，通过检测场景边界来识别镜头。常见的方法包括：</p><ul><li><strong>基于阈值的镜头识别：</strong><ul><li><strong>原理：</strong> 通过计算连续帧之间的差异（例如颜色直方图差异、像素差异、边缘差异等），当差异值超过预设的阈值时，则认为发生了镜头切换。</li><li><strong>优点：</strong> 简单快速，易于实现。</li><li><strong>缺点：</strong> 对阈值的选择敏感，容易受到光照变化、运动等因素的影响。</li></ul></li><li><strong>基于统计模型的镜头识别：</strong><ul><li><strong>原理：</strong> 使用统计模型（例如隐马尔可夫模型 HMM）来描述视频帧的特征变化，通过检测模型状态的变化来识别镜头。</li><li><strong>优点：</strong> 对噪声和光照变化具有一定的鲁棒性。</li><li><strong>缺点：</strong> 模型训练需要大量的标注数据，计算复杂度较高。</li></ul></li><li><strong>基于机器学习和深度学习的镜头识别：</strong><ul><li><strong>原理：</strong> 使用机器学习或深度学习模型（例如支持向量机 SVM、卷积神经网络 CNN、循环神经网络 RNN）来学习视频帧的特征，并对镜头边界进行分类。</li><li><strong>优点：</strong> 可以学习复杂的特征表示，具有较高的识别精度。</li><li><strong>缺点：</strong> 需要大量的标注数据进行训练，计算资源需求较高。</li></ul></li></ul><p><strong>4. 具体步骤：</strong></p><ol><li><strong>视频预处理：</strong><ul><li><strong>解码：</strong> 将视频文件解码为帧序列。</li><li><strong>降噪：</strong> 对帧序列进行降噪处理，例如使用高斯滤波或中值滤波。</li><li><strong>调整大小：</strong> 将帧序列调整到统一的大小，以便进行后续处理。</li></ul></li><li><strong>特征提取：</strong>  提取视频帧的特征，用于描述视频内容。常用的特征包括：<ul><li><strong>颜色直方图：</strong>  描述图像的颜色分布。</li><li><strong>灰度共生矩阵 (GLCM)：</strong> 描述图像的纹理特征。</li><li><strong>光流：</strong> 描述图像中物体的运动信息。</li><li><strong>局部二值模式 (LBP)：</strong> 描述图像的局部纹理特征。</li><li><strong>深度学习特征：</strong> 使用预训练的深度学习模型（例如 VGGNet、ResNet）提取图像的特征。</li></ul></li><li><strong>差异计算：</strong>  计算连续帧之间的差异。 常用的差异计算方法包括：<ul><li><strong>欧氏距离：</strong>  计算两个向量之间的距离。</li><li><strong>余弦相似度：</strong> 计算两个向量之间的角度。</li><li><strong>卡方距离：</strong>  计算两个直方图之间的距离。</li></ul></li><li><strong>镜头边界检测：</strong><ul><li><strong>阈值法：</strong>  当差异值超过预设的阈值时，则认为发生了镜头切换。</li><li><strong>机器学习方法：</strong>  使用机器学习模型对镜头边界进行分类。</li></ul></li><li><strong>后处理：</strong><ul><li><strong>合并短镜头：</strong>  将长度小于一定阈值的镜头合并到相邻的镜头中。</li><li><strong>平滑镜头边界：</strong>  对镜头边界进行平滑处理，以提高视频观看体验。</li></ul></li></ol><p><strong>5. 技术细节:</strong></p><ul><li><strong>帧速率（Frame Rate）：</strong> 影响分析的精度和计算成本。高帧速率提供更详细的信息，但也需要更多的计算资源。</li><li><strong>特征选择：</strong> 选择合适的特征对镜头识别的精度至关重要。 例如，对于快速运动的场景，光流特征可能更有效。</li><li><strong>阈值设定：</strong> 阈值的设定需要根据具体的视频内容进行调整。</li><li><strong>深度学习模型的选择：</strong> 选择合适的深度学习模型需要根据具体的应用场景进行考虑。</li></ul><h2 id="实现技术">实现技术</h2><ul><li><strong>OpenCV:</strong>  一个强大的计算机视觉库，提供了图像处理、特征提取、视频分析等功能。</li><li><strong>FFmpeg:</strong>  一个开源的多媒体框架，可以用于视频解码、编码、格式转换等操作。</li><li><strong>Scikit-learn:</strong>  一个流行的机器学习库，提供了各种机器学习算法。</li><li><strong>TensorFlow/PyTorch:</strong>  深度学习框架，可以用于构建和训练深度学习模型。</li><li><strong>PySceneDetect:</strong> 一个专门用于场景分割（即镜头识别）的Python库，它基于OpenCV和NumPy。</li></ul><h2 id="技术选择">技术选择</h2><p><strong>PySceneDetect:</strong></p><ul><li><strong>描述:</strong> PySceneDetect 是一个专门用于场景分割的 Python 库，它构建在 OpenCV 和 NumPy 之上。它提供了多种场景检测算法，包括基于内容的比较（ContentDetector）、阈值检测（ThresholdDetector）等。</li><li><strong>优点:</strong><ul><li>易于使用：提供了简单的 API，方便快速上手。</li><li>多种算法：内置了多种场景检测算法，可以根据视频内容选择合适的算法。</li><li>可定制性：允许自定义场景检测算法。</li><li>文档完善：拥有比较完善的文档。</li></ul></li><li><strong>缺点:</strong><ul><li>性能：对于非常大的视频，可能需要优化性能。</li><li>精度：默认参数可能不适用于所有类型的视频，需要调整参数。</li></ul></li></ul><h2 id="第三方库安装使用">第三方库安装使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scenedetect opencv-python tqdm</span><br></pre></td></tr></table></figure><h3 id="简易demo">简易demo</h3><ul><li>检测视频中的场景切换帧，输出图片与csv文件</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scenedetect --input goldeneye.mp4 detect-adaptive list-scenes save-images</span><br></pre></td></tr></table></figure><h3 id="关于场景切换检测阈值的确认">关于场景切换检测阈值的确认</h3><blockquote><p>例如，对于detect-content，如果默认阈值27没有产生正确的结果，我们可以通过首先生成统计文件来确定适当的阈值：</p></blockquote><blockquote><p>scenedetect --input goldeneye.mp4 --stats goldeneye.stats.csv detect-adaptive<br>然后，我们可以绘制content_val列的值</p></blockquote><ul><li>代码如下：</li></ul><blockquote><p>关键代码展示</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">generate_stats_csv</span>(<span class="params">video_path, output_dir, threshold</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Detects scenes and saves frame statistics (Frame Num, content_val) to a CSV.</span></span><br><span class="line"><span class="string">    Returns True on success, False on failure.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    thread_name = threading.current_thread().name</span><br><span class="line">    video_filename_base = os.path.splitext(os.path.basename(video_path))[<span class="number">0</span>]</span><br><span class="line">    output_csv_path = os.path.join(output_dir, <span class="string">f&quot;<span class="subst">&#123;video_filename_base&#125;</span>_stats.csv&quot;</span>)</span><br><span class="line">    temp_stats_path = os.path.join(output_dir, <span class="string">f&quot;<span class="subst">&#123;video_filename_base&#125;</span>_temp_full_stats.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Processing: <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">    video_manager = <span class="literal">None</span></span><br><span class="line">    stats_manager = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 1. Initialize</span></span><br><span class="line">        video_manager = VideoStreamCv2(video_path)</span><br><span class="line">        stats_manager = StatsManager()</span><br><span class="line">        scene_manager = SceneManager(stats_manager)</span><br><span class="line">        scene_manager.add_detector(ContentDetector(threshold=threshold))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. Get duration</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total_frames = video_manager.duration.get_frames()</span><br><span class="line">            <span class="keyword">if</span> total_frames &lt;= <span class="number">0</span>:</span><br><span class="line">                logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;os.path.basename(video_path)&#125;</span> reported 0 frames. Skipping.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> info_err:</span><br><span class="line">             logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Error getting video duration for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;info_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. Run detection</span></span><br><span class="line">        logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Running detect_scenes for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        scene_manager.detect_scenes(frame_source=video_manager)</span><br><span class="line">        logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] detect_scenes finished for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. Save *full* statistics temporarily by passing a FILE HANDLE</span></span><br><span class="line">        logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Saving full stats to temporary file: <span class="subst">&#123;temp_stats_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># --- MODIFIED PART ---</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(temp_stats_path, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                 stats_manager.save_to_csv(f) <span class="comment"># Pass the open file handle &#x27;f&#x27; directly</span></span><br><span class="line">            <span class="comment"># ---------------------</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(temp_stats_path):</span><br><span class="line">                 logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] StatsManager failed to create the temporary stats file: <span class="subst">&#123;temp_stats_path&#125;</span>&quot;</span>)</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> te:</span><br><span class="line">             <span class="comment"># Catch if even passing a handle is wrong</span></span><br><span class="line">             logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] TypeError calling save_to_csv for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>. API mismatch. Error: <span class="subst">&#123;te&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> save_err:</span><br><span class="line">             logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Error saving temporary stats file <span class="subst">&#123;temp_stats_path&#125;</span>: <span class="subst">&#123;save_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. Read the temp stats CSV and extract desired columns</span></span><br><span class="line">        <span class="comment"># (Keep this part the same as the previous version)</span></span><br><span class="line">        logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Reading temporary stats file: <span class="subst">&#123;temp_stats_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            stats_df = pd.read_csv(temp_stats_path, skipinitialspace=<span class="literal">True</span>)</span><br><span class="line">            stats_df.columns = stats_df.columns.<span class="built_in">str</span>.strip()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> FRAME_NUM_COL <span class="keyword">not</span> <span class="keyword">in</span> stats_df.columns <span class="keyword">or</span> CONTENT_VAL_COL <span class="keyword">not</span> <span class="keyword">in</span> stats_df.columns:</span><br><span class="line">                logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Temporary stats file (<span class="subst">&#123;temp_stats_path&#125;</span>) is missing required columns. Found: <span class="subst">&#123;stats_df.columns.tolist()&#125;</span>. Expected: &#x27;<span class="subst">&#123;FRAME_NUM_COL&#125;</span>&#x27;, &#x27;<span class="subst">&#123;CONTENT_VAL_COL&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">                <span class="comment"># Keep the temp file for inspection if columns are missing</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># Return failure</span></span><br><span class="line"></span><br><span class="line">            output_df = stats_df[[FRAME_NUM_COL, CONTENT_VAL_COL]]</span><br><span class="line">            logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Saving extracted stats to final file: <span class="subst">&#123;output_csv_path&#125;</span>&quot;</span>)</span><br><span class="line">            output_df.to_csv(output_csv_path, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">            logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Successfully generated stats CSV: <span class="subst">&#123;os.path.basename(output_csv_path)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># Return success</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> pd.errors.EmptyDataError:</span><br><span class="line">            logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Temporary stats file was empty: <span class="subst">&#123;temp_stats_path&#125;</span>. No scenes likely detected or error during stats generation.&quot;</span>)</span><br><span class="line">            <span class="comment"># Create an empty output file with correct headers</span></span><br><span class="line">            pd.DataFrame(columns=[FRAME_NUM_COL, CONTENT_VAL_COL]).to_csv(output_csv_path, index=<span class="literal">False</span>)</span><br><span class="line">            logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Created empty stats CSV (as temp was empty): <span class="subst">&#123;os.path.basename(output_csv_path)&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="comment"># Count as processed successfully (empty result)</span></span><br><span class="line">        <span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">             logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Column not found in temporary stats file (<span class="subst">&#123;temp_stats_path&#125;</span>): <span class="subst">&#123;e&#125;</span>. Available columns: <span class="subst">&#123;stats_df.columns.tolist()&#125;</span>&quot;</span>)</span><br><span class="line">             <span class="comment"># Keep the temp file for inspection</span></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Error processing temporary stats file <span class="subst">&#123;temp_stats_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> VideoOpenFailure <span class="keyword">as</span> vf_err:</span><br><span class="line">        logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Failed to open video <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;vf_err&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Error during scene detection/stats generation for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> video_manager <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">hasattr</span>(video_manager, <span class="string">&#x27;_cap&#x27;</span>) <span class="keyword">and</span> video_manager._cap <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(video_manager._cap, <span class="string">&#x27;release&#x27;</span>):</span><br><span class="line">                    video_manager._cap.release()</span><br><span class="line">                <span class="keyword">del</span> video_manager</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> del_e:</span><br><span class="line">                 logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Exception while cleaning up video_manager for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;del_e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Clean up temporary stats file ONLY IF the final CSV was successfully created or was intentionally empty</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;output_df&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">or</span> ( <span class="string">&#x27;stats_df&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> stats_df.empty ): <span class="comment"># Check if processing reached CSV saving/empty handling stage</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;temp_stats_path&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> os.path.exists(temp_stats_path):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    os.remove(temp_stats_path)</span><br><span class="line">                    logger.debug(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Removed temporary stats file: <span class="subst">&#123;temp_stats_path&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                    logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Failed to remove temporary stats file <span class="subst">&#123;temp_stats_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">             <span class="comment"># If processing failed before reading/writing the final CSV, keep the temp file for debugging</span></span><br><span class="line">              <span class="keyword">if</span> <span class="string">&#x27;temp_stats_path&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> os.path.exists(temp_stats_path):</span><br><span class="line">                    logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Keeping temporary stats file due to processing error: <span class="subst">&#123;temp_stats_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... (Rest of the code remains the same: process_video, find_video_files, move_video, main, __main__) ...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">root_dir, dest_dir, num_threads, threshold</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Main function to orchestrate the CSV generation process.&quot;&quot;&quot;</span></span><br><span class="line">    root_dir = os.path.normpath(root_dir)</span><br><span class="line">    dest_dir = os.path.normpath(dest_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure destination directory exists</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(dest_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;Ensured destination directory exists: <span class="subst">&#123;dest_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        logger.critical(<span class="string">f&quot;Failed to create destination directory &#x27;<span class="subst">&#123;dest_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment"># Cannot proceed without output directory</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         logger.critical(<span class="string">f&quot;Unexpected error creating destination directory &#x27;<span class="subst">&#123;dest_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">         <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find video files, excluding any already in the destination</span></span><br><span class="line">    video_files_all = find_video_files(root_dir)</span><br><span class="line">    abs_dest_dir = os.path.abspath(dest_dir)</span><br><span class="line">    video_files = [f <span class="keyword">for</span> f <span class="keyword">in</span> video_files_all <span class="keyword">if</span> <span class="keyword">not</span> os.path.abspath(f).startswith(abs_dest_dir)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(video_files) &lt; <span class="built_in">len</span>(video_files_all):</span><br><span class="line">         logger.warning(<span class="string">f&quot;Filtered out <span class="subst">&#123;<span class="built_in">len</span>(video_files_all) - <span class="built_in">len</span>(video_files)&#125;</span> files potentially inside the destination directory &#x27;<span class="subst">&#123;dest_dir&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files:</span><br><span class="line">        logger.error(<span class="string">f&quot;No valid video files found in &#x27;<span class="subst">&#123;root_dir&#125;</span>&#x27; (excluding destination directory).&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Starting stats CSV generation for <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> videos from &#x27;<span class="subst">&#123;root_dir&#125;</span>&#x27; using <span class="subst">&#123;num_threads&#125;</span> threads.&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">f&quot;Output CSV files will be saved in: <span class="subst">&#123;dest_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start_overall_time = time.time()</span><br><span class="line">    processed_count = <span class="number">0</span></span><br><span class="line">    successful_runs = <span class="number">0</span></span><br><span class="line">    failed_runs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=num_threads, thread_name_prefix=<span class="string">&#x27;StatsGenWorker&#x27;</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># Submit tasks: Pass video path, output dir, and threshold</span></span><br><span class="line">        futures = &#123;executor.submit(generate_stats_csv, video_file, dest_dir, threshold): video_file <span class="keyword">for</span> video_file <span class="keyword">in</span> video_files&#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;All tasks submitted. Waiting for completion...&quot;</span>)</span><br><span class="line">        <span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line">        <span class="comment"># Use tqdm with as_completed for better progress feedback</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> tqdm(as_completed(futures), total=<span class="built_in">len</span>(futures), desc=<span class="string">&quot;Overall Progress&quot;</span>):</span><br><span class="line">            video_file = futures[future] <span class="comment"># Get associated video file</span></span><br><span class="line">            processed_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                success = future.result() <span class="comment"># Get boolean result from generate_stats_csv</span></span><br><span class="line">                <span class="keyword">if</span> success:</span><br><span class="line">                    successful_runs += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    failed_runs += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># Error is already logged within the function</span></span><br><span class="line">                    logger.debug(<span class="string">f&quot;Task for <span class="subst">&#123;os.path.basename(video_file)&#125;</span> completed with failure (logged previously).&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">                <span class="comment"># Catch exceptions that might occur if future.result() itself fails unexpectedly</span></span><br><span class="line">                failed_runs += <span class="number">1</span></span><br><span class="line">                logger.error(<span class="string">f&quot;Unexpected error getting result for <span class="subst">&#123;os.path.basename(video_file)&#125;</span>: <span class="subst">&#123;exc&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    end_overall_time = time.time()</span><br><span class="line">    logger.info(<span class="string">f&quot;Stats CSV generation complete.&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">f&quot;Summary: <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> videos submitted. <span class="subst">&#123;successful_runs&#125;</span> processed successfully, <span class="subst">&#123;failed_runs&#125;</span> encountered errors.&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">f&quot;Total execution time: <span class="subst">&#123;end_overall_time - start_overall_time:<span class="number">.2</span>f&#125;</span> seconds.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># --- Initial Checks ---</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_ffmpeg():</span><br><span class="line">        <span class="comment"># Optional: Decide whether to proceed without FFmpeg warning or exit</span></span><br><span class="line">        <span class="comment"># sys.exit(1)</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    check_acceleration_support()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Setup Directories ---</span></span><br><span class="line">    root_directory = <span class="string">r&#x27;/Volumes/shared/标注/影视&#x27;</span></span><br><span class="line">    destination_directory = <span class="string">r&#x27;./data&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use defaults if not using argparse</span></span><br><span class="line">    detection_threshold = DEFAULT_THRESHOLD</span><br><span class="line">    thread_count = DEFAULT_NUM_THREADS</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Directory Validation ---</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(root_directory):</span><br><span class="line">        logger.critical(<span class="string">f&quot;Input root directory &#x27;<span class="subst">&#123;root_directory&#125;</span>&#x27; not found or is not a directory.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Destination directory creation is handled in main()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Run Main Process ---</span></span><br><span class="line">    main(root_directory, destination_directory, thread_count, detection_threshold)</span><br></pre></td></tr></table></figure><h2 id="测试demo">测试demo</h2><blockquote><p>使用 PySceneDetect 快速分析视频 并输出各种参数到csv</p></blockquote> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查硬件加速支持</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_scenes</span>(<span class="params">video_path, threshold=<span class="number">30.0</span>, downscale_width=<span class="number">640</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Detects scene changes in a video using PySceneDetect with VideoStreamCv2.&quot;&quot;&quot;</span></span><br><span class="line">    video_manager = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 1. 初始化</span></span><br><span class="line">        logging.debug(<span class="string">f&quot;Initializing VideoStreamCv2 for: <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        video_manager = VideoStreamCv2(video_path)</span><br><span class="line">        logging.info(<span class="string">f&quot;Initialized VideoStreamCv2 for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        stats_manager = StatsManager()</span><br><span class="line">        scene_manager = SceneManager(stats_manager)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 添加场景检测器</span></span><br><span class="line">        scene_manager.add_detector(ContentDetector(threshold=threshold))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 获取视频信息 for Progress Bar</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total_frames = video_manager.duration.get_frames()</span><br><span class="line">            logging.debug(<span class="string">f&quot;Video Info: Total Frames=<span class="subst">&#123;total_frames&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> info_err:</span><br><span class="line">             logging.error(<span class="string">f&quot;Error getting video info (duration) for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;info_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">if</span> video_manager <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="keyword">del</span> video_manager</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">None</span>, video_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_frames &lt;= <span class="number">0</span>:</span><br><span class="line">             logging.warning(<span class="string">f&quot;Video <span class="subst">&#123;os.path.basename(video_path)&#125;</span> reported 0 frames. Skipping processing.&quot;</span>)</span><br><span class="line">             <span class="keyword">if</span> video_manager <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>: <span class="keyword">del</span> video_manager</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>, video_path</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4. 设置(简化的)进度条并执行检测</span></span><br><span class="line">        <span class="comment"># The frame-by-frame callback doesn&#x27;t work with this version.</span></span><br><span class="line">        <span class="comment"># The tqdm bar will show progress only after detect_scenes finishes for the file.</span></span><br><span class="line">        <span class="keyword">with</span> tqdm(total=total_frames, desc=<span class="string">f&quot;Processing <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>, unit=<span class="string">&quot;frame&quot;</span>, leave=<span class="literal">False</span>) <span class="keyword">as</span> pbar:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 5. 执行场景检测 - Pass the video_manager as frame_source</span></span><br><span class="line">            scene_manager.detect_scenes(frame_source=video_manager)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Manually update pbar to 100% after completion if needed,</span></span><br><span class="line">            <span class="comment"># though tqdm might do this automatically on exit from &#x27;with&#x27;.</span></span><br><span class="line">            pbar.n = total_frames <span class="comment"># Set progress to max</span></span><br><span class="line">            pbar.refresh()       <span class="comment"># Refresh display</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 6. 获取结果</span></span><br><span class="line">        scene_list = scene_manager.get_scene_list()</span><br><span class="line"></span><br><span class="line">        logging.info(<span class="string">f&quot;Detected <span class="subst">&#123;<span class="built_in">len</span>(scene_list)&#125;</span> scenes in <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 7. 资源管理</span></span><br><span class="line">        <span class="comment"># del video_manager</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(scene_list), video_path</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> cv2.error <span class="keyword">as</span> cv_err:</span><br><span class="line">         logging.error(<span class="string">f&quot;OpenCV error processing <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;cv_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span>, video_path</span><br><span class="line">    <span class="keyword">except</span> VideoOpenFailure <span class="keyword">as</span> vf_err:</span><br><span class="line">         logging.error(<span class="string">f&quot;Failed to open video <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;vf_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span>, video_path</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;Generic error processing <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, video_path</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;video_manager&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> video_manager <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">             <span class="keyword">try</span>: <span class="keyword">del</span> video_manager</span><br><span class="line">             <span class="keyword">except</span> Exception: <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ... (Keep process_video, find_video_files, move_video, main, __main__ block the same) ...</span></span><br><span class="line"><span class="comment"># ... [Rest of the code] ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_video</span>(<span class="params">video_path, threshold, dest_dir, downscale_width</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理单个视频，捕获异常, 并移动视频&quot;&quot;&quot;</span></span><br><span class="line">    thread_name = threading.current_thread().name</span><br><span class="line">    logging.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Starting processing for: <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    num_scenes = <span class="literal">None</span>  <span class="comment"># Initialize</span></span><br><span class="line">    processed_video_path = video_path  <span class="comment"># Assume original path initially</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        num_scenes, processed_video_path = detect_scenes(video_path, threshold, downscale_width)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if detect_scenes returned None for path (shouldn&#x27;t happen with current logic, but defensive)</span></span><br><span class="line">        <span class="keyword">if</span> processed_video_path <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            logging.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video path became None during processing for <span class="subst">&#123;video_path&#125;</span>. Skipping move.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># Explicitly return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> num_scenes &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="comment"># Check if the source file still exists before moving (it might fail during processing)</span></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(processed_video_path):</span><br><span class="line">                move_video(processed_video_path, dest_dir)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logging.warning(</span><br><span class="line">                    <span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Source file <span class="subst">&#123;processed_video_path&#125;</span> not found after processing. Cannot move.&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> num_scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># Includes case where num_scenes is 0 because no frames were processed</span></span><br><span class="line">            logging.info(</span><br><span class="line">                <span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;os.path.basename(processed_video_path)&#125;</span> is single scene or failed processing. No move needed.&quot;</span>)</span><br><span class="line">        <span class="comment"># else case (num_scenes is None) is implicitly handled by the warning below</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># This case means detect_scenes failed and returned None for num_scenes</span></span><br><span class="line">            logging.warning(</span><br><span class="line">                <span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;os.path.basename(processed_video_path)&#125;</span> failed processing entirely. No move needed.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># Catch any unexpected error during the move decision or logging</span></span><br><span class="line">        logging.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Top-level error in process_video for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>,</span><br><span class="line">                      exc_info=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        status = <span class="string">&quot;failed&quot;</span> <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">f&quot;<span class="subst">&#123;num_scenes&#125;</span> scenes&quot;</span></span><br><span class="line">        logging.info(</span><br><span class="line">            <span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Finished processing <span class="subst">&#123;os.path.basename(video_path)&#125;</span> (<span class="subst">&#123;status&#125;</span>) in <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="场景切割">场景切割</h2><ul><li>根据视频内场景切换 切割视频</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_scenes</span>(<span class="params">video_path, threshold=<span class="number">30.0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Detects scene changes in a video using PySceneDetect with VideoStreamCv2.&quot;&quot;&quot;</span></span><br><span class="line">    video_manager = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.debug(<span class="string">f&quot;Initializing VideoStreamCv2 for: <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        video_manager = VideoStreamCv2(video_path)</span><br><span class="line">        logger.info(<span class="string">f&quot;Initialized VideoStreamCv2 for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        stats_manager = StatsManager()</span><br><span class="line">        scene_manager = SceneManager(stats_manager)</span><br><span class="line">        scene_manager.add_detector(ContentDetector(threshold=threshold))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            total_frames = video_manager.duration.get_frames()</span><br><span class="line">            <span class="comment"># base_timecode = video_manager.base_timecode # No longer needed for get_scene_list</span></span><br><span class="line">            logging.debug(<span class="string">f&quot;Video Info: Total Frames=<span class="subst">&#123;total_frames&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> info_err:</span><br><span class="line">             logger.error(<span class="string">f&quot;Error getting video info (duration) for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;info_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">None</span>, video_path, <span class="literal">None</span> <span class="comment"># Return None for scene list</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total_frames &lt;= <span class="number">0</span>:</span><br><span class="line">             logger.warning(<span class="string">f&quot;Video <span class="subst">&#123;os.path.basename(video_path)&#125;</span> reported 0 frames. Skipping processing.&quot;</span>)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>, video_path, [] <span class="comment"># Return 0 scenes, empty list</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Execute scene detection (no progress bar here as callback wasn&#x27;t reliable)</span></span><br><span class="line">        logger.debug(<span class="string">f&quot;Starting scene detection for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        scene_manager.detect_scenes(frame_source=video_manager)</span><br><span class="line">        logger.debug(<span class="string">f&quot;Finished scene detection for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Get scene list (without base_timecode)</span></span><br><span class="line">        scene_list = scene_manager.get_scene_list()</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;Detected <span class="subst">&#123;<span class="built_in">len</span>(scene_list)&#125;</span> scenes in <span class="subst">&#123;os.path.basename(video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Return scene count, path, and the actual scene list for splitting</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(scene_list), video_path, scene_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> cv2.error <span class="keyword">as</span> cv_err:</span><br><span class="line">         logger.error(<span class="string">f&quot;OpenCV error processing <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;cv_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span>, video_path, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> VideoOpenFailure <span class="keyword">as</span> vf_err:</span><br><span class="line">         logger.error(<span class="string">f&quot;Failed to open video <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;vf_err&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">None</span>, video_path, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Generic error during scene detection for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, video_path, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">         <span class="comment"># Ensure the video file is closed/released by deleting the reference</span></span><br><span class="line">         <span class="keyword">if</span> <span class="string">&#x27;video_manager&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>() <span class="keyword">and</span> video_manager <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">             <span class="keyword">try</span>:</span><br><span class="line">                 <span class="comment"># Explicitly call internal capture release if possible</span></span><br><span class="line">                 <span class="keyword">if</span> <span class="built_in">hasattr</span>(video_manager, <span class="string">&#x27;_cap&#x27;</span>) <span class="keyword">and</span> video_manager._cap <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(video_manager._cap, <span class="string">&#x27;release&#x27;</span>):</span><br><span class="line">                     video_manager._cap.release()</span><br><span class="line">                 <span class="keyword">del</span> video_manager</span><br><span class="line">             <span class="keyword">except</span> Exception <span class="keyword">as</span> del_e:</span><br><span class="line">                 logger.warning(<span class="string">f&quot;Exception while cleaning up video_manager for <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;del_e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split_video_scene</span>(<span class="params">input_path, output_path, start_timecode_str, end_timecode_str</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Splits a video segment using FFmpeg without re-encoding.&quot;&quot;&quot;</span></span><br><span class="line">    thread_name = threading.current_thread().name</span><br><span class="line">    logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Splitting scene: <span class="subst">&#123;os.path.basename(output_path)&#125;</span> (<span class="subst">&#123;start_timecode_str&#125;</span> -&gt; <span class="subst">&#123;end_timecode_str&#125;</span>)&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ensure output directory exists</span></span><br><span class="line">    os.makedirs(os.path.dirname(output_path), exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Construct FFmpeg command</span></span><br><span class="line">    <span class="comment"># Using -ss after -i and -copyts is generally more frame-accurate for splitting with -c copy</span></span><br><span class="line">    command = [</span><br><span class="line">        <span class="string">&#x27;ffmpeg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;-i&#x27;</span>, <span class="built_in">str</span>(input_path),         <span class="comment"># Input file</span></span><br><span class="line">        <span class="string">&#x27;-ss&#x27;</span>, start_timecode_str,     <span class="comment"># Start time</span></span><br><span class="line">        <span class="string">&#x27;-to&#x27;</span>, end_timecode_str,       <span class="comment"># End time</span></span><br><span class="line">        <span class="string">&#x27;-copyts&#x27;</span>,                     <span class="comment"># Copy timestamps</span></span><br><span class="line">        <span class="string">&#x27;-avoid_negative_ts&#x27;</span>, <span class="string">&#x27;make_zero&#x27;</span>, <span class="comment"># Handle timestamp issues</span></span><br><span class="line">        <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>,                  <span class="comment"># Copy codecs (no re-encoding)</span></span><br><span class="line">        <span class="string">&#x27;-y&#x27;</span>,                          <span class="comment"># Overwrite output file if it exists</span></span><br><span class="line">        <span class="built_in">str</span>(output_path)               <span class="comment"># Output file</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Run FFmpeg command</span></span><br><span class="line">        <span class="comment"># creationflags prevents console window popup on Windows</span></span><br><span class="line">        process = subprocess.run(</span><br><span class="line">            command,</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.PIPE,</span><br><span class="line">            check=<span class="literal">True</span>, <span class="comment"># Raise CalledProcessError if ffmpeg returns non-zero exit code</span></span><br><span class="line">            creationflags=subprocess.CREATE_NO_WINDOW <span class="keyword">if</span> platform.system() == <span class="string">&quot;Windows&quot;</span> <span class="keyword">else</span> <span class="number">0</span>,</span><br><span class="line">            encoding=<span class="string">&#x27;utf-8&#x27;</span>, <span class="comment"># Capture output as text</span></span><br><span class="line">            errors=<span class="string">&#x27;replace&#x27;</span> <span class="comment"># Handle potential decoding errors in ffmpeg output</span></span><br><span class="line">        )</span><br><span class="line">        logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Successfully split: <span class="subst">&#123;os.path.basename(output_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># logger.debug(f&quot;FFmpeg stdout:\n&#123;process.stdout&#125;&quot;) # Usually empty for -c copy</span></span><br><span class="line">        <span class="comment"># logger.debug(f&quot;FFmpeg stderr:\n&#123;process.stderr&#125;&quot;) # Contains progress/info</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] FFmpeg failed for <span class="subst">&#123;os.path.basename(output_path)&#125;</span>.&quot;</span>)</span><br><span class="line">        logger.error(<span class="string">f&quot;  Command: <span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(command)&#125;</span>&quot;</span>) <span class="comment"># Log the command for easier debugging</span></span><br><span class="line">        logger.error(<span class="string">f&quot;  Return Code: <span class="subst">&#123;e.returncode&#125;</span>&quot;</span>)</span><br><span class="line">        logger.error(<span class="string">f&quot;  Stderr:\n<span class="subst">&#123;e.stderr&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># Optionally log stdout too: logger.error(f&quot;  Stdout:\n&#123;e.stdout&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.critical(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] FFmpeg command not found during split. Ensure FFmpeg is installed and in PATH.&quot;</span>)</span><br><span class="line">        <span class="comment"># No point continuing if ffmpeg isn&#x27;t found for any split</span></span><br><span class="line">        <span class="keyword">raise</span> <span class="comment"># Re-raise to potentially stop the whole process</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Unexpected error splitting <span class="subst">&#123;os.path.basename(output_path)&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_video</span>(<span class="params">video_path, threshold, base_dest_dir, originals_dir, downscale_width</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Detects scenes, splits video if multiple scenes are found, and moves original.&quot;&quot;&quot;</span></span><br><span class="line">    thread_name = threading.current_thread().name</span><br><span class="line">    base_name = os.path.splitext(os.path.basename(video_path))[<span class="number">0</span>]</span><br><span class="line">    file_ext = os.path.splitext(video_path)[<span class="number">1</span>]</span><br><span class="line">    logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Starting processing for: <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span>&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    split_success_count = <span class="number">0</span></span><br><span class="line">    split_fail_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        num_scenes, _, scene_list = detect_scenes(video_path, threshold) <span class="comment"># Get scene_list now</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span> failed scene detection. Skipping.&quot;</span>)</span><br><span class="line">            <span class="comment"># Optionally move failed files to a specific error directory</span></span><br><span class="line">            <span class="keyword">return</span> <span class="comment"># Stop processing this file</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num_scenes &lt;= <span class="number">1</span>:</span><br><span class="line">            logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span> has <span class="subst">&#123;num_scenes&#125;</span> scene(s). No splitting needed.&quot;</span>)</span><br><span class="line">            <span class="comment"># Decide if you want to move single-scene videos somewhere else or leave them</span></span><br><span class="line">            <span class="comment"># Example: move_video(video_path, os.path.join(base_dest_dir, &quot;single_scene&quot;))</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Video <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span> has <span class="subst">&#123;num_scenes&#125;</span> scenes. Starting split...&quot;</span>)</span><br><span class="line">            <span class="comment"># Create a subdirectory for this video&#x27;s scenes</span></span><br><span class="line">            video_scene_dir = os.path.join(base_dest_dir, base_name)</span><br><span class="line">            os.makedirs(video_scene_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i, (start_tc, end_tc) <span class="keyword">in</span> <span class="built_in">enumerate</span>(scene_list):</span><br><span class="line">                scene_num = i + <span class="number">1</span></span><br><span class="line">                output_filename = <span class="string">f&quot;<span class="subst">&#123;base_name&#125;</span>_scene_<span class="subst">&#123;scene_num:03d&#125;</span><span class="subst">&#123;file_ext&#125;</span>&quot;</span></span><br><span class="line">                output_filepath = os.path.join(video_scene_dir, output_filename)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Use get_timecode() for FFmpeg compatible strings</span></span><br><span class="line">                start_str = start_tc.get_timecode()</span><br><span class="line">                end_str = end_tc.get_timecode()</span><br><span class="line"></span><br><span class="line">                success = split_video_scene(video_path, output_filepath, start_str, end_str)</span><br><span class="line">                <span class="keyword">if</span> success:</span><br><span class="line">                    split_success_count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    split_fail_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># After attempting all splits, move the original file</span></span><br><span class="line">            <span class="keyword">if</span> split_fail_count == <span class="number">0</span> <span class="keyword">and</span> split_success_count &gt; <span class="number">0</span>: <span class="comment"># Only move original if all splits succeeded</span></span><br><span class="line">                logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] All <span class="subst">&#123;split_success_count&#125;</span> scenes split successfully for <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span>. Moving original.&quot;</span>)</span><br><span class="line">                move_video(video_path, originals_dir)</span><br><span class="line">            <span class="keyword">elif</span> split_success_count &gt; <span class="number">0</span>: <span class="comment"># Some splits succeeded, some failed</span></span><br><span class="line">                logger.warning(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Completed splitting for <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span> with <span class="subst">&#123;split_fail_count&#125;</span> failures out of <span class="subst">&#123;num_scenes&#125;</span>. Original NOT moved.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># All splits failed</span></span><br><span class="line">                logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] All <span class="subst">&#123;num_scenes&#125;</span> split attempts failed for <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span>. Original NOT moved.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Top-level error processing <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        result_summary = <span class="string">f&quot;<span class="subst">&#123;num_scenes&#125;</span> scenes detected&quot;</span> <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&quot;failed detection&quot;</span></span><br><span class="line">        <span class="keyword">if</span> num_scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> num_scenes &gt; <span class="number">1</span>:</span><br><span class="line">             result_summary += <span class="string">f&quot; (<span class="subst">&#123;split_success_count&#125;</span> split OK, <span class="subst">&#123;split_fail_count&#125;</span> split failed)&quot;</span></span><br><span class="line">        logger.info(<span class="string">f&quot;[<span class="subst">&#123;thread_name&#125;</span>] Finished processing <span class="subst">&#123;base_name&#125;</span><span class="subst">&#123;file_ext&#125;</span> (<span class="subst">&#123;result_summary&#125;</span>) in <span class="subst">&#123;end_time - start_time:<span class="number">.2</span>f&#125;</span> seconds.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">root_dir, dest_dir, num_threads=<span class="number">4</span>, threshold=<span class="number">30.0</span>, downscale_width=<span class="number">640</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Main function to process multiple videos in parallel.&quot;&quot;&quot;</span></span><br><span class="line">    root_dir = os.path.normpath(root_dir)</span><br><span class="line">    dest_dir = os.path.normpath(dest_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define directory for processed original files</span></span><br><span class="line">    originals_processed_dir = os.path.join(dest_dir, <span class="string">&quot;originals_processed&quot;</span>)</span><br><span class="line">    os.makedirs(originals_processed_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Filter out files already in the destination or originals directory</span></span><br><span class="line">    video_files_all = find_video_files(root_dir)</span><br><span class="line">    abs_dest_dir = os.path.abspath(dest_dir) <span class="comment"># Includes originals_processed_dir</span></span><br><span class="line">    video_files = [f <span class="keyword">for</span> f <span class="keyword">in</span> video_files_all <span class="keyword">if</span> <span class="keyword">not</span> os.path.abspath(f).startswith(abs_dest_dir)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(video_files) &lt; <span class="built_in">len</span>(video_files_all):</span><br><span class="line">         logger.warning(<span class="string">f&quot;Filtered out <span class="subst">&#123;<span class="built_in">len</span>(video_files_all) - <span class="built_in">len</span>(video_files)&#125;</span> files potentially inside destination subdirectories.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files:</span><br><span class="line">        logger.error(<span class="string">f&quot;No valid video files found in <span class="subst">&#123;root_dir&#125;</span> (excluding destination).&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">f&quot;Starting scene splitting on <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> videos from <span class="subst">&#123;root_dir&#125;</span> using <span class="subst">&#123;num_threads&#125;</span> threads.&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Output segments will be in subfolders under: <span class="subst">&#123;dest_dir&#125;</span>&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Originals (if successfully split) will be moved to: <span class="subst">&#123;originals_processed_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    start_overall_time = time.time()</span><br><span class="line">    processed_count = <span class="number">0</span></span><br><span class="line">    successful_runs = <span class="number">0</span></span><br><span class="line">    failed_runs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor(max_workers=num_threads, thread_name_prefix=<span class="string">&#x27;SceneSplitWorker&#x27;</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = &#123;executor.submit(process_video, video_file, threshold, dest_dir, originals_processed_dir, downscale_width): video_file <span class="keyword">for</span> video_file <span class="keyword">in</span> video_files&#125;</span><br><span class="line"></span><br><span class="line">        logging.info(<span class="string">&quot;All tasks submitted. Waiting for completion...&quot;</span>)</span><br><span class="line">        <span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> as_completed</span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> tqdm(as_completed(futures), total=<span class="built_in">len</span>(futures), desc=<span class="string">&quot;Overall Progress&quot;</span>):</span><br><span class="line">            video_file = futures[future]</span><br><span class="line">            processed_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                future.result() <span class="comment"># Check for exceptions from the thread</span></span><br><span class="line">                successful_runs += <span class="number">1</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">                <span class="comment"># Exception already logged in thread or called functions</span></span><br><span class="line">                failed_runs += <span class="number">1</span></span><br><span class="line">                logging.debug(<span class="string">f&quot;Worker thread for <span class="subst">&#123;os.path.basename(video_file)&#125;</span> failed top-level (already logged).&quot;</span>)</span><br><span class="line"></span><br><span class="line">    end_overall_time = time.time()</span><br><span class="line">    logging.info(<span class="string">f&quot;Scene splitting complete.&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Summary: <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> videos submitted. <span class="subst">&#123;successful_runs&#125;</span> processed without top-level errors, <span class="subst">&#123;failed_runs&#125;</span> encountered errors.&quot;</span>)</span><br><span class="line">    logging.info(<span class="string">f&quot;Total execution time: <span class="subst">&#123;end_overall_time - start_overall_time:<span class="number">.2</span>f&#125;</span> seconds.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># --- CHECK FFMPEG FIRST ---</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_ffmpeg():</span><br><span class="line">        sys.exit(<span class="number">1</span>) <span class="comment"># Exit if FFmpeg is not found</span></span><br><span class="line"></span><br><span class="line">    root_dir = <span class="string">r&quot;/Volumes/shared/标注/影视&quot;</span></span><br><span class="line">    dest_dir = <span class="string">r&quot;/Volumes/shared/0328-1-detect-scene-ret&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Standard directory checks</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root_dir) <span class="keyword">or</span> <span class="keyword">not</span> os.path.isdir(root_dir):</span><br><span class="line">        logging.critical(<span class="string">f&quot;Root directory &#x27;<span class="subst">&#123;root_dir&#125;</span>&#x27; not found or is not a directory.&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.makedirs(dest_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        logging.info(<span class="string">f&quot;Ensured base destination directory exists: <span class="subst">&#123;dest_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">        logging.critical(<span class="string">f&quot;Failed to create base destination directory &#x27;<span class="subst">&#123;dest_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         logging.critical(<span class="string">f&quot;Unexpected error creating destination directory &#x27;<span class="subst">&#123;dest_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">         sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    check_acceleration_support()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Run main process</span></span><br><span class="line">    <span class="comment"># Adjust num_threads, threshold, downscale_width as needed</span></span><br><span class="line">    main(root_dir, dest_dir, num_threads=<span class="number">4</span>, threshold=<span class="number">27.0</span>, downscale_width=<span class="number">640</span>)</span><br></pre></td></tr></table></figure><h2 id="测试结果展示">测试结果展示</h2><blockquote><p>值中的峰值对应于输入视频中的场景中断。在某些情况下，可能需要相应地提高或降低阈值。</p></blockquote><p><img src="/2025/04/03/video-secene-detect/example.png" class="lazyload placeholder" data-srcset="/2025/04/03/video-secene-detect/example.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="see">see</h2><ul><li>1.<a href="https://www.scenedetect.com/cli/#quickstart">https://www.scenedetect.com/cli/#quickstart</a></li><li>2.<a href="https://github.com/Breakthrough/PySceneDetect">https://github.com/Breakthrough/PySceneDetect</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;一个摄像机连续拍摄的一段视频片段，没有进行中断。一个镜头通常是视频叙事的基本单位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 镜头识别的意义：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;视频分析和理解：&lt;/strong&gt; </summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>在ubuntu使用Postfix搭建邮件服务器</title>
    <link href="https://caozhaoqi.github.io/2025/03/26/mail-server-Postfix/"/>
    <id>https://caozhaoqi.github.io/2025/03/26/mail-server-Postfix/</id>
    <published>2025-03-26T06:32:54.000Z</published>
    <updated>2025-11-25T15:05:10.331Z</updated>
    
    <content type="html"><![CDATA[<h1>在ubuntu使用Postfix搭建邮件服务器</h1><blockquote><p>在 Ubuntu 服务器上搭建邮件服务器的教程。 Postfix 作为邮件传输代理 (MTA)，Dovecot 作为邮件投递代理 (MDA)</p></blockquote><p><strong>目标：</strong></p><ul><li>在 Ubuntu 服务器上搭建一个功能完善的邮件服务器。</li><li>支持发送和接收邮件。</li><li>实现基本的安全措施，防止垃圾邮件和未经授权的访问。</li></ul><p><strong>准备工作：</strong></p><ol><li><strong>一台运行 Ubuntu Server 的服务器。</strong> 推荐使用 Ubuntu 20.04 或更高版本。</li><li><strong>具有 <code>sudo</code> 权限的非 root 用户。</strong></li><li><strong>一个域名。</strong> 你需要一个注册的域名，以便设置邮件服务器的 DNS 记录。</li><li><strong>一个静态 IP 地址。</strong> 你的服务器需要一个静态 IP 地址，以便 DNS 记录可以正确解析到你的服务器。</li><li><strong>确保服务器主机名设置正确。</strong> 使用 <code>hostnamectl</code> 命令设置主机名。主机名应该与你的域名或子域名相关。例如，<code>mail.example.com</code>。</li></ol><p><strong>步骤 1：安装 Postfix</strong></p><p>Postfix 是一个流行的、安全的、易于配置的邮件传输代理 (MTA)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install postfix</span><br></pre></td></tr></table></figure><p>在安装过程中，会弹出一个配置窗口。选择 “Internet Site” 并输入你的域名（例如，<code>example.com</code>）。</p><p><strong>步骤 2：配置 Postfix</strong></p><p>编辑 Postfix 的主配置文件 <code>main.cf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postfix/main.cf</span><br></pre></td></tr></table></figure><p>进行以下修改：</p><ul><li><p><strong><code>myhostname</code>：</strong> 设置服务器的主机名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myhostname = mail.example.com</span><br></pre></td></tr></table></figure></li><li><p><strong><code>myorigin</code>：</strong> 设置发送邮件时使用的域名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myorigin = example.com</span><br></pre></td></tr></table></figure></li><li><p><strong><code>mydestination</code>：</strong> 设置服务器接收邮件的域名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mydestination = mail.example.com, example.com, localhost.localdomain, localhost</span><br></pre></td></tr></table></figure></li><li><p><strong><code>mynetworks</code>：</strong> 设置允许通过此服务器发送邮件的网络。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128</span><br></pre></td></tr></table></figure></li><li><p><strong><code>relayhost</code>：</strong> 如果你需要通过另一个邮件服务器发送邮件，请设置此选项。 否则，注释掉或留空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#relayhost =</span><br></pre></td></tr></table></figure></li><li><p><strong><code>inet_interfaces</code>：</strong> 设置 Postfix 监听的网络接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet_interfaces = all</span><br></pre></td></tr></table></figure></li><li><p><strong><code>inet_protocols</code>：</strong> 设置 Postfix 使用的网络协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inet_protocols = all</span><br></pre></td></tr></table></figure></li></ul><p>保存并关闭文件。</p><p><strong>步骤 3：安装 Dovecot</strong></p><p>Dovecot 是一个流行的、安全的邮件投递代理 (MDA)。 它负责将邮件投递到用户的邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install dovecot-core dovecot-imapd dovecot-pop3d</span><br></pre></td></tr></table></figure><p><strong>步骤 4：配置 Dovecot</strong></p><p>配置 Dovecot 以使用 Postfix 进行邮件投递。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/dovecot/dovecot.conf</span><br></pre></td></tr></table></figure><p>取消注释以下行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!include conf.d/10-mail.conf</span><br><span class="line">!include conf.d/10-auth.conf</span><br><span class="line">!include conf.d/10-master.conf</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>编辑 <code>10-mail.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/dovecot/conf.d/10-mail.conf</span><br></pre></td></tr></table></figure><p>设置 <code>mail_location</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail_location = mbox:~/mail:INBOX=/var/mail/%u</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>编辑 <code>10-auth.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/dovecot/conf.d/10-auth.conf</span><br></pre></td></tr></table></figure><p>取消注释 <code>disable_plaintext_auth</code> 选项并将其设置为 <code>no</code>。<strong>（注意：在生产环境中，强烈建议启用 TLS/SSL 加密，并保持 <code>disable_plaintext_auth = yes</code> 以提高安全性。）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable_plaintext_auth = no</span><br></pre></td></tr></table></figure><p>找到 <code>auth_mechanisms</code> 行，并确保它包含 <code>plain</code> 和 <code>login</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth_mechanisms = plain login</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>编辑 <code>10-master.conf</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/dovecot/conf.d/10-master.conf</span><br></pre></td></tr></table></figure><p>找到 <code>service auth</code> 部分，并确保 <code>unix_listener /var/spool/postfix/private/auth</code> 行存在且未注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service auth &#123;</span><br><span class="line">  unix_listener /var/spool/postfix/private/auth &#123;</span><br><span class="line">    mode = 0660</span><br><span class="line">    user = postfix</span><br><span class="line">    group = postfix</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到 <code>service imap-login</code> 和 <code>service pop3-login</code> 部分，确保 <code>inet_listener</code> 选项存在且未注释。</p><p>保存并关闭文件。</p><p><strong>步骤 5：配置 Postfix 以使用 Dovecot 进行身份验证</strong></p><p>编辑 Postfix 的 <code>main.cf</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postfix/main.cf</span><br></pre></td></tr></table></figure><p>添加以下行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">smtpd_sasl_type = dovecot</span><br><span class="line">smtpd_sasl_path = private/auth</span><br><span class="line">smtpd_sasl_auth_enable = yes</span><br><span class="line">smtpd_relay_restrictions = permit_mynetworks,permit_sasl_authenticated,defer_unauth_destination</span><br><span class="line">broken_sasl_auth_clients = yes</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p><strong>步骤 6：设置 DNS 记录</strong></p><p>你需要设置以下 DNS 记录，以便邮件服务器可以正常工作：</p><ul><li><p><strong>A 记录：</strong> 将你的域名或子域名（例如，<code>mail.example.com</code>）指向你的服务器的静态 IP 地址。</p></li><li><p><strong>MX 记录：</strong> 指示邮件服务器的域名。 将 MX 记录指向你的域名或子域名（例如，<code>mail.example.com</code>）。</p></li><li><p><strong>TXT 记录 (SPF)：</strong> SPF 记录用于防止垃圾邮件。 添加一个 TXT 记录，指定允许从你的域名发送邮件的服务器。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v=spf1 mx a ip4:你的服务器IP地址 -all</span><br></pre></td></tr></table></figure></li><li><p><strong>TXT 记录 (DMARC)：</strong> DMARC 记录用于进一步提高邮件安全性。 添加一个 DMARC 记录，指示如何处理未通过 SPF 和 DKIM 检查的邮件。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v=DMARC1; p=none; rua=mailto:postmaster@example.com;</span><br></pre></td></tr></table></figure><p><em>注意：<code>rua=mailto:postmaster@example.com;</code> 这部分是可选的，用于指定接收 DMARC 报告的邮箱。</em></p><p>具体的 DNS 记录设置方法取决于你的域名注册商。</p></li></ul><p><strong>步骤 7：重新启动服务</strong></p><p>重新启动 Postfix 和 Dovecot 服务以应用更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart postfix</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart dovecot</span><br></pre></td></tr></table></figure><p><strong>步骤 8：测试邮件服务器</strong></p><ol><li><strong>创建用户:</strong> 创建一个系统用户用于邮件测试</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> adduser testuser</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>发送邮件:</strong> 使用 <code>mail</code> 命令发送邮件。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test email.&quot;</span> | mail -s <span class="string">&quot;Test Email&quot;</span> testuser@example.com</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>接收邮件:</strong> 使用 <code>dovecot</code> 提供的工具或者 <code>mutt</code> 命令来接收邮件。 首先安装 <code>mutt</code>:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mutt</span><br></pre></td></tr></table></figure><p>然后运行 <code>mutt</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutt -f /var/mail/testuser</span><br></pre></td></tr></table></figure><p>你应该能看到你发送的测试邮件。</p><p><strong>步骤 9：安全加固 (重要!)</strong></p><ul><li><p><strong>启用 TLS/SSL 加密：</strong> 使用 Let’s Encrypt 获取免费的 TLS/SSL 证书，并配置 Postfix 和 Dovecot 以使用加密连接。 这可以保护你的邮件在传输过程中不被窃听。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install certbot python3-certbot-nginx</span><br><span class="line"><span class="built_in">sudo</span> certbot --nginx -d mail.example.com</span><br></pre></td></tr></table></figure><p>然后，编辑 <code>main.cf</code> 和 <code>10-ssl.conf</code> 文件以配置 TLS/SSL 加密。</p></li><li><p><strong>配置防火墙：</strong> 使用 <code>ufw</code> 防火墙，只允许必要的端口（例如，25, 143, 993, 587）通过。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ufw allow 25</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 143</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 993</span><br><span class="line"><span class="built_in">sudo</span> ufw allow 587</span><br><span class="line"><span class="built_in">sudo</span> ufw <span class="built_in">enable</span></span><br></pre></td></tr></table></figure></li><li><p><strong>安装和配置 Fail2ban：</strong> Fail2ban 可以自动阻止尝试暴力破解你的服务器的 IP 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install fail2ban</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /etc/fail2ban/jail.conf /etc/fail2ban/jail.local</span><br><span class="line"><span class="built_in">sudo</span> nano /etc/fail2ban/jail.local</span><br></pre></td></tr></table></figure><p>编辑 <code>jail.local</code> 文件，启用对 Postfix 和 Dovecot 的保护。</p></li><li><p><strong>定期更新系统：</strong> 保持你的 Ubuntu 服务器更新到最新版本，以修补安全漏洞。</p></li></ul><p><strong>步骤 10：防止垃圾邮件</strong></p><ul><li><strong>设置反向 DNS (PTR) 记录：</strong> 确保你的服务器 IP 地址具有正确的反向 DNS 记录。 这可以帮助验证你的服务器是否是一个合法的邮件服务器。 联系你的服务器提供商设置 PTR 记录。</li><li><strong>使用 DKIM：</strong> DKIM（DomainKeys Identified Mail）是一种电子邮件身份验证方法，允许你的邮件服务器对发出的邮件进行数字签名。</li><li><strong>使用 DMARC：</strong> DMARC（Domain-based Message Authentication, Reporting &amp; Conformance）是一种电子邮件身份验证策略，允许你指定如何处理未通过 SPF 和 DKIM 检查的邮件。</li></ul><p><strong>注意事项：</strong></p><ul><li><strong>安全性：</strong> 设置邮件服务器需要非常重视安全性。 请务必采取所有必要的安全措施，以防止垃圾邮件、网络钓鱼和其他恶意活动。</li><li><strong>可送达性：</strong> 确保你的邮件服务器符合电子邮件发送的最佳实践，以提高邮件的可送达性。 这包括设置正确的 DNS 记录、使用 DKIM 和 DMARC，以及避免发送垃圾邮件。</li><li><strong>监控：</strong> 持续监控你的邮件服务器的性能和安全状况。 检查日志文件，以便及时发现和解决任何问题。</li><li>**IP信誉：**保持IP信誉良好对于邮件的成功发送至关重要，务必遵守发送规则和避免发送垃圾邮件，否则你的邮件可能被标记为垃圾邮件。</li></ul><h2 id="客户端使用">客户端使用</h2><p>在本地测试邮件服务器的可用性，是指在你的邮件服务器搭建好后，在不涉及到外部网络的情况下，验证它是否能够正确地发送和接收邮件。 这通常在你服务器搭建的初期阶段进行，用于排查基本配置问题。</p><p>以下是几种在本地测试邮件服务器可用性的方法：</p><p><strong>方法 1：使用 <code>mail</code> 命令（简单快速）</strong></p><p><code>mail</code> 命令是一个简单的命令行邮件客户端，适用于快速测试。</p><ol><li><p><strong>确保 <code>mail</code> 命令已安装：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install mailutils</span><br></pre></td></tr></table></figure></li><li><p><strong>发送邮件到本地用户：</strong><br>假设你的系统上有一个用户名为 <code>testuser</code>，并且邮件服务器配置了域名 <code>example.com</code>，你可以尝试向 <code>testuser@example.com</code> 发送邮件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is a test email.&quot;</span> | mail -s <span class="string">&quot;Test Email&quot;</span> testuser@example.com</span><br></pre></td></tr></table></figure></li><li><p><strong>检查本地用户的邮箱：</strong></p><p>本地用户的邮箱通常位于 <code>/var/mail/&lt;用户名&gt;</code>。 使用 <code>mutt</code> 或者直接查看文件内容：</p><ul><li><p><strong>使用 <code>mutt</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mutt  <span class="comment"># 如果没有安装</span></span><br><span class="line">mutt -f /var/mail/testuser</span><br></pre></td></tr></table></figure></li><li><p><strong>直接查看文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cat</span> /var/mail/testuser</span><br></pre></td></tr></table></figure></li></ul><p>如果邮件服务器配置正确，你应该能在 <code>testuser</code> 的邮箱中看到你发送的测试邮件。</p></li></ol><p><strong>方法 2：使用 <code>swaks</code> 命令（更详细的测试）</strong></p><p><code>swaks</code> (Swiss Army Knife for SMTP) 是一个更强大的命令行 SMTP 测试工具。 它可以让你更详细地控制邮件发送过程，并检查服务器的响应。</p><ol><li><p><strong>安装 <code>swaks</code>：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install swaks</span><br></pre></td></tr></table></figure></li><li><p><strong>发送邮件并检查响应：</strong></p><p>使用 <code>swaks</code> 命令发送邮件，并检查服务器的响应：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swaks --to testuser@example.com --from youruser@example.com --server localhost --header <span class="string">&quot;Subject: Test Email from Swaks&quot;</span> --body <span class="string">&quot;This is a test email from swaks.&quot;</span> --verbose</span><br></pre></td></tr></table></figure><ul><li><code>--to</code>：收件人地址。</li><li><code>--from</code>：发件人地址（必须是邮件服务器允许发送的地址）。</li><li><code>--server</code>：邮件服务器地址 (localhost 表示本地服务器)。</li><li><code>--header</code>：邮件头部信息 (例如，主题)。</li><li><code>--body</code>：邮件正文。</li><li><code>--verbose</code>：显示详细的发送过程和服务器响应。</li></ul><p>检查 <code>swaks</code> 的输出，确保服务器返回了 “250 OK” 或类似的成功代码。 如果出现错误，可以根据错误信息排查问题。</p></li></ol><p><strong>方法 3：使用本地邮件客户端（例如 Thunderbird）</strong></p><p>如果你的系统上安装了图形界面的邮件客户端 (例如 Thunderbird)，你可以配置它来连接到本地邮件服务器，并发送和接收邮件。</p><ol><li><p><strong>配置邮件客户端：</strong></p><ul><li><strong>账户类型：</strong> 手动配置账户。</li><li><strong>收件服务器 (IMAP/POP3)：</strong><ul><li>服务器地址：<code>localhost</code> 或 <code>127.0.0.1</code></li><li>端口：143 (IMAP) 或 110 (POP3) - 如果启用了 SSL/TLS，则使用 993 (IMAPS) 或 995 (POP3S)</li><li>安全连接：根据你的服务器配置选择 “STARTTLS” 或 “SSL/TLS”。 如果你没有启用 TLS/SSL，则选择 “无加密”。</li><li>身份验证方法：选择 “普通密码” 或 “加密密码”。</li></ul></li><li><strong>发件服务器 (SMTP)：</strong><ul><li>服务器地址：<code>localhost</code> 或 <code>127.0.0.1</code></li><li>端口：25 或 587 (如果使用 STARTTLS) - 如果启用了 SSL/TLS，则使用 465 (SMTPS)</li><li>安全连接：根据你的服务器配置选择 “STARTTLS” 或 “SSL/TLS”。 如果你没有启用 TLS/SSL，则选择 “无加密”。</li><li>身份验证方法：选择 “普通密码” 或 “加密密码”。</li><li>用户名：必须设置为可用的用户，设置需要发送账号和用户密码</li></ul></li></ul></li><li><p><strong>发送和接收邮件：</strong><br>使用邮件客户端发送邮件到本地用户（例如，<code>testuser@example.com</code>），并检查是否能够成功接收。</p></li></ol><p><strong>方法 4：检查邮件日志</strong></p><p>无论使用哪种方法测试，都应该检查邮件服务器的日志文件，以了解邮件的发送和接收情况。</p><ul><li><strong>Postfix 日志：</strong> <code>/var/log/mail.log</code> 或 <code>/var/log/maillog</code></li><li><strong>Dovecot 日志：</strong> <code>/var/log/dovecot.log</code></li></ul><h2 id="可视化注册与使用方案">可视化注册与使用方案</h2><p>在 Ubuntu 服务器上搭建邮件服务器后，并不能直接“图形化注册邮箱”。 上述教程搭建的是邮件服务器的底层基础，需要手动创建 Linux 系统用户，这些用户才能通过 IMAP/POP3 等协议访问邮件。 如果你想要提供一种“图形化注册邮箱”的体验，你需要额外的软件来管理邮箱账户，并提供一个 Web 界面供用户注册和管理他们的邮箱。</p><p>以下是一些可行的方案，它们都需要安装额外的软件，并进行配置。</p><p><strong>方案 1：使用 iRedMail (推荐)</strong></p><p>iRedMail 是一个非常流行的、开源的邮件服务器解决方案，它提供了一个 Web 界面，用于管理邮箱、用户和域名。 iRedMail 可以自动化配置 Postfix、Dovecot、Roundcube Webmail 等组件，并提供了一个易于使用的管理界面。</p><ol><li><p><strong>下载 iRedMail 安装脚本：</strong><br>访问 <a href="https://www.iredmail.org/">https://www.iredmail.org/</a> 下载最新的 iRedMail 安装脚本。</p></li><li><p><strong>运行安装脚本：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzf iRedMail-x.y.z.tar.gz  <span class="comment"># 解压下载的压缩包</span></span><br><span class="line"><span class="built_in">cd</span> iRedMail-x.y.z</span><br><span class="line"><span class="built_in">sudo</span> bash iRedMail.sh</span><br></pre></td></tr></table></figure><p>按照安装脚本的提示进行操作。 你需要设置管理员密码、选择数据库类型、设置域名等。</p></li><li><p><strong>访问 iRedMail Web 管理界面：</strong><br>安装完成后，访问 iRedMail Web 管理界面。 界面地址通常是 <code>https://你的服务器IP地址/iredadmin/</code> 或 <code>https://你的域名/iredadmin/</code>。</p></li><li><p><strong>使用 Web 界面创建邮箱账户：</strong><br>使用管理员账户登录 iRedMail Web 管理界面，然后你可以创建新的邮箱账户，设置密码等。</p></li><li><p><strong>让用户访问Web邮箱</strong></p><p>iRedMail 集成了 Roundcube Webmail。 用户可以使用浏览器访问他们的邮箱，地址通常是<code>https://你的服务器IP地址/mail/</code> 或 <code>https://你的域名/mail/</code>。</p></li></ol><p><strong>方案 2：使用 Mail-in-a-Box</strong></p><p>Mail-in-a-Box 是另一个易于使用的邮件服务器解决方案，旨在简化邮件服务器的设置和管理。 它也提供了一个 Web 界面，用于管理邮箱、用户和域名。</p><ol><li><p><strong>下载 Mail-in-a-Box 安装脚本：</strong><br>访问 <a href="https://mailinabox.email/">https://mailinabox.email/</a> 获取最新的安装说明。</p></li><li><p><strong>运行安装脚本：</strong><br>按照 Mail-in-a-Box 的安装说明进行操作。 安装过程相对简单，会自动配置所需的组件。</p></li><li><p><strong>访问 Mail-in-a-Box Web 管理界面：</strong><br>安装完成后，访问 Mail-in-a-Box Web 管理界面。</p></li><li><p><strong>使用 Web 界面创建邮箱账户：</strong><br>使用管理员账户登录 Mail-in-a-Box Web 管理界面，然后你可以创建新的邮箱账户。</p></li></ol><p><strong>方案 3：手动配置 Roundcube Webmail 或 Rainloop (更复杂)</strong></p><p>如果你不想使用完整的邮件服务器解决方案，你可以手动安装和配置 Roundcube Webmail 或 Rainloop Webmail，并将其与你的 Postfix 和 Dovecot 邮件服务器集成。</p><ol><li><p><strong>安装 Web 服务器：</strong><br>首先，你需要安装一个 Web 服务器（例如，Apache 或 Nginx）。</p></li><li><p><strong>安装 PHP：</strong><br>你需要安装 PHP 和一些必要的 PHP 扩展。</p></li><li><p><strong>下载和安装 Roundcube Webmail 或 Rainloop：</strong><br>从官方网站下载 Roundcube Webmail 或 Rainloop 的最新版本，并将其解压到你的 Web 服务器的文档根目录中。</p></li><li><p><strong>配置 Roundcube Webmail 或 Rainloop：</strong><br>按照 Roundcube Webmail 或 Rainloop 的安装说明进行配置。 你需要设置数据库连接信息、IMAP 和 SMTP 服务器地址、身份验证方法等。</p></li><li><p><strong>创建 Web 界面用于注册用户：</strong><br>开发自己的Web界面，用于添加用户到数据库中。</p></li></ol><p><strong>方案对比</strong></p><table><thead><tr><th>特性</th><th>iRedMail</th><th>Mail-in-a-Box</th><th>手动配置 Webmail</th></tr></thead><tbody><tr><td>易用性</td><td>简单</td><td>简单</td><td>复杂</td></tr><tr><td>Web 管理界面</td><td>有</td><td>有</td><td>需要手动添加</td></tr><tr><td>自动配置</td><td>是</td><td>是</td><td>否</td></tr><tr><td>灵活性</td><td>较低</td><td>较低</td><td>高</td></tr><tr><td>社区支持</td><td>活跃</td><td>活跃</td><td>取决于选择的 Webmail</td></tr><tr><td>适用场景</td><td>快速搭建邮件服务器</td><td>快速搭建邮件服务器</td><td>自定义程度高的场景</td></tr></tbody></table><p><strong>选择哪个方案？</strong></p><ul><li><p><strong>iRedMail 或 Mail-in-a-Box：</strong> 如果你希望快速搭建一个功能完善的邮件服务器，并且不需要太多的自定义，那么 iRedMail 或 Mail-in-a-Box 是不错的选择。</p></li><li><p><strong>手动配置Webmail:</strong> 如果你需要高度自定义， 那么选择这个方式。</p></li></ul><p><strong>总结：</strong></p><p>要实现“图形化注册邮箱”的功能，你需要安装额外的软件，并提供一个 Web 界面供用户注册和管理他们的邮箱。 iRedMail 和 Mail-in-a-Box 是两种流行的选择，它们提供了易于使用的 Web 管理界面，可以简化邮件服务器的管理。 你也可以选择手动安装和配置 Roundcube Webmail 或 Rainloop Webmail，但这种方法更复杂。 请务必仔细阅读所选方案的文档，并按照说明进行操作。</p><h2 id="日志诊断">日志诊断</h2><ul><li>nginx</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> less /var/log/nginx/error.log</span><br><span class="line"><span class="built_in">sudo</span> less /var/log/nginx/access.log</span><br></pre></td></tr></table></figure><ul><li>mail</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">tail</span> -n 50 /var/log/mail.err</span><br></pre></td></tr></table></figure><h2 id="about-me-个人微信">about me 个人微信</h2><p><img src="https://czq-blog.oss-cn-beijing.aliyuncs.com/me.jpeg?Expires=1741078870&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=3OQ42kDkDuA1517Z6lKc2ZUhiQU%3D" class="lazyload placeholder" data-srcset="https://czq-blog.oss-cn-beijing.aliyuncs.com/me.jpeg?Expires=1741078870&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=3OQ42kDkDuA1517Z6lKc2ZUhiQU%3D" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="wechat-offical-微信公众号">wechat offical 微信公众号</h2><p><img src="https://czq-blog.oss-cn-beijing.aliyuncs.com/wechat.jpg?Expires=1741078900&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=y3fPR2LjlkZXW%2FAQCh5n%2ByfHcxQ%3D" class="lazyload placeholder" data-srcset="https://czq-blog.oss-cn-beijing.aliyuncs.com/wechat.jpg?Expires=1741078900&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=y3fPR2LjlkZXW%2FAQCh5n%2ByfHcxQ%3D" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;在ubuntu使用Postfix搭建邮件服务器&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Ubuntu 服务器上搭建邮件服务器的教程。 Postfix 作为邮件传输代理 (MTA)，Dovecot 作为邮件投递代理 (MDA)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="ubuntu" scheme="https://caozhaoqi.github.io/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>搭建 Git 或 SVN 服务器并通过 Samba 共享</title>
    <link href="https://caozhaoqi.github.io/2025/03/18/smb-git-svn/"/>
    <id>https://caozhaoqi.github.io/2025/03/18/smb-git-svn/</id>
    <published>2025-03-18T03:40:56.000Z</published>
    <updated>2025-11-25T15:05:10.365Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、搭建 Git 服务器并通过 Samba 共享</strong></p><p>这种方式下，Git 服务器本身处理版本控制逻辑，Samba 只负责共享 Git 仓库所在的目录。</p><p><strong>1. 安装 Git 和 Samba</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install git samba</span><br></pre></td></tr></table></figure><p><strong>2. 创建 Git 仓库</strong></p><ul><li><p><strong>创建一个用于存放 Git 仓库的目录（例如 <code>/srv/git</code>）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /srv/git</span><br></pre></td></tr></table></figure></li><li><p><strong>进入该目录并初始化一个裸仓库（bare repository）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /srv/git</span><br><span class="line"><span class="built_in">sudo</span> git init --bare myproject.git  <span class="comment"># &quot;myproject&quot; 是你的项目名称</span></span><br></pre></td></tr></table></figure><p>裸仓库只包含版本控制信息，没有工作目录。</p></li><li><p><strong>设置权限</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R www-data:www-data /srv/git/myproject.git <span class="comment">#假设你的samba用户是www-data</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 775 /srv/git/myproject.git</span><br></pre></td></tr></table></figure></li></ul><p><strong>3. 配置 Samba 共享</strong></p><ul><li><p><strong>编辑 Samba 配置文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>在文件末尾添加以下内容（根据你的实际情况修改）：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[git-repos]</span></span><br><span class="line">    <span class="attr">comment</span> = Git Repositories</span><br><span class="line">    <span class="attr">path</span> = /srv/git</span><br><span class="line">    <span class="attr">browseable</span> = <span class="literal">yes</span></span><br><span class="line">    read <span class="attr">only</span> = <span class="literal">no</span></span><br><span class="line">    guest <span class="attr">ok</span> = <span class="literal">no</span>  <span class="comment"># 如果需要匿名访问，设置为 yes</span></span><br><span class="line">    valid <span class="attr">users</span> = @gitusers  <span class="comment"># 允许访问的用户组 (见下一步)</span></span><br><span class="line">    create <span class="attr">mask</span> = <span class="number">0664</span></span><br><span class="line">    directory <span class="attr">mask</span> = <span class="number">0775</span></span><br><span class="line">    force <span class="attr">group</span> = gitusers <span class="comment">#强制组</span></span><br></pre></td></tr></table></figure><ul><li><code>[git-repos]</code>: 共享名称，客户端访问时使用。</li><li><code>path</code>: Git 仓库所在的目录。</li><li><code>valid users</code>: 允许访问的用户或用户组（需要先创建用户/组）。</li><li><code>guest ok</code>: 是否允许匿名访问（不推荐）。</li></ul></li><li><p><strong>创建一个 Samba 用户组（例如 <code>gitusers</code>）并将用户添加到该组：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> groupadd gitusers</span><br><span class="line"><span class="built_in">sudo</span> usermod -aG gitusers nas  </span><br><span class="line"><span class="built_in">sudo</span> smbpasswd -a nas   </span><br></pre></td></tr></table></figure><p>重复<code>usermod</code>和<code>smbpasswd</code>命令，添加多个用户。</p></li><li><p><strong>重启 Samba 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart smbd</span><br></pre></td></tr></table></figure></li></ul><p><strong>4. 客户端访问</strong></p><ul><li><p><strong>在 Windows 上：</strong></p><ul><li>打开文件资源管理器，在地址栏输入 <code>\\your_server_ip\git-repos</code> （将 <code>your_server_ip</code> 替换为你的服务器 IP 地址或主机名）。</li><li>输入你的 Samba 用户名和密码。</li><li>你应该能看到 <code>myproject.git</code> 目录。</li></ul></li><li><p><strong>在 Linux/macOS 上：</strong></p><ul><li>可以使用命令行或图形界面的 SMB/CIFS 客户端访问。</li><li>挂载 Samba 共享：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mount -t cifs //your_server_ip/git-repos /mnt/git -o username=yourusername,password=yourpassword</span><br></pre></td></tr></table></figure>(将 <code>/mnt/git</code> 替换为你想要挂载到的本地目录)。</li></ul></li><li><p><strong>使用 Git 客户端克隆仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> smb://your_server_ip/git-repos/myproject.git</span><br><span class="line"><span class="comment"># 或者, 如果已经挂载:</span></span><br><span class="line">git <span class="built_in">clone</span> /mnt/git/myproject.git  </span><br></pre></td></tr></table></figure><p>之后就可以像使用普通的 Git 仓库一样进行 <code>add</code>、<code>commit</code>、<code>push</code>、<code>pull</code> 等操作。</p></li></ul><p><strong>二、搭建 SVN 服务器并通过 Samba 共享</strong></p><p>与 Git 类似，SVN 服务器处理版本控制，Samba 共享 SVN 仓库目录。</p><p><strong>1. 安装 SVN 和 Samba</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install subversion samba libapache2-mod-svn</span><br></pre></td></tr></table></figure><p><code>libapache2-mod-svn</code> 提供了通过 Apache 进行 SVN 访问的功能 (可选, 但更安全, 推荐)</p><p><strong>2. 创建 SVN 仓库</strong></p><ul><li><p><strong>创建一个用于存放 SVN 仓库的目录（例如 <code>/srv/svn</code>）：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /srv/svn</span><br></pre></td></tr></table></figure></li><li><p><strong>进入该目录并创建一个 SVN 仓库：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /srv/svn</span><br><span class="line"><span class="built_in">sudo</span> svnadmin create myproject  <span class="comment"># &quot;myproject&quot; 是你的项目名称</span></span><br></pre></td></tr></table></figure></li><li><p><strong>设置权限</strong></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R www-data:www-data /srv/svn/myproject</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> -R 775 /srv/svn/myproject</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>3.  (可选, 推荐) 配置 Apache + SVN (更安全)</strong></p><ul><li><p><strong>创建 SVN 的密码文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> htpasswd -c /etc/apache2/dav_svn.passwd yourusername  <span class="comment"># 创建第一个用户</span></span><br><span class="line"><span class="built_in">sudo</span> htpasswd /etc/apache2/dav_svn.passwd anotheruser     <span class="comment"># 添加更多用户</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个 Apache 配置文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apache2/mods-available/dav_svn.conf</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Location /svn&gt;</span></span><br><span class="line">   <span class="attribute">DAV</span> svn</span><br><span class="line">   <span class="attribute">SVNParentPath</span> /srv/svn</span><br><span class="line">   <span class="attribute">AuthType</span> Basic</span><br><span class="line">   <span class="attribute">AuthName</span> <span class="string">&quot;Subversion Repository&quot;</span></span><br><span class="line">   <span class="attribute">AuthUserFile</span> /etc/apache2/dav_svn.passwd</span><br><span class="line">   <span class="attribute">Require</span> valid-user</span><br><span class="line"><span class="section">&lt;/Location&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启用必要的 Apache 模块并重启 Apache：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> a2enmod dav</span><br><span class="line"><span class="built_in">sudo</span> a2enmod dav_svn</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart apache2</span><br></pre></td></tr></table></figure><ul><li>现在, 可以通过 <code>http://your_server_ip/svn/myproject</code> 来访问 SVN 仓库 (需要用户名和密码).</li></ul></li></ul><p><strong>4. 配置 Samba 共享 (如果不用 Apache, 可以通过 Samba 共享)</strong></p><ul><li><p><strong>编辑 Samba 配置文件：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>在文件末尾添加以下内容：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[svn-repos]</span></span><br><span class="line">    <span class="attr">comment</span> = SVN Repositories</span><br><span class="line">    <span class="attr">path</span> = /srv/svn</span><br><span class="line">    <span class="attr">browseable</span> = <span class="literal">yes</span></span><br><span class="line">    read <span class="attr">only</span> = <span class="literal">no</span></span><br><span class="line">    guest <span class="attr">ok</span> = <span class="literal">no</span>  <span class="comment"># 如果需要匿名访问，设置为 yes</span></span><br><span class="line">    valid <span class="attr">users</span> = @svnusers <span class="comment">#同上，需要创建svnusers组和用户</span></span><br><span class="line">    create <span class="attr">mask</span> = <span class="number">0664</span></span><br><span class="line">    directory <span class="attr">mask</span> = <span class="number">0775</span></span><br><span class="line">    force <span class="attr">group</span> = svnusers</span><br></pre></td></tr></table></figure></li><li><p><strong>创建 Samba 用户组和用户 (参考 Git 部分的步骤)。</strong></p></li><li><p><strong>重启 Samba 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart smbd</span><br></pre></td></tr></table></figure></li></ul><p><strong>5. 客户端访问</strong></p><ul><li>如果使用 Apache + SVN, 使用 SVN 客户端通过 <code>http://your_server_ip/svn/myproject</code> 访问.</li><li>如果使用 Samba 共享：<ul><li><strong>Windows:</strong>  <code>\\your_server_ip\svn-repos</code></li><li><strong>Linux/macOS:</strong>  <code>smb://your_server_ip/svn-repos</code> (或挂载)</li><li>使用 SVN 客户端（如 TortoiseSVN、<code>svn</code> 命令行工具）进行 <code>checkout</code>、<code>commit</code>、<code>update</code> 等操作。</li></ul></li></ul><h2 id="smb-启用回收站">smb 启用回收站</h2><p>Samba 的 <code>vfs_recycle</code> 模块提供了一个简单但实用的回收站功能，可以防止用户意外删除共享文件。当用户通过 Samba 删除文件时，文件不会被立即从服务器上永久删除，而是会被移动到一个特殊的回收站目录中。管理员可以配置回收站的保留策略，例如文件保留时间、回收站最大容量等。</p><p>下面是关于 <code>vfs_recycle</code> 模块的详细说明和配置方法：</p><p><strong>1. 工作原理</strong></p><ul><li>当用户通过 Samba 客户端删除文件时，<code>vfs_recycle</code> 模块会拦截删除操作。</li><li>文件不会被真正删除，而是被移动到预先配置好的回收站目录中。</li><li>移动到回收站的文件会保留一段时间（可配置），超过保留时间后才会被自动删除。</li><li>管理员可以手动清理回收站，或者恢复回收站中的文件。</li></ul><p><strong>2. 配置方法</strong></p><p><code>vfs_recycle</code> 模块的配置主要在 Samba 的配置文件 (<code>/etc/samba/smb.conf</code>) 中完成。你可以在全局配置部分 (<code>[global]</code>) 中设置默认的回收站参数，也可以在单个共享配置部分中为特定的共享设置不同的回收站参数。</p><p>以下是一个配置示例，添加到你的 <code>smb.conf</code> 文件中：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line">    <span class="comment"># ... 其他全局配置 ...</span></span><br><span class="line"></span><br><span class="line">    vfs <span class="attr">objects</span> = recycle  <span class="comment"># 在全局配置中启用 recycle 模块</span></span><br><span class="line"></span><br><span class="line">    recycle:<span class="attr">repository</span> = .recycle/%U  <span class="comment"># 回收站目录，%U 代表用户名</span></span><br><span class="line">    recycle:<span class="attr">keeptree</span> = <span class="literal">Yes</span>            <span class="comment"># 保留原始目录结构</span></span><br><span class="line">    recycle:<span class="attr">versions</span> = <span class="literal">Yes</span>            <span class="comment"># 启用版本控制 (如果文件名相同)</span></span><br><span class="line">    recycle:<span class="attr">touch</span> = <span class="literal">Yes</span>               <span class="comment"># 更新文件的访问时间</span></span><br><span class="line">    recycle:<span class="attr">maxsize</span> = <span class="number">0</span>               <span class="comment"># 回收站最大容量 (0 表示无限制)</span></span><br><span class="line">    recycle:<span class="attr">exclude</span> = *.tmp, *.temp    <span class="comment"># 排除的文件类型</span></span><br><span class="line">    recycle:<span class="attr">exclude_dir</span> = /tmp, /cache <span class="comment"># 排除的目录</span></span><br><span class="line">    recycle:<span class="attr">noversions</span> = *.doc        <span class="comment"># 不保留版本的文件类型</span></span><br><span class="line">    <span class="comment"># recycle:minsize = 1024            # 最小文件大小 (单位: 字节)</span></span><br><span class="line">    <span class="comment"># recycle:days_kept = 30           # 文件保留天数</span></span><br><span class="line"></span><br><span class="line"><span class="section">[myshare]</span></span><br><span class="line">    <span class="attr">comment</span> = My Shared Folder</span><br><span class="line">    <span class="attr">path</span> = /path/to/myshare</span><br><span class="line">    <span class="comment"># ... 其他共享配置 ...</span></span><br><span class="line"></span><br><span class="line">    vfs <span class="attr">objects</span> = recycle  <span class="comment"># 也可以在单个共享中启用 recycle 模块</span></span><br><span class="line">    recycle:<span class="attr">repository</span> = .recycle/%U <span class="comment">#可选，如果需要和全局不一样的配置</span></span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><strong><code>vfs objects = recycle</code></strong>: 启用 <code>vfs_recycle</code> 模块。可以放在 <code>[global]</code> 部分（对所有共享生效）或单个共享配置部分（只对该共享生效）。</li><li><strong><code>recycle:repository = .recycle/%U</code></strong>:<ul><li>指定回收站目录的位置。</li><li><code>.recycle</code> 是回收站目录的名称（可以自定义）。</li><li><code>%U</code> 是一个变量，代表删除文件的用户名，这样可以为每个用户创建单独的回收站。</li><li>也可以使用绝对路径，例如 <code>/path/to/recycle/%U</code>。</li><li>如果使用相对路径（如 <code>.recycle</code>），回收站目录会创建在共享目录的根目录下。</li></ul></li><li><strong><code>recycle:keeptree = Yes</code></strong>:  在回收站中保留文件被删除前的原始目录结构。如果设置为 <code>No</code>，所有文件都会被直接放在回收站根目录下。</li><li><strong><code>recycle:versions = Yes</code></strong>:<ul><li>如果回收站中已经存在同名文件，是否创建新版本。</li><li>设置为 <code>Yes</code> 时，新版本的文件名会附加一个版本号（例如 <code>file.txt.1</code>、<code>file.txt.2</code>）。</li><li>设置为 <code>No</code> 时，新文件会覆盖旧文件。</li></ul></li><li><strong><code>recycle:touch = Yes</code></strong>:  当文件被移动到回收站时，更新文件的访问时间（atime）。</li><li><strong><code>recycle:maxsize = 0</code></strong>:<ul><li>设置回收站的最大容量（以字节为单位）。</li><li><code>0</code> 表示无限制。</li><li>当回收站达到最大容量时，最早的文件会被自动删除。</li></ul></li><li><strong><code>recycle:exclude = *.tmp, *.temp</code></strong>:  指定不放入回收站的文件类型（使用通配符）。</li><li><strong><code>recycle:exclude_dir = /tmp, /cache</code></strong>:  指定不放入回收站的目录（绝对路径）。</li><li><strong><code>recycle:noversions = *.doc</code></strong>:  指定不保留版本的文件类型（即使 <code>recycle:versions = Yes</code>）。</li><li><strong><code>recycle:minsize = 1024</code></strong>:  指定只有大于此大小（字节）的文件才会被放入回收站。</li><li><strong><code>recycle:days_kept = 30</code></strong>:  指定文件在回收站中保留的天数。超过此天数的文件会被自动删除。</li></ul><p><strong>3. 注意事项</strong></p><ul><li><strong>权限:</strong> 确保 Samba 用户对回收站目录有读写权限。</li><li><strong>性能:</strong> 如果回收站中文件过多，可能会影响 Samba 的性能。建议定期清理回收站。</li><li><strong>删除</strong>: 回收站中的文件，是真正被删除。</li><li><strong>与版本控制的区别:</strong> <code>vfs_recycle</code> 模块只是一个简单的回收站功能，它不能像 Git、SVN 那样进行细粒度的版本控制（记录每次修改、回滚到特定版本等）。它只能恢复被删除的文件，而不能恢复文件的历史版本（除非启用了 <code>recycle:versions</code> 并且文件名相同）。</li><li><strong>客户端兼容性</strong>: 通过smb删除的文件才会进入回收站，直接在服务器上通过<code>rm</code>等命令删除，不会进入回收站。</li></ul><p><strong>4. 使用方法</strong></p><p>配置完成后，用户通过 Samba 客户端删除文件时，文件会自动进入回收站。管理员可以通过以下方式管理回收站：</p><ul><li><strong>直接访问回收站目录:</strong> 回收站目录通常位于共享目录的根目录下（如果使用相对路径）或指定的绝对路径下。管理员可以直接访问该目录来查看、恢复或删除回收站中的文件。</li><li><strong>使用命令行工具:</strong> 可以编写脚本，定期清理回收站中超过保留时间的文件。</li></ul><p>通过合理配置 <code>vfs_recycle</code> 模块，你可以为 Samba 共享提供一个简单有效的回收站功能，防止用户误删除文件，提高数据安全性。</p><h2 id="about-me-个人微信">about me 个人微信</h2><p><img src="https://czq-blog.oss-cn-beijing.aliyuncs.com/me.jpeg?Expires=1741078870&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=3OQ42kDkDuA1517Z6lKc2ZUhiQU%3D" class="lazyload placeholder" data-srcset="https://czq-blog.oss-cn-beijing.aliyuncs.com/me.jpeg?Expires=1741078870&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=3OQ42kDkDuA1517Z6lKc2ZUhiQU%3D" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="wechat-offical-微信公众号">wechat offical 微信公众号</h2><p><img src="https://czq-blog.oss-cn-beijing.aliyuncs.com/wechat.jpg?Expires=1741078900&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=y3fPR2LjlkZXW%2FAQCh5n%2ByfHcxQ%3D" class="lazyload placeholder" data-srcset="https://czq-blog.oss-cn-beijing.aliyuncs.com/wechat.jpg?Expires=1741078900&amp;OSSAccessKeyId=TMP.3Kqnu2nGq3bZ4KHKg3CKb4cix6tBsmx7Nhi7A7qcv84ZvM8W24oGTuKCih6se8FQJtPuh8fHNK6NqbkbsbkDAwGCfmeBHV&amp;Signature=y3fPR2LjlkZXW%2FAQCh5n%2ByfHcxQ%3D" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一、搭建 Git 服务器并通过 Samba 共享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式下，Git 服务器本身处理版本控制逻辑，Samba 只负责共享 Git 仓库所在的目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 安装 Git 和 Samba&lt;/stron</summary>
      
    
    
    
    
    <category term="git" scheme="https://caozhaoqi.github.io/tags/git/"/>
    
  </entry>
  
</feed>
