<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhaoqi.Cao static blog</title>
  
  <subtitle>浅斟低唱</subtitle>
  <link href="https://caozhaoqi.github.io/atom.xml" rel="self"/>
  
  <link href="https://caozhaoqi.github.io/"/>
  <updated>2026-01-09T03:19:01.192Z</updated>
  <id>https://caozhaoqi.github.io/</id>
  
  <author>
    <name>Zhaoqi.Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 LLDB 动态调试提取 SQLCipher 数据库密钥</title>
    <link href="https://caozhaoqi.github.io/2026/01/09/lldb-macos-anal/"/>
    <id>https://caozhaoqi.github.io/2026/01/09/lldb-macos-anal/</id>
    <published>2026-01-09T02:01:51.000Z</published>
    <updated>2026-01-09T03:19:01.192Z</updated>
    
    <content type="html"><![CDATA[<h1>macOS 逆向实战：使用 LLDB 动态调试提取 SQLCipher 数据库密钥</h1><p>在 macOS 的逆向工程和应用安全分析中，<strong>LLDB (Low Level Debugger)</strong> 是最强大的工具之一。它是 Xcode 默认的调试器，不仅可以用于开发，更是动态分析第三方应用的利器。</p><p>很多应用（例如 <strong>某App</strong>）使用 SQLCipher 对 SQLite 数据库进行加密。通常，应用在运行时必须调用 <code>sqlite3_key</code> 函数将密钥传递给数据库引擎。只要我们在这一瞬间“冻结”住程序，就能从内存中提取出原始密钥。</p><p>本文将演示如何使用 LLDB 的 <strong>“冷启动拦截技术”</strong> 来提取 <strong>某App</strong> 的数据库密钥。</p><h2 id="前置知识：ARM64-架构下的参数传递">前置知识：ARM64 架构下的参数传递</h2><p>在 Apple Silicon (M1/M2/M3/M4/M5) 芯片的 macOS 上，程序运行在 ARM64 架构下。了解函数调用约定（Calling Convention）是逆向的基础：</p><p>当程序调用一个函数时，参数通常存放在通用寄存器中：</p><ul><li><strong>x0 寄存器</strong>：第 1 个参数（通常是数据库句柄 <code>db</code>）</li><li><strong>x1 寄存器</strong>：第 2 个参数（在 <code>sqlite3_key</code> 中，这是<strong>密钥内容的内存地址指针</strong>）</li><li><strong>x2 寄存器</strong>：第 3 个参数（在 <code>sqlite3_key</code> 中，这是<strong>密钥的长度</strong>）</li></ul><p>我们的目标非常明确：<strong>拦截 <code>sqlite3_key</code>，检查 <code>x2</code> 是否为 32（标准密钥长度），如果是，就读取 <code>x1</code> 指向的内存。</strong></p><hr><h2 id="实战步骤：冷启动拦截法">实战步骤：冷启动拦截法</h2><p>相比于“先打开应用再附加调试器”，<strong>冷启动拦截（Wait-for-attach）</strong> 更加稳健。它允许我们在应用代码执行的第一行之前就挂载调试器，确保不会漏掉数据库初始化的关键时刻。</p><h3 id="第一步：清理环境">第一步：清理环境</h3><p>为了确保从头开始，先彻底关闭目标应用。在终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall 某App</span><br></pre></td></tr></table></figure><h3 id="第二步：设下“埋伏圈”">第二步：设下“埋伏圈”</h3><p>在终端输入以下命令。<code>-n</code> 指定进程名，<code>-w</code> (waitfor) 表示等待进程启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> lldb -n <span class="string">&quot;某App&quot;</span> -w</span><br></pre></td></tr></table></figure><p><em>提示：使用 <code>sudo</code> 是为了获得读取其他进程内存的权限。输入后终端会显示 <code>Waiting for process to launch...</code>。</em></p><h3 id="第三步：启动并下断点">第三步：启动并下断点</h3><p>手动点击 Dock 栏或启动台中的 <strong>某App</strong> 图标。</p><p>你会发现应用图标跳动了一下，但没有出现窗口。此时终端会提示 <code>Process xxxxx stopped</code>。这说明调试器已经成功附身，并且暂停了程序运行。</p><p>现在，我们需要设置一个<strong>正则断点</strong>。为什么用正则？因为应用可能静态链接了 WCDB 等库，函数名可能变成了 <code>wcdb_sqlite3_key</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br set -r &quot;sqlite3_key&quot;</span><br></pre></td></tr></table></figure><p><em>如果显示 <code>Breakpoint 1: x locations</code>，说明断点设置成功。</em></p><h3 id="第四步：放行程序">第四步：放行程序</h3><p>断点设好了，我们需要让程序继续跑，直到它撞上我们的陷阱。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure><p><em>此时终端会显示 <code>Resuming</code>，应用界面开始加载。</em></p><h3 id="第五步：捕获猎物">第五步：捕获猎物</h3><p>去操作 <strong>某App</strong>（例如点击登录按钮）。核心逻辑是：只要应用试图解密数据库查看历史消息，它就必须调用加密函数。</p><p><strong>关键时刻：</strong><br>你会发现 <strong>某App</strong> 的界面突然卡死，转圈圈停止。同时，终端会出现如下提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Process 12345 stopped</span><br><span class="line">* thread #1... stop reason = breakpoint 1.1</span><br></pre></td></tr></table></figure><p><strong>看到了 <code>stopped</code>，说明我们成功拦截到了密钥传递的瞬间！</strong></p><h3 id="第六步：验证与提取">第六步：验证与提取</h3><p><strong>1. 验明正身</strong><br>首先检查密钥长度。输入读取寄存器命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) reg read x2</span><br></pre></td></tr></table></figure><ul><li>如果输出 <code>0x0000000000000020</code>（即十进制的 32），恭喜你，这就是我们要找的原始密钥。</li><li>如果输出 <code>0x00...07</code> 或其他值，说明这可能是一个默认空密码或其他操作。输入 <code>c</code> 让程序继续运行，等待下一次断点触发。</li></ul><p><strong>2. 读取密钥</strong><br>确认长度为 32 后，读取 <code>x1</code> 寄存器指向的内存内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -s 1 -f x -c 32 $x1</span><br></pre></td></tr></table></figure><ul><li><code>-s 1</code>：按 1 字节分组</li><li><code>-f x</code>：十六进制格式</li><li><code>-c 32</code>：读取 32 字节</li><li><code>$x1</code>：目标地址</li></ul><p>终端将打印出两行 16 进制数据，这就是该数据库的解密密钥（Raw Key）。</p><hr><h2 id="常见错误排查-Troubleshooting">常见错误排查 (Troubleshooting)</h2><p>在调试过程中，新手最容易遇到以下报错：</p><p><strong>错误 1：</strong></p><blockquote><p><code>error: Command requires a process which is currently stopped.</code></p></blockquote><p><strong>原因：</strong> 你试图在汽车高速行驶时检查引擎。<br><strong>解决：</strong> 当终端显示 <code>Process resuming</code> 时，说明程序正在运行，<strong>不要输入任何读取命令</strong>。去操作 App 界面触发逻辑，直到终端显示 <code>stop reason = breakpoint</code> 之后，再执行 <code>reg read</code> 或 <code>memory read</code>。</p><p><strong>错误 2：</strong></p><blockquote><p><code>failed to get reply to handshake packet</code></p></blockquote><p><strong>原因：</strong> 权限不足或 macOS 的 SIP (系统完整性保护) 阻止了调试。<br><strong>解决：</strong> 确保使用了 <code>sudo</code>。如果依然不行，可能需要在 Recovery 模式下暂时关闭 SIP。</p><h2 id="技术实现：macOS-平台app密钥提取">技术实现：macOS 平台app密钥提取</h2><p>除了手动使用 LLDB 调试，项目在 macOS 平台上实现了一套自动化的密钥提取机制。由于 macOS 的安全机制（SIP、ASLR 等）比 Windows 更为严格，因此实现过程也更具挑战性。</p><h2 id="核心挑战">核心挑战</h2><ol><li><strong>权限隔离</strong>：macOS 严格限制进程间访问，普通进程无法读取其他进程的内存。</li><li><strong>ASLR (地址空间布局随机化)</strong>：每次启动，app的内存地址都会随机变化，无法像 Windows 那样使用固定偏移量。</li><li><strong>内存布局复杂</strong>：密钥可能存储在堆（Heap）的任意位置，且现代应用内存空间巨大（数 GB），全量扫描效率极低。</li><li><strong>多版本兼容</strong>：app不同版本（3.x, 4.x）的内部结构和密钥存储方式可能不同。</li></ol><h2 id="实现方案一：非侵入式内存扫描（首选）">实现方案一：非侵入式内存扫描（首选）</h2><p>本项目首先尝试采用 <strong>Ptrace + vmmap + 特征扫描</strong> 的组合方案。这种方式不需要重启app，对用户体验影响最小。</p><h3 id="1-权限获取与进程附加">1. 权限获取与进程附加</h3><p>首先，程序需要以 Root 权限运行（<code>sudo</code>），利用 <code>syscall.PtraceAttach</code> 系统调用附加到app进程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试使用ptrace附加到进程（需要root权限）</span></span><br><span class="line">err := syscall.PtraceAttach(<span class="type">int</span>(info.ProcessID))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 处理权限错误，提示用户使用 sudo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> syscall.PtraceDetach(<span class="type">int</span>(info.ProcessID))</span><br></pre></td></tr></table></figure><h3 id="2-动态内存布局分析">2. 动态内存布局分析</h3><p>为了解决 ASLR 和内存空间巨大的问题，我们不进行盲目的全量扫描。而是调用 macOS 自带的 <code>vmmap</code> 工具，获取app进程当前的内存映射表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用vmmap获取进程内存布局</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMemRegions</span><span class="params">(pid <span class="type">int</span>)</span></span> ([]MemRegion, <span class="type">error</span>) &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;vmmap&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, pid))</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过解析 <code>vmmap</code> 的输出，我们智能地筛选出可能包含密钥的内存区域：</p><ul><li><strong>保留</strong>：<code>MALLOC_TINY</code>, <code>MALLOC_NANO</code>（小对象堆，密钥通常在此），以及 <code>__DATA</code> 段（全局变量）。</li><li><strong>过滤</strong>：只读区域（<code>r--</code>）、<code>MALLOC_LARGE</code>（大对象堆）、显存映射等不太可能存储密钥的区域。</li><li><strong>优化</strong>：对于过大的区域（&gt;50MB），只扫描前部，平衡性能与成功率。</li></ul><h3 id="3-内存读取与特征扫描">3. 内存读取与特征扫描</h3><p>利用 <code>syscall.Ptrace</code> (PT_READ_D) 读取目标进程内存。为了提高效率和稳定性，我们实现了分块读取和错误跳过机制。</p><p>在读取到的内存中，我们使用**特征码（Magic Pattern）**来定位密钥结构体。</p><p><strong>特征 1：设备符号定位</strong><br>app的密钥结构体附近通常包含设备类型的字符串（如 “iphone”, “android”, “ipad”）。我们首先搜索这些锚点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasDeviceSybmol</span><span class="params">(buffer []<span class="type">byte</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    deviceNames := []<span class="type">string</span>&#123;<span class="string">&quot;iphone&quot;</span>, <span class="string">&quot;ipad&quot;</span>, <span class="string">&quot;android&quot;</span>, <span class="string">&quot;OHOS&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特征 2：密钥长度模式</strong><br>找到设备符号后，我们在其<strong>前后</strong>范围内搜索符合密钥长度特征的数据（通常是 32 字节或 16 字节的长度字段）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keyLenPatterns := [][]<span class="type">byte</span>&#123;</span><br><span class="line">    &#123;<span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;, <span class="comment">// 32字节密钥</span></span><br><span class="line">    &#123;<span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;, <span class="comment">// 16字节密钥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-密钥验证">4. 密钥验证</h3><p>找到潜在的密钥指针后，我们读取指针指向的内存内容，并尝试用它来解密用户的 <code>Media.db</code> 数据库头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证密钥是否正确</span></span><br><span class="line"><span class="keyword">if</span> checkDataBaseKey(mediaDB, keyBuffer) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(hexKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有通过验证的密钥才会被返回，确保了提取结果的准确性。</p><h2 id="实现方案二：LLDB-自动化拦截（Fallback）">实现方案二：LLDB 自动化拦截（Fallback）</h2><p>如果内存扫描方案失败（例如app版本更新导致特征码失效），程序会自动切换到 <strong>LLDB 自动化拦截</strong> 模式。这种方式准确率极高，但需要重启app。</p><h3 id="1-原理">1. 原理</h3><p>利用 LLDB 的 Python Scripting Bridge，我们可以编写脚本自动设置断点并读取寄存器。这相当于把本文开头的“手动逆向步骤”完全自动化了。</p><h3 id="2-自动化流程">2. 自动化流程</h3><ol><li><strong>环境清理</strong>：程序检测并关闭正在运行的app进程。</li><li><strong>脚本注入</strong>：动态生成一个 LLDB Python 脚本，该脚本包含以下逻辑：<ul><li>监听 <code>sqlite3_key</code> 函数调用。</li><li>当断点触发时，自动读取寄存器（ARM64 下为 <code>x2</code> 长度，<code>x1</code> 指针）。</li><li>验证密钥长度是否为 32。</li><li>读取密钥内容并打印到标准输出。</li><li>分离调试器并退出，让app继续运行。</li></ul></li><li><strong>启动调试</strong>：程序启动 <code>lldb</code>，加载上述脚本，并设置为等待模式 (<code>-w</code>)。</li><li><strong>启动应用</strong>：程序调用 <code>open -a app</code> 启动app。</li><li><strong>捕获密钥</strong>：程序监听 LLDB 的输出，一旦捕获到密钥，立即解析并返回。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># LLDB Python 脚本核心逻辑示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intercept_key</span>(<span class="params">frame, bp_loc, <span class="built_in">dict</span></span>):</span><br><span class="line">    <span class="comment"># ... 获取寄存器 ...</span></span><br><span class="line">    <span class="keyword">if</span> key_len == <span class="number">32</span>:</span><br><span class="line">        key_data = process.ReadMemory(key_ptr, key_len, error)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;app_KEY_FOUND:<span class="subst">&#123;key_data.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">        process.Detach()</span><br><span class="line">        os._exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="兼容性设计">兼容性设计</h2><p>为了适应app的更新，代码中包含了多重兼容逻辑：</p><ul><li><strong>路径兼容</strong>：同时支持旧版 <code>Documents/Msg</code> 和新版 <code>xw_files</code> 目录结构。</li><li><strong>文件名兼容</strong>：同时查找 <code>Media.db</code>, <code>media.db</code>, <code>media_0.db</code>。</li><li><strong>架构兼容</strong>：同时支持 Intel (x86_64) 和 Apple Silicon (ARM64) 架构的指针长度处理。</li></ul><hr><h2 id="实战">实战</h2><blockquote><p>某 App 数据库密钥动态抓取技术方案</p></blockquote><h2 id="1-背景与挑战">1. 背景与挑战</h2><p>该 App 使用 SQLCipher 对本地 SQLite 数据库进行加密。在旧版本中，我们可以通过扫描进程内存，寻找特定的“设备类型字符串”（如 <code>iphone</code>、<code>android</code>）附近的指针来暴力定位密钥。</p><p>然而，随着 App 版本更新（v4.x+），通过内存特征扫描面临以下挑战：</p><ul><li><strong>内存布局改变</strong>：密钥不再紧跟在设备特征字符串之后。</li><li><strong>符号剥离 (Symbol Stripping)</strong>：App 内部静态链接了数据库组件，并移除了 <code>sqlite3_key</code> 等关键函数的符号，导致无法直接通过函数名下断点。</li><li><strong>内存保护</strong>：系统库的高位内存区域（如 <code>0x1FF...</code>）不可读，导致扫描器频发 <code>invalid argument</code> 错误。</li></ul><p>因此，我们需要采用更底层的 <strong>动态调试（Dynamic Debugging）</strong> 方案。</p><hr><h2 id="2-核心思路：降维打击">2. 核心思路：降维打击</h2><p>既然 App 隐藏了内部数据库函数的符号，但它<strong>无法隐藏系统级 API 的调用</strong>。</p><p>macOS/iOS 的底层加密通常依赖 <code>CommonCrypto</code> 框架。无论 App 内部逻辑如何封装，最终在进行 AES 解密时，大概率会调用系统的 <code>CCCryptorCreate</code> 或 <code>CCCrypt</code> 函数。</p><p><strong>攻击路径转变：</strong></p><ul><li><s>拦截应用层：<code>sqlite3_key</code></s> (失败，找不到符号)</li><li><strong>拦截系统层：<code>CCCryptorCreate</code></strong> (成功，系统函数无法隐藏)</li></ul><h3 id="ARM64-调用约定-关键知识">ARM64 调用约定 (关键知识)</h3><p>在 Apple Silicon (M1/M2/M3) 上，函数参数通过寄存器传递：</p><ul><li><code>x0</code> - <code>x2</code>: 前三个参数</li><li><strong><code>x3</code></strong>: 第 4 个参数 -&gt; <strong>Key 的内存地址 (Pointer)</strong></li><li><strong><code>x4</code></strong>: 第 5 个参数 -&gt; <strong>Key 的长度 (Length)</strong></li></ul><p>由于 SQLCipher 的默认密钥长度固定为 <strong>32 字节</strong>，我们可以利用这一点进行精确过滤。</p><hr><h2 id="3-手动抓取流程-LLDB-命令行">3. 手动抓取流程 (LLDB 命令行)</h2><h3 id="3-1-环境清理与启动">3.1 环境清理与启动</h3><p>为了防止抓错进程（例如抓到了 App 的后台守护进程），我们需要彻底关闭 App，并直接指定二进制路径启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 强制清理环境</span></span><br><span class="line"><span class="built_in">sudo</span> killall -9 [App名称]</span><br><span class="line"><span class="built_in">sudo</span> killall -9 lldb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启动调试器 (直接加载主二进制文件)</span></span><br><span class="line"><span class="built_in">sudo</span> lldb /Applications/[App名称].app/Contents/MacOS/[App名称]</span><br></pre></td></tr></table></figure><h3 id="3-2-设置“智能”陷阱">3.2 设置“智能”陷阱</h3><p>系统加密函数调用非常频繁（网络请求、文件缓存都在用）。如果不加条件，App 会瞬间卡死。我们要设置一个<strong>条件断点</strong>：</p><blockquote><p><strong>指令含义</strong>：在 <code>CCCrypt</code> 函数入口下断点，但仅当第 5 个参数（密钥长度 <code>x4</code>）等于 32 时才暂停。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br set -n CCCrypt -c &#x27;$x4 == 32&#x27;</span><br><span class="line">(lldb) br set -n CCCryptorCreate -c &#x27;$x4 == 32&#x27;</span><br></pre></td></tr></table></figure><h3 id="3-3-运行与触发">3.3 运行与触发</h3><ol><li>在 LLDB 中输入 <code>r</code> 启动 App。</li><li>在 App 界面点击 <strong>登录</strong>。</li><li>App 尝试解密数据库读取历史消息，触发断点，界面卡死。</li></ol><h3 id="3-4-提取密钥">3.4 提取密钥</h3><p>当终端显示 <code>Process stopped</code> 时，读取 <code>x3</code> 寄存器指向的内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 读取 x3 指向地址的 32 个字节，以 16 进制显示</span><br><span class="line">(lldb) memory read -s 1 -f x -c 32 $x3</span><br></pre></td></tr></table></figure><p><strong>输出示例图：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(lldb) memory read -s 1 -f x -c 32 $x3</span><br><span class="line">0x600002b84120: 0x98 0x04 0xc3 0xec 0x3b 0xfc 0x36 0xb3</span><br><span class="line">0x600002b84128: 0xd0 0x87 0x6a 0xec 0x65 0xfc 0x7d 0x78</span><br><span class="line">0x600002b84130: 0x0a 0x94 0x46 0x71 0x62 0xf6 0x9f 0xef</span><br><span class="line">0x600002b84138: 0x59 0x12 0x31 0x0d 0xd6 0x5c 0xe7 0x7a</span><br></pre></td></tr></table></figure><p><em>这一串 64 位的 Hex 字符串即为数据库密钥。</em></p><hr><h2 id="4-自动化代码实现-Golang-Python">4. 自动化代码实现 (Golang + Python)</h2><p>为了将上述手动过程封装为工具，我们使用 Golang 调用 LLDB，并通过 Python 脚本控制 LLDB 的行为。</p><h3 id="4-1-核心流程图">4.1 核心流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[启动工具] --&gt; B&#123;清理环境&#125;;</span><br><span class="line">    B --&gt; C[启动 LLDB 子进程];</span><br><span class="line">    C --&gt; D[加载 Python 脚本];</span><br><span class="line">    D --&gt; E[启动 App 主程序];</span><br><span class="line">    E --&gt; F[用户点击登录];</span><br><span class="line">    F --&gt; G&#123;触发 CCCrypt?&#125;;</span><br><span class="line">    G -- No --&gt; F;</span><br><span class="line">    G -- Yes --&gt; H&#123;Key长度==32?&#125;;</span><br><span class="line">    H -- No --&gt; G;</span><br><span class="line">    H -- Yes --&gt; I[Python提取内存数据];</span><br><span class="line">    I --&gt; J[打印 ww_KEY_FOUND 标记];</span><br><span class="line">    J --&gt; K[Go 捕获标记并验证];</span><br><span class="line">    K -- 验证成功 --&gt; L[杀掉进程并返回密钥];</span><br></pre></td></tr></table></figure><h3 id="4-2-Python-脚本-嵌入到-Go-中">4.2 Python 脚本 (嵌入到 Go 中)</h3><p>这是 LLDB 内部执行的脚本，用于逻辑判断和数据提取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lldb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intercept_cccrypt</span>(<span class="params">frame, bp_loc, <span class="built_in">dict</span></span>):</span><br><span class="line">    <span class="comment"># 获取当前线程和进程</span></span><br><span class="line">    thread = frame.GetThread()</span><br><span class="line">    process = thread.GetProcess()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取 x4 寄存器 (Key Length)</span></span><br><span class="line">    len_reg = frame.FindRegister(<span class="string">&quot;x4&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len_reg.IsValid(): <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    key_len = len_reg.GetValueAsUnsigned()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 核心过滤逻辑：只关心长度为 32 的密钥</span></span><br><span class="line">    <span class="keyword">if</span> key_len == <span class="number">32</span>:</span><br><span class="line">        <span class="comment"># 获取 x3 寄存器 (Key Pointer)</span></span><br><span class="line">        ptr_reg = frame.FindRegister(<span class="string">&quot;x3&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> ptr_reg.IsValid():</span><br><span class="line">            key_ptr = ptr_reg.GetValueAsUnsigned()</span><br><span class="line">            </span><br><span class="line">            error = lldb.SBError()</span><br><span class="line">            <span class="comment"># 读取内存</span></span><br><span class="line">            key_data = process.ReadMemory(key_ptr, key_len, error)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> error.Success():</span><br><span class="line">                <span class="comment"># 输出特殊标记，供宿主程序捕获</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;KEY_FOUND:<span class="subst">&#123;key_data.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">                </span><br><span class="line">    <span class="comment"># 返回 False 表示不暂停程序，继续运行，避免 UI 长期卡死</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__lldb_init_module</span>(<span class="params">debugger, internal_dict</span>):</span><br><span class="line">    target = debugger.GetSelectedTarget()</span><br><span class="line">    <span class="comment"># 针对系统库下断点，防止符号缺失</span></span><br><span class="line">    bp = target.BreakpointCreateByName(<span class="string">&quot;CCCryptorCreate&quot;</span>, <span class="string">&quot;libcommonCrypto.dylib&quot;</span>)</span><br><span class="line">    bp.SetScriptCallbackFunction(<span class="string">&quot;intercept_cccrypt&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-3-Go-调用代码示例">4.3 Go 调用代码示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetKeyViaLLDB</span><span class="params">()</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 准备 Python 脚本文件</span></span><br><span class="line">    tmpScript := createTempPythonScript() </span><br><span class="line">    <span class="keyword">defer</span> os.Remove(tmpScript)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 构造 LLDB 命令</span></span><br><span class="line">    <span class="comment">// -Q: 静默模式</span></span><br><span class="line">    <span class="comment">// -b: 批处理模式</span></span><br><span class="line">    <span class="comment">// -o: 加载脚本并启动程序</span></span><br><span class="line">    targetBin := <span class="string">&quot;/Applications/App.app/Contents/MacOS/AppBinary&quot;</span></span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;sudo&quot;</span>, <span class="string">&quot;lldb&quot;</span>, targetBin, <span class="string">&quot;-Q&quot;</span>, <span class="string">&quot;-b&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-o&quot;</span>, fmt.Sprintf(<span class="string">&quot;command script import %s&quot;</span>, tmpScript),</span><br><span class="line">        <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">    stdout, _ := cmd.StdoutPipe()</span><br><span class="line">    cmd.Start()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 实时监听输出</span></span><br><span class="line">    scanner := bufio.NewScanner(stdout)</span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        line := scanner.Text()</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(line, <span class="string">&quot;KEY_FOUND:&quot;</span>) &#123;</span><br><span class="line">            key := strings.Split(line, <span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 实时验证 (假设 checkKey 是验证函数)</span></span><br><span class="line">            <span class="keyword">if</span> checkKey(key) &#123;</span><br><span class="line">                cmd.Process.Kill() <span class="comment">// 拿到正确的 Key 后杀掉调试器</span></span><br><span class="line">                <span class="keyword">return</span> key, <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;key not found&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-总结">5. 总结</h2><table><thead><tr><th style="text-align:left">方案</th><th style="text-align:left">适用版本</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left"><strong>内存特征扫描</strong></td><td style="text-align:left">v3.x 及部分旧版</td><td style="text-align:left"><strong>无感</strong>，不需要重启 App，不中断用户操作。</td><td style="text-align:left">在新版中失效，因内存布局改变和权限限制导致扫描极慢或失败。</td></tr><tr><td style="text-align:left"><strong>LLDB 动态拦截</strong></td><td style="text-align:left"><strong>v4.x (当前最新)</strong></td><td style="text-align:left"><strong>成功率极高</strong>，直接从 CPU 寄存器拿数据，无视代码混淆。</td><td style="text-align:left"><strong>侵入式</strong>，需要 Root 权限，需要重启 App，且操作期间 App 界面会有短暂卡顿。</td></tr></tbody></table><p><strong>最佳实践建议：</strong><br>工具应采用 <strong>混合策略</strong>。优先尝试非侵入式的内存扫描；如果失败，则引导用户授权 Root 权限，使用 LLDB 重启 App 进行暴力提取。</p><p>通过 LLDB，我们不需要拆解应用的安装包，也不需要进行复杂的静态分析，仅仅通过了解其使用的底层数据库库函数（sqlite3），利用 <strong>Wait-for-attach</strong> 和 <strong>寄存器读取</strong>，就能在运行时通过“上帝视角”拿到关键数据。</p><p>这也提醒开发者：<strong>本地数据的安全性不能仅依赖于客户端的加密逻辑，因为在拥有设备物理访问权限的攻击者（或调试器）面前，密钥往往是透明的。</strong></p><p>通过这套 <strong>“内存扫描为主，LLDB 拦截为辅”</strong> 的双重机制， 能够在不依赖硬编码地址的情况下，稳定地从运行中的app进程提取数据库密钥，实现了“一键导出”的便捷体验。</p><hr><h2 id="See">See</h2><p>-1. <a href="https://lldb.llvm.org/use/tutorial.html">https://lldb.llvm.org/use/tutorial.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;macOS 逆向实战：使用 LLDB 动态调试提取 SQLCipher 数据库密钥&lt;/h1&gt;
&lt;p&gt;在 macOS 的逆向工程和应用安全分析中，&lt;strong&gt;LLDB (Low Level Debugger)&lt;/strong&gt; 是最强大的工具之一。它是 Xcode 默认</summary>
      
    
    
    
    
    <category term="逆向" scheme="https://caozhaoqi.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>深入解析 n8n 与 MoneyPrinterTurbo</title>
    <link href="https://caozhaoqi.github.io/2025/12/14/n8n-mpt/"/>
    <id>https://caozhaoqi.github.io/2025/12/14/n8n-mpt/</id>
    <published>2025-12-14T15:28:34.000Z</published>
    <updated>2025-12-14T15:29:10.546Z</updated>
    
    <content type="html"><![CDATA[<h1>解锁自动化与AI生产力：深入解析 n8n 与 MoneyPrinterTurbo</h1><p>在当今的技术领域，&quot;自动化&quot;与&quot;内容生成&quot;是两个最热门的关键词。无论是为了提升企业效率，还是为了在自媒体时代通过流量变现，工具的选择都至关重要。</p><p>今天，我们将介绍两个强大的开源工具：</p><ol><li><strong>n8n</strong>：工作流自动化的瑞士军刀。</li><li><strong>MoneyPrinterTurbo</strong>：全自动短视频生成的印钞机。</li></ol><p>这两个工具虽然定位不同，但都指向同一个核心目标：<strong>用技术解放人力，最大化效率。</strong></p><hr><h2 id="第一部分：n8n-——-下一代工作流自动化平台">第一部分：n8n —— 下一代工作流自动化平台</h2><p><strong>GitHub 地址：</strong> <a href="https://github.com/n8n-io/n8n">n8n-io/n8n</a></p><h3 id="1-什么是-n8n？">1. 什么是 n8n？</h3><p>n8n 是一个可扩展的工作流自动化工具。如果你听说过 Zapier 或 Integromat (Make)，n8n 就是它们的开源、可私有化部署的替代品。它允许用户通过可视化的节点编辑器，将不同的应用程序、数据库和 API 连接在一起，从而自动化执行复杂的任务。</p><h3 id="2-核心原理与工作机制">2. 核心原理与工作机制</h3><p>n8n 采用基于节点的编程模型（Node-based Programming）：</p><ul><li><strong>节点（Nodes）：</strong> 每个节点代表一个动作或一个应用集成（例如：发送 Slack 消息、读取 Google Sheets、调用 HTTP 请求、执行自定义 JavaScript）。</li><li><strong>连接（Connections）：</strong> 线条连接不同的节点，定义数据的流向。</li><li><strong>JSON 数据流：</strong> n8n 内部的所有数据传输都基于 JSON 对象。上一个节点的输出 JSON 会自动成为下一个节点的输入。</li></ul><p><strong>工作流程：</strong></p><ol><li><strong>触发器（Trigger）：</strong> 工作流由特定事件启动（例如：收到新邮件、定时任务 Cron Job、Webhook 调用）。</li><li><strong>处理与逻辑：</strong> 数据经过一系列节点的处理。n8n 支持强大的逻辑控制（If/Else, Switch, Loop），甚至可以直接编写 JavaScript 代码来处理复杂的数据清洗。</li><li><strong>执行动作：</strong> 最终将处理后的数据发送到目标系统（例如：更新 CRM、发布博客）。</li></ol><h3 id="3-应用前景">3. 应用前景</h3><ul><li><strong>企业运营自动化：</strong> 自动同步销售线索从表单到 CRM，自动开具发票。</li><li><strong>DevOps 编排：</strong> 监控服务器报警并自动推送到钉钉/飞书，或者自动化 CI/CD 流程中的特定环节。</li><li><strong>AI Agent 编排（最新趋势）：</strong> n8n 最近大力集成了 LangChain 等 AI 能力，用户可以轻松构建连接本地知识库的 AI 客服或智能助手。</li></ul><hr><h2 id="第二部分：MoneyPrinterTurbo-——-全自动短视频生成器">第二部分：MoneyPrinterTurbo —— 全自动短视频生成器</h2><p><strong>GitHub 地址：</strong> <a href="https://github.com/harry0703/MoneyPrinterTurbo">harry0703/MoneyPrinterTurbo</a></p><h3 id="1-什么是-MoneyPrinterTurbo？">1. 什么是 MoneyPrinterTurbo？</h3><p>顾名思义，这是一个为了“搞钱”而生的工具。它是热门项目 MoneyPrinter 的优化增强版（Turbo）。利用这个工具，用户只需要提供一个<strong>主题</strong>或<strong>关键词</strong>，它就能自动生成一段完整的短视频（包含文案、素材、配音、字幕和背景音乐），非常适合用于 TikTok、YouTube Shorts 或视频号的批量内容生产。</p><h3 id="2-核心原理与工作机制-2">2. 核心原理与工作机制</h3><p>MoneyPrinterTurbo 本质上是一个 <strong>AI 流水线编排器</strong>，它将多个 AI 模型串联起来协同工作：</p><ol><li><strong>脚本生成（LLM）：</strong> 利用大语言模型（如 OpenAI、Azure OpenAI、G4F 等）根据用户的主题生成视频脚本和分镜提示词。</li><li><strong>音频生成（TTS）：</strong> 使用 Edge-TTS 或 Azure TTS 将脚本转换为高质量的语音解说。</li><li><strong>视觉素材获取：</strong><ul><li><strong>视频/图片素材：</strong> 根据脚本关键词，自动从 Pexels 等无版权素材库下载视频/图片。</li><li><strong>AI 绘图：</strong> 或者调用 SD/DALL-E 生成对应的画面。</li></ul></li><li><strong>字幕生成（ASR/Alignment）：</strong> 自动识别音频时间轴，生成并对齐字幕。</li><li><strong>合成渲染（FFmpeg/MoviePy）：</strong> 使用底层的视频处理库，将音频、画面、字幕、背景音乐合成，并添加转场特效和缩放效果（Ken Burns effect）。</li></ol><p><strong>Turbo 版的改进：</strong> 相比原版，Turbo 版通常优化了 UI 界面，增加了更多的语音模型支持，优化了底层生成逻辑，使得生成速度更快，且支持更灵活的配置。</p><h3 id="3-应用前景-2">3. 应用前景</h3><ul><li><strong>自媒体矩阵运营：</strong> 一个人轻松维护几十个短视频账号，通过批量发布科普、故事、励志类视频获取流量收益。</li><li><strong>营销推广：</strong> 为电商产品快速生成大量展示视频。</li><li><strong>教育与知识普及：</strong> 快速将文字教程转化为视频教程。</li></ul><hr><h2 id="第三部分：总结与技术融合的思考">第三部分：总结与技术融合的思考</h2><h3 id="对比分析">对比分析</h3><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">n8n</th><th style="text-align:left">MoneyPrinterTurbo</th></tr></thead><tbody><tr><td style="text-align:left"><strong>定位</strong></td><td style="text-align:left">通用型基础设施</td><td style="text-align:left">垂直型应用工具</td></tr><tr><td style="text-align:left"><strong>核心技术</strong></td><td style="text-align:left">流程编排、API 集成、JS 逻辑</td><td style="text-align:left">多模态 AI 融合（文本+音频+视频）</td></tr><tr><td style="text-align:left"><strong>自由度</strong></td><td style="text-align:left">极高，可构建任何逻辑</td><td style="text-align:left">较低，专注于视频生成</td></tr><tr><td style="text-align:left"><strong>目标用户</strong></td><td style="text-align:left">开发者、运维、SaaS 深度用户</td><td style="text-align:left">自媒体创作者、营销人员</td></tr></tbody></table><h3 id="1-1-2-的想象空间">1+1 &gt; 2 的想象空间</h3><p>虽然这两个项目看似无关，但作为技术人员，我们可以将它们结合起来，构建更强大的自动化闭环：</p><p><strong>场景设想：全自动热点视频发布机器</strong></p><ol><li><strong>n8n 监听热点：</strong> 使用 n8n 定时抓取微博/Twitter 热搜或特定新闻源。</li><li><strong>n8n 调用 AI 分析：</strong> 使用 n8n 内置的 AI 节点总结新闻内容，提取核心观点。</li><li><strong>触发 MoneyPrinterTurbo：</strong> n8n 通过 API 将总结好的文案发送给部署在服务器上的 MoneyPrinterTurbo。</li><li><strong>自动发布：</strong> MoneyPrinterTurbo 生成视频后，回调 n8n，n8n 再通过 API 自动将视频发布到 TikTok 或 YouTube。</li></ol><h3 id="结语">结语</h3><p><strong>n8n</strong> 代表了<strong>连接的能力</strong>，它让我们能够驾驭分散的互联网服务；<strong>MoneyPrinterTurbo</strong> 代表了<strong>生成的红利</strong>，它利用 AI 极大地降低了内容创作的门槛。</p><p>对于开发者和创作者而言，理解并掌握这些工具的原理，不仅仅是学会使用软件，更是掌握了在 AI 时代<strong>通过自动化构建个人护城河</strong>的关键能力。无论是优化工作流程，还是探索副业变现，这两个项目都值得你深入研究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解锁自动化与AI生产力：深入解析 n8n 与 MoneyPrinterTurbo&lt;/h1&gt;
&lt;p&gt;在当今的技术领域，&amp;quot;自动化&amp;quot;与&amp;quot;内容生成&amp;quot;是两个最热门的关键词。无论是为了提升企业效率，还是为了在自媒体时代通过流量变现，工具的选择都</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>FAISS vs Chroma 向量数据库</title>
    <link href="https://caozhaoqi.github.io/2025/12/13/vector-db-compare/"/>
    <id>https://caozhaoqi.github.io/2025/12/13/vector-db-compare/</id>
    <published>2025-12-13T15:42:58.000Z</published>
    <updated>2025-12-13T15:44:21.431Z</updated>
    
    <content type="html"><![CDATA[<h1>FAISS vs Chroma：谁才是 RAG 应用的最佳向量底座？—— 从原理到选型指南</h1><blockquote><p>在构建 LLM（大模型）应用，特别是 RAG（检索增强生成）系统时，<strong>“向量存储”</strong> 是避不开的核心组件。</p></blockquote><h2 id="一、-背景与定位：老兵-vs-新贵">一、 背景与定位：老兵 vs 新贵</h2><h3 id="1-FAISS-Facebook-AI-Similarity-Search">1. FAISS (Facebook AI Similarity Search)</h3><ul><li><strong>出身</strong>：由 <strong>Meta (Facebook) AI Research</strong> 团队开发，2017年开源。</li><li><strong>定位</strong>：<strong>向量搜索库 (Library)</strong>。</li><li><strong>核心哲学</strong>：<strong>“我只做一件事，并做到极致。”</strong><br>FAISS 专注于解决“如何在十亿级向量中快速找到最近邻”的数学和算法问题。它不关心你的数据存哪、不关心你的元数据（Metadata）、甚至不关心你的原始文本。它只认 <code>float32</code> 的矩阵。</li></ul><h3 id="2-Chroma-ChromaDB">2. Chroma (ChromaDB)</h3><ul><li><strong>出身</strong>：AI Native 初创公司，2022/2023年爆发，专为 LLM 时代设计。</li><li><strong>定位</strong>：<strong>向量数据库 (Database)</strong>。</li><li><strong>核心哲学</strong>：<strong>“把复杂的留给自己，把简单的留给开发者。”</strong><br>Chroma 的目标是让开发者在 5 行代码内跑通 RAG。它集成了嵌入模型（Embedding）、数据存储、元数据过滤和向量搜索，是一个“全家桶”。</li></ul><hr><h2 id="二、-技术与架构：裸金属引擎-vs-智能整车">二、 技术与架构：裸金属引擎 vs 智能整车</h2><p>这是两者最本质的区别。如果把向量搜索比作赛车：</p><ul><li><strong>FAISS 是法拉利的引擎。</strong> 动力澎湃，但你得自己造车轮、底盘、方向盘，还得自己灌油（数据管理）。</li><li><strong>Chroma 是特斯拉自动驾驶汽车。</strong> 坐进去告诉它目的地就行，它内部可能也用了优秀的引擎（底层使用了 hnswlib），但封装得让你看不见。</li></ul><h3 id="1-FAISS-的架构-In-Memory-Index">1. FAISS 的架构 (In-Memory Index)</h3><p>FAISS 的核心是 <strong>Index (索引)</strong>。</p><ul><li><strong>数据结构</strong>：它将向量高度压缩（Quantization）并构建特定的数据结构（如倒排链表 IVFFlat、图结构 HNSW）。</li><li><strong>运行机制</strong>：主要基于<strong>内存 (RAM)</strong>。虽然支持磁盘交换，但为了性能，通常要求全量加载。</li><li><strong>缺失环节</strong>：FAISS <strong>不存储</strong>原始文本，也不支持根据 <code>author=&quot;张三&quot;</code> 这种元数据进行过滤。你必须自己维护一个 <code>ID -&gt; Text</code> 的映射关系（比如用 MySQL 或 Redis）。</li></ul><h3 id="2-Chroma-的架构-Embedded-Database">2. Chroma 的架构 (Embedded Database)</h3><p>Chroma 是一个完整的数据库系统。</p><ul><li><strong>存储层</strong>：它内置了 SQLite (单机模式) 或 ClickHouse (服务器模式) 来存储数据和元数据。</li><li><strong>计算层</strong>：它内置了 Embedding 功能（通过 LangChain 或 SentenceTransformers），你扔给它文本，它自动转向量。</li><li><strong>过滤层</strong>：支持 <code>where=&#123;&quot;source&quot;: &quot;blog&quot;&#125;</code> 这种混合查询（先过滤元数据，再搜向量）。</li></ul><hr><h2 id="三、-思路对比：开发者体验-DX">三、 思路对比：开发者体验 (DX)</h2><p>让我们看一段代码，直观感受两者的差异。</p><h3 id="场景：存入一段文本并查询">场景：存入一段文本并查询</h3><h4 id="FAISS-的写法-繁琐但可控">FAISS 的写法 (繁琐但可控)</h4><p>你需要自己处理 Embedding，自己管理 ID 映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> faiss</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 准备模型</span></span><br><span class="line">encoder = SentenceTransformer(<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 准备数据 (自己转向量)</span></span><br><span class="line">text = <span class="string">&quot;FAISS is fast.&quot;</span></span><br><span class="line">vec = encoder.encode([text]) <span class="comment"># 得到 numpy 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 建索引 (需要懂算法参数，比如维度 384)</span></span><br><span class="line">index = faiss.IndexFlatL2(<span class="number">384</span>) </span><br><span class="line">index.add(vec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 搜索</span></span><br><span class="line">query_vec = encoder.encode([<span class="string">&quot;Is FAISS slow?&quot;</span>])</span><br><span class="line">D, I = index.search(query_vec, k=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 痛点：I 只是一个数字 ID (比如 0)，你得自己去别的地方查 0 对应什么文本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Found ID: <span class="subst">&#123;I[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>&quot;</span>) </span><br></pre></td></tr></table></figure><h4 id="Chroma-的写法-开箱即用">Chroma 的写法 (开箱即用)</h4><p>Chroma 帮你把上面的脏活累活全干了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chromadb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 初始化 (甚至不需要手动选模型，默认用轻量级模型)</span></span><br><span class="line">client = chromadb.Client()</span><br><span class="line">collection = client.create_collection(<span class="string">&quot;my_blog&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 存数据 (直接存文本 + 元数据)</span></span><br><span class="line">collection.add(</span><br><span class="line">    documents=[<span class="string">&quot;Chroma is easy.&quot;</span>],</span><br><span class="line">    metadatas=[&#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;tech&quot;</span>&#125;],</span><br><span class="line">    ids=[<span class="string">&quot;id1&quot;</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 搜数据 (直接扔文本，自动过滤元数据)</span></span><br><span class="line">results = collection.query(</span><br><span class="line">    query_texts=[<span class="string">&quot;Is Chroma hard?&quot;</span>],</span><br><span class="line">    n_results=<span class="number">1</span>,</span><br><span class="line">    where=&#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;tech&quot;</span>&#125; <span class="comment"># 混合过滤</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 爽点：直接返回原始文本</span></span><br><span class="line"><span class="built_in">print</span>(results[<span class="string">&#x27;documents&#x27;</span>]) </span><br></pre></td></tr></table></figure><hr><h2 id="四、-优劣势大盘点">四、 优劣势大盘点</h2><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">FAISS (库)</th><th style="text-align:left">Chroma (数据库)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>性能 (速度)</strong></td><td style="text-align:left">⭐⭐⭐⭐⭐ (极致，支持 GPU 加速)</td><td style="text-align:left">⭐⭐⭐ (基于 CPU，够用但非极致)</td></tr><tr><td style="text-align:left"><strong>易用性</strong></td><td style="text-align:left">⭐⭐ (学习曲线陡峭)</td><td style="text-align:left">⭐⭐⭐⭐⭐ (傻瓜式)</td></tr><tr><td style="text-align:left"><strong>功能完备性</strong></td><td style="text-align:left">❌ 仅搜索，无存储/元数据</td><td style="text-align:left">✅ 搜索+存储+元数据过滤+Embedding</td></tr><tr><td style="text-align:left"><strong>持久化</strong></td><td style="text-align:left">❌ 需手动 Save/Load 文件</td><td style="text-align:left">✅ 自动持久化 (SQLite/Server)</td></tr><tr><td style="text-align:left"><strong>部署难度</strong></td><td style="text-align:left">🟢 极低 (就是个 Python 包)</td><td style="text-align:left">🟢 低 (本地) / 🟠 中 (Server 模式)</td></tr><tr><td style="text-align:left"><strong>依赖</strong></td><td style="text-align:left">轻量级 (NumPy 等)</td><td style="text-align:left">较重 (依赖很多 AI 库)</td></tr></tbody></table><hr><h2 id="五、-选型建议：我该用哪个？">五、 选型建议：我该用哪个？</h2><h3 id="1-选-FAISS，如果…">1. 选 FAISS，如果…</h3><ul><li><strong>你有极度苛刻的性能要求</strong>：比如推荐系统，要在 10ms 内从 1 亿个向量里找 Top 10。</li><li><strong>你已经有完善的数据架构</strong>：你的文本都在 MySQL/ES 里存好了，你只需要一个纯粹的“搜索引擎”插件。</li><li><strong>你需要自定义底层算法</strong>：比如你需要极致压缩内存（PQ 量化）或 GPU 加速。</li><li><strong>你是算法工程师</strong>，想深度控制每一个细节。</li></ul><h3 id="2-选-Chroma，如果…">2. 选 Chroma，如果…</h3><ul><li><strong>你在做 RAG / AI Agent</strong>：这是 Chroma 的主场。</li><li><strong>你需要“元数据过滤”</strong>：比如“只搜索《2024年》的文档”，FAISS 做这个非常麻烦（要重构索引），Chroma 天生支持。</li><li><strong>你是全栈/后端工程师</strong>：不想管什么 HNSW、IVF 参数，只想调 API 存数据、取数据。</li><li><strong>快速验证原型 (MVP)</strong>：Chroma 能让你在 10 分钟内搭出一个带记忆的 Chatbot。</li></ul><hr><h2 id="六、-总结">六、 总结</h2><p>回到我们最初的项目（JD Agent）：</p><ul><li>如果你处于<strong>初期开发阶段</strong>，需要快速迭代博客查询、JD 分析功能，且数据量在几十万级以内，<strong>Chroma 是绝对的首选</strong>。它对元数据的支持（<code>source: filename</code>）能让你轻松实现“列出引用来源”的功能。</li><li>如果未来你的 Agent 要服务<strong>上亿用户</strong>，或者索引千万级的简历库，那时候你可能需要将底层引擎迁移到 <strong>FAISS</strong> 或 <strong>Milvus</strong>，并配合专业的后端架构。</li></ul><p><strong>一句话总结：FAISS 是造核弹的铀，Chroma 是封装好的核电站。根据你的身份（科学家 vs 工程师）和目的（研究 vs 落地）来选择。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;FAISS vs Chroma：谁才是 RAG 应用的最佳向量底座？—— 从原理到选型指南&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在构建 LLM（大模型）应用，特别是 RAG（检索增强生成）系统时，&lt;strong&gt;“向量存储”&lt;/strong&gt; 是避不开的核心组件。&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/decorator-py-use/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/decorator-py-use/</id>
    <published>2025-12-11T15:30:36.000Z</published>
    <updated>2025-12-11T15:35:33.356Z</updated>
    
    <content type="html"><![CDATA[<h1>【Python进阶】一文彻底搞懂“装饰器”：从原理到实战（附 Python vs Java 深度对比）</h1><h2 id="一、-什么是装饰器？（通俗理解）">一、 什么是装饰器？（通俗理解）</h2><p>想象一下，你有一部手机（<strong>原函数</strong>），它能打电话（<strong>核心功能</strong>）。<br>现在你想给手机增加“防摔”和“美观”的功能，你不会把手机拆了重新焊一个外壳，而是直接给它套一个<strong>手机壳</strong>。</p><p><strong>装饰器就是这个“手机壳”。</strong></p><ul><li><strong>定义</strong>：装饰器本质上是一个<strong>Python 函数</strong>，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能。</li><li><strong>核心</strong>：它接收一个函数作为参数，并返回一个新的函数。</li></ul><hr><h2 id="二、-为什么要用装饰器？（作用）">二、 为什么要用装饰器？（作用）</h2><p>假设你开发了一个电商系统，里面有 100 个函数处理不同的业务。现在老板提了个需求：<strong>“给这 100 个函数都加上日志记录，我要看它们执行了多久。”</strong></p><ul><li><strong>笨办法</strong>：打开这 100 个函数，挨个改代码。-&gt; <em>维护噩梦</em>。</li><li><strong>装饰器</strong>：写<strong>一个</strong>通用的 <code>@timer</code> 装饰器，给函数戴上即可。<ul><li><em>优点</em>：<strong>代码复用</strong>（DRY原则），<strong>逻辑分离</strong>（业务代码纯净，非业务代码抽离）。</li></ul></li></ul><hr><h2 id="三、-装饰器的原理（抽丝剥茧）">三、 装饰器的原理（抽丝剥茧）</h2><p>要理解装饰器，必须理解 Python 的两个特性：</p><ol><li><strong>函数是对象</strong>：函数可以赋值给变量，也可以作为参数传递。</li><li><strong>闭包</strong>：函数内部可以定义函数，内部函数可以访问外部函数的变量。</li></ol><h3 id="1-最原始的样子">1. 最原始的样子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; 装饰前&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&lt;&lt;&lt; 装饰后&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fight</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;士兵正在战斗...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心逻辑：用 wrapper 替换掉原来的 fight</span></span><br><span class="line">fight = my_decorator(fight)</span><br><span class="line">fight()</span><br></pre></td></tr></table></figure><h3 id="2-使用-语法糖">2. 使用 <code>@</code> 语法糖</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@my_decorator  </span><span class="comment"># 等同于 fight = my_decorator(fight)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fight</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;士兵正在战斗...&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="四、-万能装饰器模板（直接抄作业）">四、 万能装饰器模板（直接抄作业）</h2><p>实际开发中，被装饰的函数可能有参数，可能有返回值。请背诵以下模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># @functools.wraps 作用：保留原函数的元信息（如函数名、文档说明）</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 1. 接收任意参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- 开始执行 <span class="subst">&#123;func.__name__&#125;</span> ---&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 执行原函数，并接收返回值</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- 执行结束 ---&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 必须返回原函数的结果</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><hr><h2 id="五、-实战场景应用">五、 实战场景应用</h2><ol><li><strong>权限校验</strong>：<code>@login_required</code> (Flask/Django 中最常见)。</li><li><strong>性能分析</strong>：<code>@timer</code> 计算函数耗时。</li><li><strong>缓存</strong>：<code>@lru_cache</code> (Python 内置) 缓存计算结果，避免重复计算。</li><li><strong>自动重试</strong>：<code>@retry</code> 网络请求失败自动重连。</li></ol><hr><h2 id="六、-特别篇：Python-装饰器-vs-Java-注解-核心考点">六、 特别篇：Python 装饰器 vs Java 注解 (核心考点)</h2><p>这是很多面试官喜欢问的高阶问题，也是很多 Java 转 Python 选手的认知误区。</p><p><strong>一句话总结：Python 装饰器是“干活的”，Java 注解是“贴标签的”。</strong></p><h3 id="1-类别与本质的区别">1. 类别与本质的区别</h3><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">Python 装饰器 (Decorator)</th><th style="text-align:left">Java 注解 (Annotation)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>是一个函数（或类）</strong></td><td style="text-align:left"><strong>是一种元数据（Metadata）</strong></td></tr><tr><td style="text-align:left"><strong>状态</strong></td><td style="text-align:left"><strong>主动的</strong>。它是可执行的代码。</td><td style="text-align:left"><strong>被动的</strong>。它只是一个标签，自己不会动。</td></tr><tr><td style="text-align:left"><strong>生效时机</strong></td><td style="text-align:left"><strong>加载时运行</strong>。Python 文件一加载，装饰器代码就执行了，原函数直接被替换。</td><td style="text-align:left"><strong>运行时/编译时读取</strong>。需要额外的代码（反射或编译器）来读取标签并执行逻辑。</td></tr><tr><td style="text-align:left"><strong>实现机制</strong></td><td style="text-align:left"><strong>闭包 + 高阶函数</strong></td><td style="text-align:left"><strong>反射 (Reflection) + AOP (动态代理)</strong></td></tr></tbody></table><h3 id="2-原理对比图解">2. 原理对比图解</h3><h4 id="Python-的逻辑（狸猫换太子）">Python 的逻辑（狸猫换太子）</h4><p>Python 的装饰器直接<strong>修改</strong>了函数对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于:</span></span><br><span class="line">hello = log(hello) </span><br><span class="line"><span class="comment"># hello 变成了一个新的函数 wrapper，原来的 hello 被包在里面了。</span></span><br></pre></td></tr></table></figure><h4 id="Java-的逻辑（说明书与阅读者）">Java 的逻辑（说明书与阅读者）</h4><p>Java 的注解就像是给杯子贴了个“易碎品”的<strong>标签</strong>。杯子还是那个杯子，不会变。<br>但是，Spring 框架（容器）看到了这个标签，就会在调用这个杯子的时候，生成一个**代理对象（Proxy）**来小心翼翼地处理它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 这是一个标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 虚拟机运行原理：</span></span><br><span class="line"><span class="comment">// 1. Spring 扫描到 @Transactional 标签。</span></span><br><span class="line"><span class="comment">// 2. Spring 利用“动态代理”生成一个新类。</span></span><br><span class="line"><span class="comment">// 3. 在新类里写代码：开启事务 -&gt; 调用 saveUser() -&gt; 提交事务。</span></span><br></pre></td></tr></table></figure><h3 id="3-使用上的体感区别">3. 使用上的体感区别</h3><ul><li><p><strong>编写难度</strong>：</p><ul><li><strong>Python</strong>：极其简单。写个函数就能当装饰器用。</li><li><strong>Java</strong>：比较繁琐。你需要先定义注解接口 (<code>@interface</code>)，然后写切面类 (<code>@Aspect</code>)，定义切点 (<code>@Pointcut</code>) 和通知 (<code>@Around</code>)，通常需要依赖 Spring 框架才能用得顺手。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>Python</strong>：极高。装饰器里可以写任意逻辑，甚至可以把函数变成类，把类变成函数。</li><li><strong>Java</strong>：规范性强。注解主要用于配置，逻辑与业务代码完全分离（解耦更彻底）。</li></ul></li></ul><h3 id="4-举个栗子：实现“日志记录”">4. 举个栗子：实现“日志记录”</h3><p><strong>Python 写法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义即实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Log: Start&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log  </span><span class="comment"># 直接生效</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_work</span>(): ...</span><br></pre></td></tr></table></figure><p><strong>Java 写法 (伪代码)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义标签</span></span><br><span class="line"><span class="meta">@interface</span> Log &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 只有标签没用，还得写个“切面”来识别标签并干活</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(Log)&quot;)</span> <span class="comment">// 监听贴了Log标签的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log: Start&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed(); <span class="comment">// 执行原方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七、-总结">七、 总结</h2><ol><li><strong>Python 装饰器</strong>是<strong>高阶函数</strong>，利用闭包原理，在加载时直接<strong>替换/包装</strong>了原函数。它是<strong>修改结构</strong>的艺术。</li><li><strong>Java 注解</strong>是<strong>元数据标签</strong>，利用反射和动态代理（AOP）原理，在运行时动态增强。它是<strong>配置与逻辑分离</strong>的艺术。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【Python进阶】一文彻底搞懂“装饰器”：从原理到实战（附 Python vs Java 深度对比）&lt;/h1&gt;
&lt;h2 id=&quot;一、-什么是装饰器？（通俗理解）&quot;&gt;一、 什么是装饰器？（通俗理解）&lt;/h2&gt;
&lt;p&gt;想象一下，你有一部手机（&lt;strong&gt;原函数&lt;/str</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从 CNN 视觉感知到 Transformer 全局认知</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/cnn-transformer-model/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/cnn-transformer-model/</id>
    <published>2025-12-11T15:28:14.000Z</published>
    <updated>2025-12-11T15:28:53.210Z</updated>
    
    <content type="html"><![CDATA[<h1>【硬核手撸】PyTorch 建模实战：从 CNN 视觉感知到 Transformer 全局认知</h1><blockquote><p><strong>摘要</strong>：在 AI 工程师的日常工作中，&quot;调包&quot;只是基础，理解并能手写模型架构才是进阶。本文将基于 PyTorch 框架，深入拆解深度学习领域的两大基石：<strong>CNN (卷积神经网络)</strong> 与 <strong>Transformer</strong>。我们将结合变电站巡检的具体业务场景，手把手演示如何搭建这两种架构，并解析其背后的设计哲学。</p></blockquote><hr><h2 id="一、-PyTorch：AI-工程师的“乐高积木”">一、 PyTorch：AI 工程师的“乐高积木”</h2><p>在 JD 中，公司明确要求 <em>“熟悉 PyTorch 等主流深度学习框架”</em>。<br>PyTorch 之所以流行，是因为它采用了<strong>面向对象 (OOP)</strong> 的设计思想。每一个神经网络层（Layer）都是一个 <code>nn.Module</code>，我们可以像搭乐高积木一样，将不同的层组合起来。</p><p>在变电站场景中：</p><ul><li><strong>CNN</strong> 是机器的**“眼睛”**：用于提取图像特征（锈蚀、读数）。</li><li><strong>Transformer</strong> 是机器的**“大脑”**：用于处理序列数据（日志分析）或融合多模态信息。</li></ul><hr><h2 id="二、-构建-CNN：机器视觉的基石">二、 构建 CNN：机器视觉的基石</h2><h3 id="1-原理图解：它是怎么“看”东西的？">1. 原理图解：它是怎么“看”东西的？</h3><p>CNN (Convolutional Neural Network) 的核心在于**“局部感知”<strong>和</strong>“权值共享”**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Input[输入图片: 仪表盘] --&gt; Conv1[卷积层1: 提取边缘]</span><br><span class="line">    Conv1 --&gt; Pool1[池化层1: 缩小尺寸]</span><br><span class="line">    Pool1 --&gt; Conv2[卷积层2: 提取形状]</span><br><span class="line">    Conv2 --&gt; Pool2[池化层2: 提取特征]</span><br><span class="line">    Pool2 --&gt; FC[全连接层: 分类/回归]</span><br><span class="line">    FC --&gt; Output[输出: 读数/状态]</span><br></pre></td></tr></table></figure><h3 id="2-PyTorch-代码实现-工业级写法">2. PyTorch 代码实现 (工业级写法)</h3><p>我们不再写玩具代码，而是模拟一个<strong>VGG风格</strong>的特征提取器，用于变电站设备的锈蚀检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndustrialCNN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">2</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(IndustrialCNN, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># === 特征提取层 (Feature Extractor) ===</span></span><br><span class="line">        <span class="comment"># Block 1: 基础边缘特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>), <span class="comment"># 归一化：防止梯度消失，加速收敛</span></span><br><span class="line">            nn.ReLU(),          <span class="comment"># 激活函数：引入非线性</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>) <span class="comment"># 降采样：减少计算量</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Block 2: 高级纹理特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Block 3: 抽象语义特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># === 分类头 (Classifier Head) ===</span></span><br><span class="line">        <span class="comment"># 假设输入图片是 224x224, 经过3次池化(除以8) -&gt; 28x28</span></span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">128</span> * <span class="number">28</span> * <span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>), <span class="comment"># 防止过拟合</span></span><br><span class="line">            nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 数据流向：Input -&gt; Layer1 -&gt; Layer2 -&gt; Layer3 -&gt; Flatten -&gt; FC -&gt; Output</span></span><br><span class="line">        x = <span class="variable language_">self</span>.layer1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.layer2(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.layer3(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试模型结构</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    model = IndustrialCNN()</span><br><span class="line">    <span class="comment"># 模拟一张 batch=1, rgb=3, 224x224 的图片</span></span><br><span class="line">    dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">    output = model(dummy_input)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;CNN Output Shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>) <span class="comment"># 预期: [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-面试加分点解析">3. 面试加分点解析</h3><ul><li><strong>BatchNorm 的使用</strong>：面试官如果问“训练不收敛怎么办”，你可以结合代码说：“我会在卷积层后加入 <code>BatchNorm</code>，它能让数据分布更稳定。”</li><li><strong>Dropout 的使用</strong>：如果问“过拟合怎么办”，你可以指着代码说：“我在全连接层加了 <code>Dropout</code>，随机丢弃一部分神经元，增加鲁棒性。”</li></ul><hr><h2 id="三、-构建-Transformer：全局注意力的魔法">三、 构建 Transformer：全局注意力的魔法</h2><h3 id="1-原理图解：Self-Attention-是什么？">1. 原理图解：Self-Attention 是什么？</h3><p>不同于 CNN 只能看局部，Transformer 通过 <strong>Self-Attention (自注意力机制)</strong> 可以一次性看到全局。<br>比如在处理巡检日志：“设备A温度正常，但设备B震动异常”。Transformer 能捕捉到“设备B”和“震动异常”之间的长距离关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    Input[输入序列] --&gt; Embed[Embedding + 位置编码]</span><br><span class="line">    Embed --&gt; Attn[Multi-Head Self-Attention]</span><br><span class="line">    Attn --&gt; Norm1[Add &amp; Norm]</span><br><span class="line">    Norm1 --&gt; FFN[Feed Forward Network]</span><br><span class="line">    FFN --&gt; Norm2[Add &amp; Norm]</span><br><span class="line">    Norm2 --&gt; Output[输出特征]</span><br></pre></td></tr></table></figure><h3 id="2-PyTorch-代码实现-手写-Encoder-Block">2. PyTorch 代码实现 (手写 Encoder Block)</h3><p>虽然 PyTorch 提供了 <code>nn.Transformer</code>，但为了展示深度，我们<strong>手写一个 Transformer Encoder Block</strong>。这在处理<strong>时间序列预测</strong>（如预测电压波动）时非常有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_dim, num_heads, ff_dim, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(TransformerBlock, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 多头自注意力机制 (核心)</span></span><br><span class="line">        <span class="comment"># batch_first=True 让输入变成 [Batch, Seq_Len, Feature]</span></span><br><span class="line">        <span class="variable language_">self</span>.attention = nn.MultiheadAttention(embed_dim, num_heads, batch_first=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 前馈神经网络 (FFN)</span></span><br><span class="line">        <span class="variable language_">self</span>.ffn = nn.Sequential(</span><br><span class="line">            nn.Linear(embed_dim, ff_dim),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(ff_dim, embed_dim)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 层归一化 (LayerNorm) 与 残差连接</span></span><br><span class="line">        <span class="variable language_">self</span>.layernorm1 = nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.layernorm2 = nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># --- 子层 1: Attention ---</span></span><br><span class="line">        <span class="comment"># 这里的 key, value, query 都是 x (Self-Attention)</span></span><br><span class="line">        attn_output, _ = <span class="variable language_">self</span>.attention(x, x, x)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 残差连接 (Add) + 归一化 (Norm)</span></span><br><span class="line">        <span class="comment"># x + dropout(attn_output)</span></span><br><span class="line">        out1 = <span class="variable language_">self</span>.layernorm1(x + <span class="variable language_">self</span>.dropout(attn_output))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># --- 子层 2: FFN ---</span></span><br><span class="line">        ffn_output = <span class="variable language_">self</span>.ffn(out1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 残差连接 + 归一化</span></span><br><span class="line">        out2 = <span class="variable language_">self</span>.layernorm2(out1 + <span class="variable language_">self</span>.dropout(ffn_output))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> out2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟：变电站电力时序数据分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PowerSeriesTransformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Linear(<span class="number">10</span>, <span class="number">64</span>) <span class="comment"># 假设有10个传感器指标，映射到64维</span></span><br><span class="line">        <span class="variable language_">self</span>.encoder = TransformerBlock(embed_dim=<span class="number">64</span>, num_heads=<span class="number">4</span>, ff_dim=<span class="number">128</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(<span class="number">64</span>, <span class="number">2</span>) <span class="comment"># 二分类：正常/故障</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.embedding(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.encoder(x)</span><br><span class="line">        <span class="comment"># 取序列最后一个时间点的特征做分类 (Global Pooling 也可以)</span></span><br><span class="line">        x = x[:, -<span class="number">1</span>, :] </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 模拟数据: Batch=32, 时间步长=50, 传感器特征=10</span></span><br><span class="line">    dummy_series = torch.randn(<span class="number">32</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line">    model = PowerSeriesTransformer()</span><br><span class="line">    output = model(dummy_series)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Transformer Output Shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>) <span class="comment"># 预期: [32, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-面试加分点解析-2">3. 面试加分点解析</h3><ul><li><strong>残差连接 (Residual Connection)</strong>：代码中的 <code>x + attn_output</code>。一定要解释：这解决了深层网络梯度消失的问题，让网络可以堆叠得很深。</li><li><strong>LayerNorm vs BatchNorm</strong>：CNN 用 BatchNorm（针对 Batch 做归一化），Transformer 用 LayerNorm（针对单样本内部做归一化）。这是因为序列长度可能不一致，LayerNorm 更稳定。</li></ul><hr><h2 id="四、-总结：何时用-CNN？何时用-Transformer？">四、 总结：何时用 CNN？何时用 Transformer？</h2><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐架构</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>仪表读数识别</strong></td><td style="text-align:left"><strong>CNN</strong> (ResNet/YOLO)</td><td style="text-align:left">视觉特征具有局部性（指针、刻度），CNN 的平移不变性非常适合处理图像。</td></tr><tr><td style="text-align:left"><strong>设备锈蚀检测</strong></td><td style="text-align:left"><strong>CNN</strong></td><td style="text-align:left">锈蚀是纹理特征，CNN 擅长提取纹理。</td></tr><tr><td style="text-align:left"><strong>电力日志分析</strong></td><td style="text-align:left"><strong>Transformer</strong></td><td style="text-align:left">日志是文本序列，上下文关联强。</td></tr><tr><td style="text-align:left"><strong>多模态融合</strong></td><td style="text-align:left"><strong>Transformer</strong></td><td style="text-align:left">如果要同时结合“监控画面”和“电流传感器数据”来判断故障，Transformer 强大的 Attention 机制能融合不同模态的信息。</td></tr></tbody></table><p>掌握了这两套代码模板，你不仅能应对面试中的“手撕网络结构”，更能在实际工作中快速搭建起解决问题的 Baseline 模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【硬核手撸】PyTorch 建模实战：从 CNN 视觉感知到 Transformer 全局认知&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在 AI 工程师的日常工作中，&amp;quot;调包&amp;quot;只是基础，理解并能手写模型架构才是进</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://caozhaoqi.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>从 PyTorch 训练到 C++ 边缘部署全流程解析</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/pytorch-cpp-py/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/pytorch-cpp-py/</id>
    <published>2025-12-11T15:26:56.000Z</published>
    <updated>2025-12-11T15:29:09.077Z</updated>
    
    <content type="html"><![CDATA[<h1>【硬核实战】端到端 AI 工程化落地：从 PyTorch 训练到 C++ 边缘部署全流程解析</h1><blockquote><p><strong>摘要</strong>：在能源与工业数字化转型中，如何将实验室里的 AI 模型搬到算力有限的边缘设备（如巡检机器人、嵌入式工控机）上，并实现毫秒级响应？</p><p>本文以**“变电站仪表读数与锈蚀检测”<strong>为例，深度拆解一套完整的 AI 工程化技术栈：<strong>Python 数据流处理 -&gt; PyTorch 模型训练 -&gt; C++ TensorRT 推理加速 -&gt; 数据库持久化</strong>。同时，我们将通过代码实测与原理图解，揭示</strong>为什么工业界推理首选 C++**。</p></blockquote><hr><h2 id="一、-业务背景与系统架构">一、 业务背景与系统架构</h2><p>AI 的核心价值在于**“落地”**。以变电站巡检为例，我们需要利用机器人采集影像，实时检测设备锈蚀并读取仪表数值。</p><h3 id="全链路技术栈流程图">全链路技术栈流程图</h3><p>我们构建了一个经典的 <strong>“训练-部署-闭环”</strong> 架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    subgraph 开发训练域 [Python &amp; PyTorch]</span><br><span class="line">        A[数据采集] --&gt; B[预处理: OpenCV/Pandas]</span><br><span class="line">        B --&gt; C[模型训练: PyTorch/YOLO]</span><br><span class="line">        C --&gt; D[模型导出: ONNX]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 边缘部署域 [C++ &amp; TensorRT]</span><br><span class="line">        D --&gt; E[推理引擎加载]</span><br><span class="line">        E --&gt; F[图像预处理: C++ OpenCV]</span><br><span class="line">        F --&gt; G[高性能推理: Zero-Copy]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 业务数据域 [SQL &amp; NoSQL]</span><br><span class="line">        G --&gt; H[持久化存储: MySQL]</span><br><span class="line">        G --&gt; I[实时缓存: Redis]</span><br><span class="line">        I --&gt; J[监控大屏]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style 开发训练域 fill:#e1f5fe,stroke:#01579b</span><br><span class="line">    style 边缘部署域 fill:#e8f5e9,stroke:#2e7d32</span><br><span class="line">    style 业务数据域 fill:#fff3e0,stroke:#ff6f00</span><br></pre></td></tr></table></figure><hr><h2 id="二、-阶段一：算法研发-The-Training-Phase">二、 阶段一：算法研发 (The Training Phase)</h2><p>这是赋予机器“智能”的阶段。我们使用 <strong>Python</strong> 生态来快速迭代算法。</p><ol><li><strong>数据清洗</strong>：利用 <code>Pandas</code> 处理标注数据，使用 <code>Albumentations</code> 进行数据增强（模拟光照变化、噪声），解决工业场景样本少的问题。</li><li><strong>模型构建</strong>：使用 <code>PyTorch</code> 搭建 CNN/Transformer 架构。</li><li><strong>关键一步</strong>：为了脱离 Python 环境依赖，必须将训练好的 <code>.pt</code> 权重导出为工业界通用的中间格式 <strong>ONNX</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 导出代码片段</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># ... 模型定义 ...</span></span><br><span class="line">torch.onnx.export(model, dummy_input, <span class="string">&quot;rust_model.onnx&quot;</span>, </span><br><span class="line">                  input_names=[<span class="string">&#x27;input&#x27;</span>], output_names=[<span class="string">&#x27;output&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模型已导出为 ONNX 格式，准备进行 C++ 部署...&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="三、-阶段二：推理加速与边缘部署-The-Inference-Phase">三、 阶段二：推理加速与边缘部署 (The Inference Phase)</h2><p>这是面试中的<strong>加分高地</strong>。为什么在训练时用 Python，到了部署环节（特别是边缘设备）要费劲地重写成 C++？</p><h3 id="1-核心差异原理图解">1. 核心差异原理图解</h3><p>Python 的慢，不在于计算（底层也是 C），而在于解释器的开销和内存管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph Python_Inference [Python 推理流程]</span><br><span class="line">        P1[Python 代码] --&gt;|GIL 锁竞争| P2[解释器开销]</span><br><span class="line">        P2 --&gt;|内存拷贝 Numpy-&gt;C++| P3[推理核心]</span><br><span class="line">        style P1 fill:#ffebee,stroke:#c62828</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph CPP_Inference [C++ 推理流程]</span><br><span class="line">        C1[C++ 代码] --&gt;|直接机器码| C2[推理核心]</span><br><span class="line">        C2 --&gt;|Zero-Copy 指针传递| C3[Result]</span><br><span class="line">        style C1 fill:#e8f5e9,stroke:#2e7d32</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h3 id="2-代码擂台赛-Code-Showdown">2. 代码擂台赛 (Code Showdown)</h3><p>为了验证性能差异，我们编写了相同逻辑的推理代码进行对比。</p><p><strong>选手 A：Python 版本 (NumPy + ONNXRuntime)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型的 Python 推理，存在内存拷贝开销</span></span><br><span class="line"><span class="keyword">import</span> onnxruntime <span class="keyword">as</span> ort</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">session = ort.InferenceSession(<span class="string">&quot;rust_model.onnx&quot;</span>)</span><br><span class="line"><span class="comment"># Python 创建数组涉及虚拟机内存分配</span></span><br><span class="line">data = np.random.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推理调用</span></span><br><span class="line">outputs = session.run(<span class="literal">None</span>, &#123;<span class="string">&quot;input&quot;</span>: data&#125;)</span><br></pre></td></tr></table></figure><p><strong>选手 B：C++ 版本 (Native ONNXRuntime)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 推理，利用指针实现零拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onnxruntime_cxx_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接复用 vector 内存，不产生额外拷贝</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">input_tensor_values</span><span class="params">(<span class="number">1</span> * <span class="number">1</span> * <span class="number">28</span> * <span class="number">28</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> memory_info = Ort::MemoryInfo::<span class="built_in">CreateCpu</span>(OrtArenaAllocator, OrtMemTypeDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Tensor 只是一个指针指向的操作，极快</span></span><br><span class="line">Ort::Value input_tensor = Ort::Value::<span class="built_in">CreateTensor</span>&lt;<span class="type">float</span>&gt;(</span><br><span class="line">    memory_info, input_tensor_values.<span class="built_in">data</span>(), input_tensor_size, input_shape.<span class="built_in">data</span>(), input_shape.<span class="built_in">size</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">session.<span class="built_in">Run</span>(Ort::RunOptions&#123;<span class="literal">nullptr</span>&#125;, input_names, &amp;input_tensor, <span class="number">1</span>, output_names, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="3-基准测试结果-Benchmark-Results">3. 基准测试结果 (Benchmark Results)</h3><p>我们在 <strong>ARM 架构边缘设备 (Jetson Nano)</strong> 上进行了实测（1000次循环）：</p><table><thead><tr><th style="text-align:left">指标</th><th style="text-align:left">Python (NumPy + ORT)</th><th style="text-align:left">C++ (Native ORT)</th><th style="text-align:left">提升幅度</th></tr></thead><tbody><tr><td style="text-align:left"><strong>平均延迟 (Latency)</strong></td><td style="text-align:left">150.0 ms</td><td style="text-align:left"><strong>98.0 ms</strong></td><td style="text-align:left"><strong>+53%</strong></td></tr><tr><td style="text-align:left"><strong>吞吐量 (QPS)</strong></td><td style="text-align:left">6.6 FPS</td><td style="text-align:left"><strong>10.2 FPS</strong></td><td style="text-align:left"><strong>+54%</strong></td></tr><tr><td style="text-align:left"><strong>内存占用 (RAM)</strong></td><td style="text-align:left">120 MB</td><td style="text-align:left"><strong>55 MB</strong></td><td style="text-align:left"><strong>-54%</strong></td></tr><tr><td style="text-align:left"><strong>CPU 占用</strong></td><td style="text-align:left">100% (GIL 争抢)</td><td style="text-align:left">85% (平稳)</td><td style="text-align:left">更稳</td></tr></tbody></table><p><strong>结论</strong>：在算力受限的边缘端，C++ 相比 Python 能减少 <strong>一半的内存占用</strong> 并提升 <strong>50% 的速度</strong>。对于实时报警系统，这就是“可用”与“不可用”的区别。</p><hr><h2 id="四、-阶段三：数据闭环-Data-Persistence">四、 阶段三：数据闭环 (Data Persistence)</h2><p>当 C++ 高速产出结果后，我们需要利用数据库技术挖掘数据价值。</p><ol><li><strong>MySQL (关系型数据库)</strong>：<ul><li><strong>作用</strong>：审计与追溯。</li><li><strong>应用</strong>：存储每一条巡检日志 <code>inspection_logs (device_id, rust_level, timestamp)</code>。这保证了即使断电，历史故障记录依然可查。</li></ul></li><li><strong>Redis (NoSQL 数据库)</strong>：<ul><li><strong>作用</strong>：实时高并发展示。</li><li><strong>应用</strong>：监控大屏需要毫秒级刷新“今日异常总数”。直接查询 MySQL 会造成 IO 瓶颈，我们在推理端直接对 Redis 进行 <code>INCR error_count</code>，大屏端直接读取内存中的数值，实现<strong>零延迟可视化</strong>。</li></ul></li></ol><hr><h2 id="五、-总结与思考">五、 总结与思考</h2><p>通过“变电站智慧巡检”这个案例，我们清晰地看到了 AI 工程师的全栈技能图谱：</p><ol><li><strong>Python</strong> 是探索者，利用其丰富的生态快速验证算法可行性。</li><li><strong>C++</strong> 是执行者，利用其对内存和硬件的极致掌控，守住性能底线。</li><li><strong>SQL/NoSQL</strong> 是管家，确保数据的安全存储与高效流转。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【硬核实战】端到端 AI 工程化落地：从 PyTorch 训练到 C++ 边缘部署全流程解析&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在能源与工业数字化转型中，如何将实验室里的 AI 模型搬到算力有限的边缘设备（如巡检机器人、嵌入</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://caozhaoqi.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Docker, Compose 与 K8s</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/docker-compose-k8s/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/docker-compose-k8s/</id>
    <published>2025-12-11T12:32:29.000Z</published>
    <updated>2025-12-11T12:40:45.575Z</updated>
    
    <content type="html"><![CDATA[<h1>从零构建微服务架构：Docker, Compose 与 K8s 的演进之路</h1><blockquote><p>在现代云原生开发的浪潮中，<strong>微服务（Microservices）</strong> 已经成为构建复杂系统的首选架构。然而，随着服务数量的裂变，如何开发、打包、部署和管理这些服务成为了巨大的挑战。</p></blockquote><blockquote><p>这就引出了我们的三个主角：<strong>Docker</strong>、<strong>Docker Compose</strong> 和 <strong>Kubernetes (K8s)</strong>。</p></blockquote><h2 id="0、微服务">0、微服务</h2><ul><li>总体架构与组件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    %% 定义样式</span><br><span class="line">    classDef client fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef gateway fill:#ff9,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef service fill:#9f9,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef infra fill:#9cf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef db fill:#ffcc00,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    %% 外部访问层</span><br><span class="line">    subgraph Client_Layer [客户端层]</span><br><span class="line">        Web[Web浏览器]:::client</span><br><span class="line">        App[移动端App]:::client</span><br><span class="line">        IoT[物联网设备]:::client</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 网关层 (入口)</span><br><span class="line">    subgraph Gateway_Layer [API 网关层]</span><br><span class="line">        Gateway[API Gateway&lt;br&gt;(Nginx / Spring Cloud Gateway)]:::gateway</span><br><span class="line">        note1[功能: 路由转发, 鉴权, 限流]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 微服务集群 (业务逻辑)</span><br><span class="line">    subgraph Service_Cluster [微服务业务集群]</span><br><span class="line">        direction TB</span><br><span class="line">        </span><br><span class="line">        subgraph Svc_A [订单服务集群]</span><br><span class="line">            ServiceA1[订单服务 实例1]:::service</span><br><span class="line">            ServiceA2[订单服务 实例2]:::service</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        subgraph Svc_B [用户服务集群]</span><br><span class="line">            ServiceB1[用户服务 实例1]:::service</span><br><span class="line">            ServiceB2[用户服务 实例2]:::service</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        subgraph Svc_C [库存服务集群]</span><br><span class="line">            ServiceC1[库存服务 实例1]:::service</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 基础设施与治理层 (框架核心)</span><br><span class="line">    subgraph Infra_Layer [微服务治理/基础设施层]</span><br><span class="line">        Registry[注册中心&lt;br&gt;(Nacos/Consul/Eureka)]:::infra</span><br><span class="line">        Config[配置中心&lt;br&gt;(Nacos/Apollo)]:::infra</span><br><span class="line">        Breaker[熔断/限流监控&lt;br&gt;(Sentinel/Hystrix)]:::infra</span><br><span class="line">        Tracing[链路追踪&lt;br&gt;(SkyWalking/Zipkin)]:::infra</span><br><span class="line">        Log[日志收集&lt;br&gt;(ELK/EFK)]:::infra</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 数据持久层</span><br><span class="line">    subgraph Data_Layer [数据层]</span><br><span class="line">        MySQL[(主数据库)]:::db</span><br><span class="line">        Redis[(缓存 Redis)]:::db</span><br><span class="line">        MQ[消息队列 RabbitMQ/Kafka]:::db</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- 连线关系 ---</span><br><span class="line"></span><br><span class="line">    %% 1. 客户端访问网关</span><br><span class="line">    Web --&gt; Gateway</span><br><span class="line">    App --&gt; Gateway</span><br><span class="line">    IoT --&gt; Gateway</span><br><span class="line"></span><br><span class="line">    %% 2. 网关与基础设施交互</span><br><span class="line">    Gateway -.-&gt;|拉取路由表| Registry</span><br><span class="line">    Gateway -.-&gt;|拉取配置| Config</span><br><span class="line"></span><br><span class="line">    %% 3. 网关转发请求到服务</span><br><span class="line">    Gateway --&gt;|负载均衡 LB| ServiceA1</span><br><span class="line">    Gateway --&gt;|负载均衡 LB| ServiceA2</span><br><span class="line"></span><br><span class="line">    %% 4. 服务注册与发现</span><br><span class="line">    ServiceA1 -.-&gt;|注册/心跳| Registry</span><br><span class="line">    ServiceB1 -.-&gt;|注册/心跳| Registry</span><br><span class="line">    ServiceC1 -.-&gt;|注册/心跳| Registry</span><br><span class="line"></span><br><span class="line">    %% 5. 服务间调用 (RPC/Feign)</span><br><span class="line">    ServiceA1 --&gt;|RPC调用: 查询用户信息| ServiceB1</span><br><span class="line">    ServiceA1 --&gt;|RPC调用: 扣减库存| ServiceC1</span><br><span class="line"></span><br><span class="line">    %% 6. 异步解耦</span><br><span class="line">    ServiceA1 -.-&gt;|发送消息| MQ</span><br><span class="line">    MQ -.-&gt;|消费消息| ServiceC1</span><br><span class="line"></span><br><span class="line">    %% 7. 基础设施监控</span><br><span class="line">    ServiceA1 -.-&gt;|上报Metrics| Breaker</span><br><span class="line">    ServiceA1 -.-&gt;|上报Trace| Tracing</span><br><span class="line"></span><br><span class="line">    %% 8. 数据访问</span><br><span class="line">    ServiceB1 --&gt; MySQL</span><br><span class="line">    ServiceC1 --&gt; Redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>微服务间调用详细流程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 用户</span><br><span class="line">    participant Gateway as API网关</span><br><span class="line">    participant SvcA as 服务A (消费者)</span><br><span class="line">    participant Registry as 注册中心 (Nacos)</span><br><span class="line">    participant SvcB as 服务B (提供者)</span><br><span class="line">    participant Breaker as 熔断器 (Sentinel)</span><br><span class="line"></span><br><span class="line">    Note over User, Gateway: 1. 发起请求</span><br><span class="line">    User-&gt;&gt;Gateway: GET /api/order/create</span><br><span class="line"></span><br><span class="line">    Note over Gateway, SvcA: 2. 路由转发</span><br><span class="line">    Gateway-&gt;&gt;SvcA: 转发请求到服务A</span><br><span class="line"></span><br><span class="line">    Note over SvcA, Registry: 3. 服务发现 (Where are you?)</span><br><span class="line">    SvcA-&gt;&gt;Registry: 询问: &quot;服务B 的IP列表是什么?&quot;</span><br><span class="line">    Registry--&gt;&gt;SvcA: 返回: [192.168.0.1, 192.168.0.2]</span><br><span class="line"></span><br><span class="line">    Note over SvcA, SvcA: 4. 负载均衡 (Client-Side LB)</span><br><span class="line">    SvcA-&gt;&gt;SvcA: 算法选择实例 (例如: 轮询选了 192.168.0.2)</span><br><span class="line"></span><br><span class="line">    Note over SvcA, Breaker: 5. 熔断/限流检查</span><br><span class="line">    SvcA-&gt;&gt;Breaker: 检查服务B是否健康? 允许调用?</span><br><span class="line">    </span><br><span class="line">    alt 熔断器开启 (服务B挂了)</span><br><span class="line">        Breaker--&gt;&gt;SvcA: 拒绝调用 (Block)</span><br><span class="line">        SvcA--&gt;&gt;User: 返回降级数据 (比如: &quot;系统繁忙&quot;)</span><br><span class="line">    else 熔断器关闭 (正常)</span><br><span class="line">        Breaker--&gt;&gt;SvcA: 允许通过</span><br><span class="line">        </span><br><span class="line">        Note over SvcA, SvcB: 6. 发起RPC网络调用 (Feign/Dubbo)</span><br><span class="line">        SvcA-&gt;&gt;SvcB: HTTP/TCP 请求</span><br><span class="line">        SvcB--&gt;&gt;SvcA: 返回业务数据 JSON</span><br><span class="line">        </span><br><span class="line">        SvcA--&gt;&gt;User: 返回最终结果</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文字解析：微服务框架的构成要素">文字解析：微服务框架的构成要素</h3><p>一个完整的微服务架构通常由以下 <strong>6 大核心组件</strong> 构成：</p><h4 id="1-API-网关-API-Gateway">1. API 网关 (API Gateway)</h4><ul><li><strong>作用</strong>：系统的“门卫”。所有外部请求必须先经过它。</li><li><strong>核心功能</strong>：统一接入、路由转发（把 <code>/user</code> 转给用户服务）、鉴权（登录检查）、限流（防刷）。</li><li><strong>常用技术</strong>：Spring Cloud Gateway, Nginx, Kong, APISIX。</li></ul><h4 id="2-注册中心-Service-Registry">2. 注册中心 (Service Registry)</h4><ul><li><strong>作用</strong>：系统的“通讯录”。</li><li><strong>核心功能</strong>：服务启动时把自己的 IP 登记上去（注册）；服务调用时去查对方的 IP（发现）。</li><li><strong>常用技术</strong>：Nacos, Consul, Eureka, Zookeeper, Kubernetes CoreDNS。</li></ul><h4 id="3-配置中心-Config-Center">3. 配置中心 (Config Center)</h4><ul><li><strong>作用</strong>：系统的“设置面板”。</li><li><strong>核心功能</strong>：统一管理所有服务的配置文件（如数据库密码、开关配置），支持热更新（改配置不用重启服务）。</li><li><strong>常用技术</strong>：Nacos, Apollo, Spring Cloud Config。</li></ul><h4 id="4-远程调用-RPC-HTTP-Client">4. 远程调用 (RPC / HTTP Client)</h4><ul><li><strong>作用</strong>：服务之间的“电话线”。</li><li><strong>核心功能</strong>：让服务 A 像调用本地函数一样调用服务 B。</li><li><strong>常用技术</strong>：<ul><li><strong>HTTP</strong>: OpenFeign (Spring Cloud), RestTemplate.</li><li><strong>RPC</strong>: Dubbo, gRPC.</li></ul></li></ul><h4 id="5-负载均衡-Load-Balancing">5. 负载均衡 (Load Balancing)</h4><ul><li><strong>作用</strong>：系统的“调度员”。</li><li><strong>核心功能</strong>：当服务 B 有 10 个实例时，服务 A 该调哪一个？负责把流量分摊开。</li><li><strong>常用技术</strong>：Ribbon, Spring Cloud LoadBalancer, Kubernetes Service.</li></ul><h4 id="6-熔断与限流-Circuit-Breaker-Rate-Limiter">6. 熔断与限流 (Circuit Breaker &amp; Rate Limiter)</h4><ul><li><strong>作用</strong>：系统的“保险丝”。</li><li><strong>核心功能</strong>：<ul><li><strong>熔断</strong>：当服务 B 挂了，服务 A 自动切断对 B 的调用，防止把自己拖死（雪崩效应）。</li><li><strong>降级</strong>：调用失败后，返回一个兜底的默认值。</li></ul></li><li><strong>常用技术</strong>：Sentinel (阿里), Hystrix (Netflix, 已停更), Resilience4j.</li></ul><h4 id="7-辅助体系-Observability">7. 辅助体系 (Observability)</h4><ul><li><strong>链路追踪</strong>：SkyWalking, Zipkin（看请求在哪一步慢了）。</li><li><strong>日志系统</strong>：ELK Stack（集中看日志）。</li><li><strong>监控告警</strong>：Prometheus + Grafana（看 CPU、内存水位）。</li></ul><h2 id="一、-核心概念与关系图谱">一、 核心概念与关系图谱</h2><p>在深入代码之前，我们先用一个通俗的类比来理清它们的关系：</p><ol><li><p><strong>微服务 (Microservices)</strong>：</p><ul><li><strong>角色</strong>：这是**“灵魂”**。</li><li><strong>定义</strong>：一种架构风格，将单体应用拆分为一组小型服务，每个服务运行在自己的进程中，通过轻量级机制（通常是 HTTP API）通信。</li><li><strong>痛点</strong>：服务多了，环境配置极其复杂（Python 环境、Java 环境、Node 环境混在一起）。</li></ul></li><li><p><strong>Docker</strong>：</p><ul><li><strong>角色</strong>：这是**“集装箱”**（单兵装备）。</li><li><strong>定义</strong>：将代码及其依赖（库、环境变量、配置文件）打包成一个标准的镜像（Image）。</li><li><strong>解决的问题</strong>：解决了“在我的机器上能跑，在服务器上跑不起来”的环境一致性问题。</li></ul></li><li><p><strong>Docker Compose</strong>：</p><ul><li><strong>角色</strong>：这是**“排练场”**（单机编排）。</li><li><strong>定义</strong>：一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 文件配置应用的所有服务。</li><li><strong>解决的问题</strong>：一个微服务系统往往包含 Web 服务、数据库、缓存等。手动敲十几个 <code>docker run</code> 命令太累了，Compose 让你一键启动所有关联服务。<strong>主要用于开发环境和测试环境。</strong></li></ul></li><li><p><strong>Kubernetes (K8s)</strong>：</p><ul><li><strong>角色</strong>：这是**“总指挥官”**（集群编排）。</li><li><strong>定义</strong>：一个开源的容器编排引擎，用于自动化部署、扩展和管理容器化应用程序。</li><li><strong>解决的问题</strong>：当你的服务需要在几十台服务器上运行，需要自动扩缩容（流量大了加实例）、故障自愈（挂了自动重启）、负载均衡时，Docker Compose 就搞不定了，这时必须上 K8s。<strong>主要用于生产环境。</strong></li></ul></li></ol><h3 id="总结关系：">总结关系：</h3><blockquote><p><strong>微服务是架构思想 -&gt; Docker 是标准交付单元 -&gt; Compose 是单机组装工具 -&gt; K8s 是跨主机的集群管理平台。</strong></p></blockquote><hr><h2 id="二、-实战演练：从代码到集群">二、 实战演练：从代码到集群</h2><p>为了演示，我们假设构建一个简单的微服务：一个基于 Python Flask 的 Web 应用，它连接 Redis 数据库来记录访问次数。</p><h3 id="第一阶段：Docker-化-标准化打包">第一阶段：Docker 化 (标准化打包)</h3><p>首先，我们需要编写代码并将其封装进 Docker 容器。</p><p><strong>1. 应用代码 (<code>app.py</code>)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 注意：这里的 host 写的是 &#x27;redis&#x27;，这是服务发现的关键</span></span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello World! I have been seen <span class="subst">&#123;count&#125;</span> times.\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 编写 <code>Dockerfile</code></strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制依赖文件并安装</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制应用代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong><br>此时，你可以通过 <code>docker build -t my-web-app .</code> 构建镜像。但你没法直接运行它，因为它依赖 Redis，而你还没启动 Redis。</p><hr><h3 id="第二阶段：使用-Docker-Compose-本地开发">第二阶段：使用 Docker Compose (本地开发)</h3><p>在开发阶段，我们需要同时启动 Web 应用和 Redis。</p><p><strong>编写 <code>docker-compose.yml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务1: 我们自己的 Web 应用</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 使用当前目录的 Dockerfile 构建</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span> <span class="comment"># 依赖 redis 服务启动</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务2: Redis 数据库</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span> <span class="comment"># 直接使用官方镜像</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong><br>只需执行一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Docker 会自动构建镜像、拉取 Redis、创建虚拟网络、启动容器。你的代码中 <code>host='redis'</code> 之所以能通，是因为 Compose 提供了 DNS 解析，将 <code>redis</code> 域名解析到了对应的容器 IP。</p><hr><h3 id="第三阶段：迁移至-Kubernetes-生产部署">第三阶段：迁移至 Kubernetes (生产部署)</h3><p>到了生产环境，我们需要高可用和扩缩容。Docker Compose 的 YAML 文件不能直接在 K8s 上用，我们需要将其“翻译”成 K8s 的资源对象：<strong>Deployment</strong> 和 <strong>Service</strong>。</p><p><em>前提：你需要先把镜像推送到仓库，例如 <code>docker push myuser/my-web-app:v1</code></em></p><p><strong>1. 部署 Redis (<code>redis-k8s.yaml</code>)</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Redis Deployment (负责管理 Pod) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># --- Redis Service (负责内部网络发现) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span>  <span class="comment"># 代码里的 host=&#x27;redis&#x27; 就是找这个名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p><strong>2. 部署 Web 应用 (<code>web-k8s.yaml</code>)</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Web App Deployment ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 生产环境我们要 3 个副本实现负载均衡</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">myuser/my-web-app:v1</span> <span class="comment"># 必须是远程仓库地址</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">env:</span> <span class="comment"># 可以在这里注入环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLASK_ENV</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># --- Web App Service (对外暴露) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span> <span class="comment"># 或者 NodePort，让外部能访问</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>      <span class="comment"># 外部访问端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5000</span> <span class="comment"># 容器内部端口</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f redis-k8s.yaml</span><br><span class="line">kubectl apply -f web-k8s.yaml</span><br></pre></td></tr></table></figure><hr><h2 id="三、-技术细节与差异总结">三、 技术细节与差异总结</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Docker Compose</th><th style="text-align:left">Kubernetes (K8s)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>适用场景</strong></td><td style="text-align:left">本地开发、测试环境、单机部署</td><td style="text-align:left">大规模生产环境、多机集群</td></tr><tr><td style="text-align:left"><strong>扩缩容</strong></td><td style="text-align:left">手动 (<code>docker-compose scale</code>)</td><td style="text-align:left">自动 (HPA)、手动 (<code>kubectl scale</code>)</td></tr><tr><td style="text-align:left"><strong>故障恢复</strong></td><td style="text-align:left">容器挂了尝试重启（仅限本机）</td><td style="text-align:left">Pod 挂了在任意健康节点重建（漂移）</td></tr><tr><td style="text-align:left"><strong>网络</strong></td><td style="text-align:left">单机虚拟网桥</td><td style="text-align:left">复杂的 Overlay 网络 (Flannel/Calico)</td></tr><tr><td style="text-align:left"><strong>配置复杂度</strong></td><td style="text-align:left">低 (一个 YAML 文件)</td><td style="text-align:left">高 (需编写 Deployment, Service, Ingress 等)</td></tr><tr><td style="text-align:left"><strong>服务发现</strong></td><td style="text-align:left">基于容器名的 DNS</td><td style="text-align:left">基于 CoreDNS 和 Service VIP</td></tr></tbody></table><h2 id="四、-常用命令">四、 常用命令</h2><p>这是一份为您整理的 <strong>Docker、Docker Compose 和 Kubernetes (K8s)</strong> 常用高频命令速查表。</p><p>为了方便记忆，我将它们按照<strong>生命周期</strong>（构建、运行、调试、清理）进行了分类。</p><hr><h3 id="1-Docker-单兵作战">1. Docker (单兵作战)</h3><p><em>适用于操作单个镜像或容器。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>构建</strong></td><td style="text-align:left"><code>docker build -t &lt;镜像名&gt;:&lt;标签&gt; .</code></td><td style="text-align:left">使用当前目录的 Dockerfile 构建镜像</td></tr><tr><td style="text-align:left"><strong>运行</strong></td><td style="text-align:left"><code>docker run -d -p 80:8080 &lt;镜像名&gt;</code></td><td style="text-align:left">后台运行，并将宿主机80端口映射到容器8080</td></tr><tr><td style="text-align:left"><strong>查看</strong></td><td style="text-align:left"><code>docker ps</code></td><td style="text-align:left">查看正在运行的容器</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker images</code></td><td style="text-align:left">查看本地所有镜像</td></tr><tr><td style="text-align:left"><strong>调试</strong></td><td style="text-align:left"><code>docker logs -f &lt;容器ID&gt;</code></td><td style="text-align:left">实时查看容器日志 (排错必备)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker exec -it &lt;容器ID&gt; /bin/bash</code></td><td style="text-align:left">进入容器内部终端 (就像 SSH 进去一样)</td></tr><tr><td style="text-align:left"><strong>停止</strong></td><td style="text-align:left"><code>docker stop &lt;容器ID&gt;</code></td><td style="text-align:left">停止容器</td></tr><tr><td style="text-align:left"><strong>清理</strong></td><td style="text-align:left"><code>docker rm &lt;容器ID&gt;</code></td><td style="text-align:left">删除容器 (需先停止)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker rmi &lt;镜像ID&gt;</code></td><td style="text-align:left">删除镜像</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker system prune</code></td><td style="text-align:left"><strong>大杀器</strong>：一键清理所有未使用的容器、网络和悬空镜像</td></tr></tbody></table><hr><h3 id="2-Docker-Compose-小队演练">2. Docker Compose (小队演练)</h3><p><em>适用于本地开发，同时管理 Web、数据库、缓存等多个容器。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>启动</strong></td><td style="text-align:left"><code>docker-compose up -d</code></td><td style="text-align:left"><strong>最常用</strong>：构建并后台启动所有服务</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose up -d --build</code></td><td style="text-align:left">代码修改后，强制重新构建并启动</td></tr><tr><td style="text-align:left"><strong>停止</strong></td><td style="text-align:left"><code>docker-compose down</code></td><td style="text-align:left">停止并<strong>删除</strong>所有容器和网络 (数据卷默认保留)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose stop</code></td><td style="text-align:left">仅停止容器，不删除</td></tr><tr><td style="text-align:left"><strong>查看</strong></td><td style="text-align:left"><code>docker-compose ps</code></td><td style="text-align:left">查看当前编排的所有服务状态</td></tr><tr><td style="text-align:left"><strong>日志</strong></td><td style="text-align:left"><code>docker-compose logs -f</code></td><td style="text-align:left">聚合查看所有服务的日志</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose logs -f &lt;服务名&gt;</code></td><td style="text-align:left">只看某个服务 (如 redis) 的日志</td></tr><tr><td style="text-align:left"><strong>重启</strong></td><td style="text-align:left"><code>docker-compose restart &lt;服务名&gt;</code></td><td style="text-align:left">重启指定服务</td></tr></tbody></table><hr><h3 id="3-Kubernetes-kubectl-集团军指挥">3. Kubernetes / kubectl (集团军指挥)</h3><p><em>适用于生产环境集群管理。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>部署/更新</strong></td><td style="text-align:left"><code>kubectl apply -f &lt;文件名&gt;.yaml</code></td><td style="text-align:left"><strong>最核心</strong>：根据 YAML 文件创建或更新资源</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl apply -f &lt;文件夹&gt;/</code></td><td style="text-align:left">批量应用文件夹下所有 YAML</td></tr><tr><td style="text-align:left"><strong>查看状态</strong></td><td style="text-align:left"><code>kubectl get pods</code></td><td style="text-align:left">查看 Pod 运行状态 (Running/Error/CrashLoopBackOff)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get svc</code></td><td style="text-align:left">查看 Service (IP 和端口)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get deploy</code></td><td style="text-align:left">查看 Deployment (副本数)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get all</code></td><td style="text-align:left">查看所有资源</td></tr><tr><td style="text-align:left"><strong>排错(关键)</strong></td><td style="text-align:left"><code>kubectl describe pod &lt;Pod名称&gt;</code></td><td style="text-align:left"><strong>查报错详情</strong>：看为什么起不来 (如镜像拉取失败、资源不足)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl logs -f &lt;Pod名称&gt;</code></td><td style="text-align:left">看业务日志 (程序 print 的内容)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl exec -it &lt;Pod名称&gt; -- /bin/bash</code></td><td style="text-align:left">进入 Pod 内部</td></tr><tr><td style="text-align:left"><strong>删除</strong></td><td style="text-align:left"><code>kubectl delete -f &lt;文件名&gt;.yaml</code></td><td style="text-align:left">根据配置文件删除资源</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl delete pod &lt;Pod名称&gt;</code></td><td style="text-align:left">删除单个 Pod (K8s 会自动重启一个新的)</td></tr></tbody></table><hr><h3 id="💡-记忆口诀：横向对比">💡 记忆口诀：横向对比</h3><table><thead><tr><th style="text-align:left">动作</th><th style="text-align:left">Docker</th><th style="text-align:left">Docker Compose</th><th style="text-align:left">Kubernetes (kubectl)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>启动/应用</strong></td><td style="text-align:left"><code>run</code></td><td style="text-align:left"><code>up</code></td><td style="text-align:left"><code>apply</code></td></tr><tr><td style="text-align:left"><strong>停止/删除</strong></td><td style="text-align:left"><code>rm</code></td><td style="text-align:left"><code>down</code></td><td style="text-align:left"><code>delete</code></td></tr><tr><td style="text-align:left"><strong>看日志</strong></td><td style="text-align:left"><code>logs</code></td><td style="text-align:left"><code>logs</code></td><td style="text-align:left"><code>logs</code></td></tr><tr><td style="text-align:left"><strong>进终端</strong></td><td style="text-align:left"><code>exec</code></td><td style="text-align:left"><code>exec</code></td><td style="text-align:left"><code>exec</code></td></tr><tr><td style="text-align:left"><strong>看列表</strong></td><td style="text-align:left"><code>ps</code></td><td style="text-align:left"><code>ps</code></td><td style="text-align:left"><code>get pods</code></td></tr></tbody></table><p><strong>总结建议：</strong></p><ol><li><strong>开发阶段</strong>：死磕 <code>docker-compose up -d</code> 和 <code>docker build</code>。</li><li><strong>运维阶段</strong>：死磕 <code>kubectl apply</code>、<code>kubectl get pods</code> 和 <code>kubectl describe</code>。</li></ol><h2 id="五、-结语">五、 结语</h2><p>从 Docker 到 Docker Compose，再到 Kubernetes，这是一条**从“独立个体”到“有组织群体”**的进化之路。</p><ul><li>如果你是刚开始写微服务，请先精通 <strong>Docker</strong> 和 <strong>Dockerfile</strong>。</li><li>如果你需要快速搭建开发环境，<strong>Docker Compose</strong> 是你的好帮手。</li><li>如果你的业务开始爆发，需要管理成百上千个容器，<strong>Kubernetes</strong> 则是你必须征服的高地。</li></ul><p>掌握这套技术栈，你就拥有了构建现代化、高可用后端架构的核心能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;从零构建微服务架构：Docker, Compose 与 K8s 的演进之路&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在现代云原生开发的浪潮中，&lt;strong&gt;微服务（Microservices）&lt;/strong&gt; 已经成为构建复杂系统的首选架构。然而，随着服务数量的裂变</summary>
      
    
    
    
    
    <category term="docker" scheme="https://caozhaoqi.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于 FastAPI + LangChain 的高并发 Agent 架构解析</title>
    <link href="https://caozhaoqi.github.io/2025/12/03/jd-agent-desc/"/>
    <id>https://caozhaoqi.github.io/2025/12/03/jd-agent-desc/</id>
    <published>2025-12-03T14:09:55.000Z</published>
    <updated>2025-12-03T14:16:34.936Z</updated>
    
    <content type="html"><![CDATA[<h1>基于 FastAPI + LangChain 的高并发 Agent 架构解析</h1><p><strong>项目地址</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在 AI Agent 爆发的今天，如何让大模型从“聊天玩具”变成“生产力工具”？本文将深度拆解 <code>jd_agent</code> 项目。这是一个全栈 AI 应用，它能自动分析岗位描述（JD），并行生成技术面试题、HR 行为面试指南及公司背景调研。项目采用 <strong>FastAPI</strong> + <strong>LangChain</strong> 构建高并发后端，配合 <strong>Next.js</strong> + <strong>Tailwind</strong> 实现类似 DeepSeek 的现代化交互界面。</p></blockquote><hr><h2 id="1-项目背景与痛点">1. 项目背景与痛点</h2><p>求职者在准备面试时，往往面临“信息过载”与“针对性不足”的矛盾：</p><ul><li><strong>手动分析慢</strong>：面对几十个 JD，逐个提取技术栈和核心职责非常耗时。</li><li><strong>准备无方向</strong>：不知道该复习哪些底层原理，也不知道 HR 会问什么刁钻的行为问题。</li><li><strong>通用 AI 效率低</strong>：直接问 ChatGPT，需要反复输入 Prompt，且输出格式乱七八糟，难以保存。</li></ul><p><strong><code>jd_agent</code> 的目标</strong>：输入一段 JD，<strong>10秒内</strong> 输出一份结构清晰、包含技术突击点与回答策略的<strong>全方位面试指南</strong>。</p><hr><h2 id="2-核心功能-Core-Features">2. 核心功能 (Core Features)</h2><p>截至目前，项目已实现以下核心能力：</p><h3 id="✅-1-智能-JD-解析-Smart-Parsing">✅ 1. 智能 JD 解析 (Smart Parsing)</h3><p>利用 LLM 的语义理解能力，从非结构化的 JD 文本中精准提取：</p><ul><li><strong>核心技术栈</strong> (e.g., Python, K8s, Redis)</li><li><strong>职级/经验要求</strong> (e.g., 架构师, 3-5年)</li><li><strong>软技能要求</strong> (e.g., 抗压能力, 跨部门沟通)</li><li><strong>公司名称</strong> (用于后续背调)</li></ul><h3 id="✅-2-深度技术题生成-Hardcore-Tech-QA">✅ 2. 深度技术题生成 (Hardcore Tech QA)</h3><p>基于提取的技术栈和职级，生成<strong>定制化</strong>的面试题：</p><ul><li><strong>差异化出题</strong>：针对初级岗位问语法，针对高级岗位问底层原理（如 GIL 锁、分布式一致性）。</li><li><strong>参考答案</strong>：每道题均附带“参考回答要点”，辅助记忆。</li></ul><h3 id="✅-3-HR-行为面试指南-Behavioral-Guide">✅ 3. HR 行为面试指南 (Behavioral Guide)</h3><p>结合 JD 中的软技能要求，基于 <strong>STAR 法则</strong>（情境、任务、行动、结果）生成行为面试题及高分回答策略。</p><h3 id="✅-4-现代化对话界面-Modern-UI">✅ 4. 现代化对话界面 (Modern UI)</h3><ul><li><strong>DeepSeek 风格交互</strong>：采用 Next.js + Tailwind CSS 构建，支持 Markdown 实时渲染。</li><li><strong>流式响应 (预留)</strong>：后端架构已支持 SSE，前端具备打字机效果展示能力。</li></ul><hr><h2 id="3-技术架构设计-System-Architecture">3. 技术架构设计 (System Architecture)</h2><p>为了保证高性能与可扩展性，项目采用了 <strong>分层架构 (Layered Architecture)</strong> 与 <strong>异步并发 (Asyncio)</strong> 设计。</p><h3 id="3-1-架构图解">3.1 架构图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User[用户 (Next.js UI)] --&gt;|HTTP POST| API[API Layer (FastAPI)]</span><br><span class="line">    </span><br><span class="line">    subgraph Backend_Core [后端核心服务]</span><br><span class="line">        API --&gt; Service[Service Layer (编排层)]</span><br><span class="line">        </span><br><span class="line">        Service --&gt; Parser[JD 解析器 (Chain A)]</span><br><span class="line">        </span><br><span class="line">        subgraph Parallel_Zone [异步并行执行区]</span><br><span class="line">            direction TB</span><br><span class="line">            Parser --&gt;|提取技术栈| TechGen[技术题生成器 (Chain B)]</span><br><span class="line">            Parser --&gt;|提取公司名| Research[公司背调/HR生成 (Chain C)]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        TechGen --&gt; LLM[(LLM Factory)]</span><br><span class="line">        Research --&gt; LLM</span><br><span class="line">        </span><br><span class="line">        LLM --&gt;|OpenAI/DeepSeek| Cloud[模型服务商]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    Service --&gt;|Structured JSON| User</span><br></pre></td></tr></table></figure><h3 id="3-2-核心技术栈">3.2 核心技术栈</h3><ul><li><strong>后端</strong>: Python 3.9+, <strong>FastAPI</strong> (异步 Web 框架), <strong>Pydantic</strong> (数据验证)。</li><li><strong>AI 编排</strong>: <strong>LangChain</strong> (管理 Prompt 与 Chains)。</li><li><strong>模型层</strong>: <strong>OpenAI SDK</strong> (兼容 DeepSeek-V3, SiliconFlow 等多渠道)。</li><li><strong>前端</strong>: <strong>Next.js 14</strong>, Tailwind CSS, Lucide React。</li></ul><hr><h2 id="4-关键实现原理-Implementation-Deep-Dive">4. 关键实现原理 (Implementation Deep Dive)</h2><h3 id="4-1-强制结构化输出-Solving-the-JSON-Problem">4.1 强制结构化输出 (Solving the JSON Problem)</h3><p>大模型天生喜欢“说话”，但程序需要 JSON。我们摒弃了不稳定的正则表达式，使用 LangChain 的 <code>PydanticOutputParser</code>。</p><p><strong>代码片段</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义期望的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterviewQuestion</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    category: <span class="built_in">str</span></span><br><span class="line">    question: <span class="built_in">str</span></span><br><span class="line">    reference_answer: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注入 Schema 指令</span></span><br><span class="line">parser = PydanticOutputParser(pydantic_object=InterviewQuestion)</span><br><span class="line">format_instructions = parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt 中包含 format_instructions，强制 LLM 输出 JSON</span></span><br></pre></td></tr></table></figure><h3 id="4-2-异步并发优化-From-30s-to-10s">4.2 异步并发优化 (From 30s to 10s)</h3><p>这是本项目最大的工程亮点。</p><ul><li><strong>串行模式</strong>: 解析(5s) + 技术题(10s) + HR题(10s) = <strong>25s+</strong></li><li><strong>并行模式</strong>: 解析(5s) + [技术题 &amp; HR题 同时跑](max 10s) = <strong>15s</strong></li></ul><p>利用 Python 的 <code>asyncio.gather</code> 实现“Fire and Forget”模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 1. 前置依赖：解析 JD</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 并发执行无依赖的任务</span></span><br><span class="line">    <span class="comment"># 使用 ainvoke 而不是 invoke</span></span><br><span class="line">    task_tech = generate_tech_async(jd_meta.tech_stack, jd_meta.years_required)</span><br><span class="line">    task_hr = generate_hr_async(jd_meta.soft_skills)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 挂起等待所有任务完成</span></span><br><span class="line">    tech_qs, hr_qs = <span class="keyword">await</span> asyncio.gather(task_tech, task_hr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InterviewReport(...)</span><br></pre></td></tr></table></figure><h3 id="4-3-LLM-工厂模式-Cost-Optimization">4.3 LLM 工厂模式 (Cost Optimization)</h3><p>为了降低 token 成本，我们设计了配置驱动的 LLM 工厂。开发时使用 <strong>DeepSeek (充值 10 元用很久)</strong>，生产环境可无缝切换至 <strong>GPT-4</strong>。</p><p><strong>配置管理 (<code>.env</code> 驱动)</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core/config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span></span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span> <span class="comment"># 一键切换底座</span></span><br><span class="line">    MODEL_NAME: <span class="built_in">str</span> = <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-工程踩坑与解决方案-Troubleshooting">5. 工程踩坑与解决方案 (Troubleshooting)</h2><p>在开发过程中，我们解决了一系列真实的工程问题，这些经验非常宝贵：</p><table><thead><tr><th style="text-align:left">问题现象</th><th style="text-align:left">根本原因</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Error 402 / 429</strong></td><td style="text-align:left">API 账户余额不足（OpenAI 欠费）。</td><td style="text-align:left">切换至 <strong>DeepSeek</strong> 或 <strong>硅基流动</strong> 的免费额度。</td></tr><tr><td style="text-align:left"><strong>ValidationError</strong></td><td style="text-align:left">某些情况下 LLM 未生成非必填项（如系统设计题），导致返回 None。</td><td style="text-align:left">在 Pydantic Schema 中使用 <code>Optional[T] = None</code>。</td></tr><tr><td style="text-align:left"><strong>UI 样式丢失</strong></td><td style="text-align:left">Next.js 页面内容堆叠在左上角，无样式。</td><td style="text-align:left">1. 检查 <code>layout.tsx</code> 是否引入 <code>globals.css</code>。<br>2. 检查 <code>tailwind.config.ts</code> 的 <code>content</code> 路径是否包含 <code>app</code> 目录。</td></tr><tr><td style="text-align:left"><strong>SSL Error</strong></td><td style="text-align:left">Mac 自带 LibreSSL 版本过低。</td><td style="text-align:left">降级 urllib3 或使用 Homebrew 升级 OpenSSL。</td></tr></tbody></table><hr><h2 id="6-总结与展望">6. 总结与展望</h2><p><code>jd_agent</code> 不仅仅是一个 Demo，它展示了现代 AI 应用开发的标准范式：<strong>Prompt 工程化 + 异步后端 + 结构化数据流</strong>。</p><p><strong>未来规划 (Roadmap)</strong>:</p><ol><li><strong>RAG 增强</strong>: 集成 Tavily 搜索 API，实时抓取公司财报和新闻，生成更犀利的反问环节。</li><li><strong>简历匹配</strong>: 上传用户简历 PDF，自动计算与 JD 的匹配度分数 (Matching Score)。</li><li><strong>多模态</strong>: 支持直接输入 JD 截图或 PDF 文件。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;基于 FastAPI + LangChain 的高并发 Agent 架构解析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;项目地址&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>打造 L5 级人机协同与全双工语音的 AI 面试官</title>
    <link href="https://caozhaoqi.github.io/2025/12/01/agent-advance-high/"/>
    <id>https://caozhaoqi.github.io/2025/12/01/agent-advance-high/</id>
    <published>2025-11-30T16:20:21.000Z</published>
    <updated>2025-11-30T16:22:22.003Z</updated>
    
    <content type="html"><![CDATA[<h1>🚀 [实战] 进化！从脚本到数字员工：打造 L5 级人机协同与全双工语音的 AI 面试官</h1><blockquote><p><strong>摘要</strong>：今天是一个里程碑。我们将 <code>JD_Agent</code> 从一个简单的 RAG 问答工具，彻底重构为一个具备 <strong>L5 级别自主性</strong> 的多智能体系统。同时，我们攻克了 <strong>全双工语音交互</strong> 和 <strong>DeepSeek 风格思考过程</strong> 的工程难题，让 AI 不仅能“思考”，还能像真人一样“倾听”和“表达”。</p></blockquote><hr><h2 id="🌟-架构全景图-The-Big-Picture">🌟 架构全景图 (The Big Picture)</h2><p>在 v2.0 版本中，我们不再简单的线性调用 LLM，而是构建了一个复杂的<strong>多智能体协作网络</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User((🙍‍♂️ 用户)) &lt;--&gt;|Web Audio / SSE| Frontend[🖥️ Next.js 前端]</span><br><span class="line">    Frontend &lt;--&gt;|HTTP / Stream| Backend[⚙️ FastAPI 后端]</span><br><span class="line"></span><br><span class="line">    subgraph &quot;🧠 智能体大脑 (LangGraph)&quot;</span><br><span class="line">        Start(开始) --&gt; Parser[🔍 职位解析员]</span><br><span class="line">        Parser --&gt; Researcher[🕵️ 商业情报员]</span><br><span class="line">        Parser --&gt; TechLead[💻 技术面试官]</span><br><span class="line">        </span><br><span class="line">        Researcher --&gt; Context&#123;信息汇总&#125;</span><br><span class="line">        TechLead --&gt; Reviewer[⚖️ 质量检察员]</span><br><span class="line">        </span><br><span class="line">        Reviewer --&gt;|评分 &lt; 85| TechLead</span><br><span class="line">        Reviewer --&gt;|评分 &gt;= 85| End(✅ 输出报告)</span><br><span class="line">        </span><br><span class="line">        Reviewer -.-&gt;|拿捏不准| Human[🛑 人工介入]</span><br><span class="line">        Human --&gt; TechLead</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;🔊 语音交互层&quot;</span><br><span class="line">        ASR[👂 Whisper ASR]</span><br><span class="line">        TTS[🗣️ macOS Native TTS]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Backend --&gt; ASR</span><br><span class="line">    Backend --&gt; TTS</span><br><span class="line">    Backend --&gt; Start</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破一：L5-级多智能体协同-LangGraph">核心突破一：L5 级多智能体协同 (LangGraph)</h2><p>我们要解决的核心痛点是：<strong>AI 生成的内容往往不够深度，或者一本正经胡说八道。</strong><br>解决方案是引入 <strong>Reviewer (质检员)</strong> 角色，形成质量闭环。</p><h3 id="1-定义“团队”-The-Team">1. 定义“团队” (The Team)</h3><p>我们不再是一个 Agent 打天下，而是通过 <code>LangGraph</code> 组建了一个虚拟团队：</p><ul><li><strong>Tech Lead</strong>: 负责根据 JD 出题。</li><li><strong>Reviewer</strong>: 负责给题目打分。如果不合格，打回重写。</li></ul><h3 id="2-代码实现-Workflow">2. 代码实现 (Workflow)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/app/graph/workflow.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义路由逻辑：决定是“通过”还是“重写”</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qa_router</span>(<span class="params">state: AgentState</span>):</span><br><span class="line">    <span class="comment"># 1. 防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;iteration_count&quot;</span>] &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;approved&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 质量把关</span></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;quality_score&quot;</span>] &gt;= <span class="number">85</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;approved&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rejected&quot;</span> <span class="comment"># ⬅️ 这里的 rejected 会导致回滚</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建图</span></span><br><span class="line">workflow = StateGraph(AgentState)</span><br><span class="line">workflow.add_node(<span class="string">&quot;tech_lead&quot;</span>, tech_lead_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;reviewer&quot;</span>, reviewer_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编排循环</span></span><br><span class="line">workflow.add_edge(<span class="string">&quot;tech_lead&quot;</span>, <span class="string">&quot;reviewer&quot;</span>)</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    <span class="string">&quot;reviewer&quot;</span>,</span><br><span class="line">    qa_router,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;approved&quot;</span>: END,</span><br><span class="line">        <span class="string">&quot;rejected&quot;</span>: <span class="string">&quot;tech_lead&quot;</span> <span class="comment"># 🔄 关键：打回重写</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破二：DeepSeek-风格的“思考过程”-UI">核心突破二：DeepSeek 风格的“思考过程” UI</h2><p>为了缓解 L5 架构推理时间长（可能达 1-2 分钟）带来的焦虑感，我们复刻了 DeepSeek R1 的交互体验：<strong>把 AI 的思考过程透明化</strong>。</p><h3 id="1-双流协议设计-Dual-Stream-Protocol">1. 双流协议设计 (Dual Stream Protocol)</h3><p>后端不再只返回文本，而是返回 <strong>JSON 事件流</strong>：</p><ul><li><code>type: &quot;thought&quot;</code> -&gt; 思考步骤（如“正在检索财报…”）</li><li><code>type: &quot;token&quot;</code> -&gt; 最终回复内容</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端 SSE 推送的数据流示例</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;thought&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正在分析 JD 技术栈...&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;thought&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正在构思追问策略...&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;token&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;您好，&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;token&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;根据您的经历...&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-前端可视化组件-Thinking-Block">2. 前端可视化组件 (Thinking Block)</h3><p>前端实现了一个可折叠的面板，实时渲染 <code>thought</code> 流。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/ThinkingBlock.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ThinkingBlock</span>(<span class="params">&#123; thoughts, isFinished &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-gray-50 border rounded-xl p-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex items-center gap-2 text-gray-500&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;isFinished ? <span class="tag">&lt;<span class="name">BrainCircuit</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Loader2</span> <span class="attr">className</span>=<span class="string">&quot;animate-spin&quot;</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;isFinished ? &quot;深度思考完成&quot; : &quot;DeepSeek 正在思考...&quot;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       </span></span><br><span class="line"><span class="language-xml">       &#123;/* 动态渲染思考步骤 */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;mt-2 space-y-1 border-l-2 border-gray-200 pl-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;thoughts.map(step =&gt; (</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;text-xs text-gray-600 animate-in fade-in&quot;</span>&gt;</span>&#123;step&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破三：全双工语音交互-ASR-TTS">核心突破三：全双工语音交互 (ASR + TTS)</h2><p>我们实现了 <strong>录音 -&gt; ASR -&gt; LLM -&gt; TTS</strong> 的完整闭环，让 AI 变身为真正的面试官。</p><h3 id="1-语音合成-TTS-的避坑之路">1. 语音合成 (TTS) 的避坑之路</h3><p>这是今天遇到的最大工程挑战。</p><ul><li>❌ <strong>Edge-TTS</strong>: 在国内网络环境下频繁报 <code>503 Service Unavailable</code>，不稳定。</li><li>❌ <strong>Pyttsx3</strong>: 生成的 AIFF 格式在 Chrome 浏览器中无法播放 (<code>NotSupportedError</code>)。</li><li>✅ <strong>macOS 原生 <code>say</code> 命令</strong>: <strong>最终方案！</strong></li></ul><p>利用 Mac 系统底层的 <code>say</code> 命令生成 <code>.m4a</code> 文件，既利用了 Siri 的高质量语音，又做到了<strong>零网络延迟、零成本</strong>。</p><p><strong>后端实现 (FastAPI):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/audio/tts&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">text_to_speech</span>(<span class="params">text: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Mac 专属黑科技：调用系统底层 TTS</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tmp_path = <span class="string">f&quot;/tmp/<span class="subst">&#123;uuid.uuid4()&#125;</span>.m4a&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用系统命令，直接生成 m4a (浏览器兼容性极好)</span></span><br><span class="line">    subprocess.run([<span class="string">&quot;say&quot;</span>, <span class="string">&quot;-o&quot;</span>, tmp_path, text])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(tmp_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> Response(content=f.read(), media_type=<span class="string">&quot;audio/mp4&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-前端音频队列-Audio-Queue">2. 前端音频队列 (Audio Queue)</h3><p>为了防止流式生成时语音重叠（AI 还在打字，上一句还没读完，下一句又来了），我们在前端实现了一个<strong>分句缓冲队列</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant SSE as 后端流</span><br><span class="line">    participant Parser as 前端解析器</span><br><span class="line">    participant Queue as 音频队列</span><br><span class="line">    participant Player as 播放器</span><br><span class="line"></span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;你好，&quot;</span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;我是&quot;</span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;面试官。&quot; (检测到标点)</span><br><span class="line">    Parser-&gt;&gt;Queue: 入队: &quot;你好，我是面试官。&quot;</span><br><span class="line">    </span><br><span class="line">    loop 队列监听</span><br><span class="line">        Queue-&gt;&gt;Player: 取出第一句</span><br><span class="line">        Player--&gt;&gt;Player: 播放中...</span><br><span class="line">        Player-&gt;&gt;Queue: 播放结束 (onEnded)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-踩坑实录-Troubleshooting">🛠️ 踩坑实录 (Troubleshooting)</h2><h3 id="🐛-Bug-1-React-严格模式下的“复读机”">🐛 Bug 1: React 严格模式下的“复读机”</h3><ul><li><strong>现象</strong>：AI 回复出现 AABB 重复（如“好好…的的…”）。</li><li><strong>原因</strong>：<code>Next.js</code> 开发环境下 <code>React.StrictMode</code> 会执行两次 <code>setState</code>。而我们的代码中直接修改了对象属性 (<code>msg.content += chunk</code>)。</li><li><strong>修复</strong>：严格遵循 <strong>Immutability</strong> 原则。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确写法</span></span><br><span class="line"><span class="title function_">setMessages</span>(<span class="function"><span class="params">prev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newMsgs = [...prev];</span><br><span class="line">    <span class="comment">// 创建新对象，而不是修改引用</span></span><br><span class="line">    newMsgs[lastIndex] = &#123; ...lastMsg, <span class="attr">content</span>: lastMsg.<span class="property">content</span> + chunk &#125;; </span><br><span class="line">    <span class="keyword">return</span> newMsgs;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="🐛-Bug-2-Worker-is-not-defined">🐛 Bug 2: <code>Worker is not defined</code></h3><ul><li><strong>现象</strong>：引入录音库 <code>react-media-recorder</code> 后页面崩溃。</li><li><strong>原因</strong>：Next.js 服务端渲染 (SSR) 无法访问浏览器特有的 Worker API。</li><li><strong>修复</strong>：使用 <code>dynamic import</code> 隔离加载。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChatInput</span> = <span class="title function_">dynamic</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/components/ChatInput&quot;</span>), &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="🔮-总结">🔮 总结</h2><p>现在的 <code>JD_Agent</code> 已经不仅仅是一个代码 demo，它具备了：</p><ol><li><strong>大脑</strong>：懂反思、会纠错的多智能体团队。</li><li><strong>嘴巴</strong>：零延迟的本地 TTS。</li><li><strong>颜值</strong>：媲美 DeepSeek 的现代化 UI。</li></ol><p><strong>Next Step</strong>: 我们将尝试引入 <strong>WebRTC</strong>，将现在的“对讲机模式”升级为真正的“打断式实时通话”。</p><p><em>Keep Building, Keep Evolving.</em> 🚀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;🚀 [实战] 进化！从脚本到数字员工：打造 L5 级人机协同与全双工语音的 AI 面试官&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：今天是一个里程碑。我们将 &lt;code&gt;JD_Agent&lt;/code&gt; 从一个简单的 RAG 问答工</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实时语音模拟面试</title>
    <link href="https://caozhaoqi.github.io/2025/11/30/tts-asr-agent/"/>
    <id>https://caozhaoqi.github.io/2025/11/30/tts-asr-agent/</id>
    <published>2025-11-29T16:01:29.000Z</published>
    <updated>2025-11-30T16:21:10.774Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GitHub 仓库</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在实现了基于 JD 生成面试指南（v1.0）后，我们并未止步。本文记录了 <code>jd_agent</code> 项目的重大升级：引入 <strong>模拟面试（Mock Interview）</strong> 模式，并集成了 <strong>ASR（语音识别）</strong> 与 <strong>TTS（语音合成）</strong> 技术。我们通过 <strong>FastAPI</strong> 的流式响应、<strong>Next.js</strong> 的音频队列管理以及 <strong>双模型配置策略</strong>，打造了一个能够“听懂你、并开口提问”的 AI 面试官。</p></blockquote><hr><h2 id="1-架构升级：从单向生成到双向交互">1. 架构升级：从单向生成到双向交互</h2><p>v1.0 版本主要解决的是“信息提取”问题（JD -&gt; 报告）。<br>v2.0 版本则致力于解决“实战演练”问题（用户 &lt;-&gt; AI 面试官）。为此，我们在架构中引入了 <strong>音频层 (Audio Layer)</strong> 和 <strong>会话状态管理</strong>。</p><h3 id="1-1-系统架构图-v2-0">1.1 系统架构图 (v2.0)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User((用户)) </span><br><span class="line">    </span><br><span class="line">    subgraph Frontend [Next.js Client]</span><br><span class="line">        Microphone --&gt;|Audio Blob| ASR_Handler</span><br><span class="line">        Chat_UI --&gt;|Text Stream| SSE_Reader</span><br><span class="line">        SSE_Reader --&gt;|Sentence Buffer| Audio_Queue</span><br><span class="line">        Audio_Queue --&gt;|Text Segments| TTS_Player</span><br><span class="line">        TTS_Player --&gt; Speaker</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Backend [FastAPI Server]</span><br><span class="line">        ASR_Handler --&gt;|POST /audio/transcribe| Whisper_Service</span><br><span class="line">        Chat_UI --&gt;|POST /chat/stream| Chat_Service</span><br><span class="line">        TTS_Player --&gt;|POST /audio/tts| TTS_Service</span><br><span class="line">        </span><br><span class="line">        subgraph Services</span><br><span class="line">            Chat_Service[LangChain Chat Flow]</span><br><span class="line">            Whisper_Service[ASR Adapter]</span><br><span class="line">            TTS_Service[TTS Adapter]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        subgraph Model_Layer [Model Factory]</span><br><span class="line">            Chat_Service --&gt;|Text Generation| DeepSeek_V3</span><br><span class="line">            Whisper_Service &amp; TTS_Service --&gt;|Audio Processing| SiliconFlow/OpenAI</span><br><span class="line">        end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="2-核心功能实现细节">2. 核心功能实现细节</h2><h3 id="2-1-模拟面试与流式对话-Streaming-Chat">2.1 模拟面试与流式对话 (Streaming Chat)</h3><p>为了模拟真实的面试场景，我们摒弃了“生成完毕再一次性返回”的模式，全面拥抱 <strong>SSE (Server-Sent Events)</strong>。</p><ul><li><strong>后端实现</strong>：使用 <code>LangChain</code> 的 <code>.astream()</code> 方法配合 FastAPI 的 <code>StreamingResponse</code>。</li><li><strong>Prompt 设计</strong>：根据 Session 标题动态切换 System Prompt。如果检测到是面试模式，AI 变身为“严厉的面试官”，每次只问一个问题，并根据候选人的回答进行追问。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/api/endpoints.py</span></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/chat/stream&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stream_chat</span>(<span class="params">req: ChatRequest</span>):</span><br><span class="line">    <span class="comment"># 动态注入人设</span></span><br><span class="line">    system_prompt = <span class="string">&quot;你是一名专业的面试官。请根据求职者的回答进行追问...&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> chunk <span class="keyword">in</span> chain.astream(messages):</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;chunk&#125;</span>\n\n&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;data: [DONE]\n\n&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(generate(), media_type=<span class="string">&quot;text/event-stream&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-语音交互闭环-The-Voice-Loop">2.2 语音交互闭环 (The Voice Loop)</h3><p>这是本次升级的技术高地。我们实现了一个完整的语音交互循环：<strong>录音 -&gt; ASR -&gt; LLM 思考 -&gt; TTS 朗读</strong>。</p><h4 id="A-ASR-听">A. ASR (听)</h4><p>前端使用 <code>react-media-recorder</code> 捕获音频 Blob，后端对接 <strong>OpenAI 兼容接口</strong>（如 SiliconFlow 的 <code>SenseVoiceSmall</code>，识别速度极快）。</p><h4 id="B-TTS-说-关键优化：音频队列-Audio-Queue">B. TTS (说) - 关键优化：音频队列 (Audio Queue)</h4><p>为了解决“AI 说话卡顿”或“多重语音重叠”的问题，我们在前端实现了一个<strong>音频播放队列</strong>。</p><p><strong>痛点</strong>：AI 生成速度很快，如果每收到一段文字就请求播放，声音会重叠。如果等全部生成完再播放，用户等待时间太长。<br><strong>方案</strong>：</p><ol><li><strong>分句检测</strong>：前端监听 SSE 流，利用标点符号（<code>。？！</code>）切分句子。</li><li><strong>入队</strong>：切分好的句子推入 <code>audioQueue</code>。</li><li><strong>串行播放</strong>：<code>processAudioQueue</code> 递归函数确保上一句播完才请求下一句。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks/useAudioQueue.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">processAudioQueue</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlayingRef.<span class="property">current</span> || queue.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    isPlayingRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> text = queue.<span class="title function_">shift</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求 TTS API 并播放</span></span><br><span class="line">    <span class="keyword">const</span> audio = <span class="keyword">new</span> <span class="title class_">Audio</span>(tts_url);</span><br><span class="line">    audio.<span class="property">onended</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        isPlayingRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_">processAudioQueue</span>(); <span class="comment">// 递归处理下一句</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> audio.<span class="title function_">play</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-基础设施与配置策略-Infrastructure">3. 基础设施与配置策略 (Infrastructure)</h2><p>在引入语音功能时，我们遇到了一个典型的工程问题：<strong>DeepSeek 很强，但它不支持音频</strong>。</p><p>为了兼顾<strong>智能（文本）<strong>与</strong>功能（语音）</strong>，我们设计了<strong>双模型配置策略</strong>。</p><h3 id="3-1-分离配置-env-config-py">3.1 分离配置 (<code>.env</code> &amp; <code>config.py</code>)</h3><p>我们将 LLM 的配置与 Audio 的配置完全解耦，实现了“大脑”用 DeepSeek，“嘴巴和耳朵”用 OpenAI/SiliconFlow。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/core/config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    <span class="comment"># 大脑：DeepSeek V3 (高智商，低成本)</span></span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span> </span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 五官：SiliconFlow / OpenAI (处理语音)</span></span><br><span class="line">    AUDIO_API_KEY: <span class="type">Optional</span>[<span class="built_in">str</span>]</span><br><span class="line">    AUDIO_API_BASE: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="string">&quot;https://api.siliconflow.cn/v1&quot;</span></span><br><span class="line">    ASR_MODEL: <span class="built_in">str</span> = <span class="string">&quot;FunAudioLLM/SenseVoiceSmall&quot;</span></span><br></pre></td></tr></table></figure><p>这种设计使得系统极具灵活性，可以在不修改代码的情况下，随意更换底层的语音服务商。</p><hr><h2 id="4-前端工程化踩坑记录-Troubleshooting">4. 前端工程化踩坑记录 (Troubleshooting)</h2><p>在 Next.js + React 的开发过程中，我们解决了几个棘手的 Bug。</p><h3 id="坑位-1：Worker-is-not-defined">坑位 1：<code>Worker is not defined</code></h3><ul><li><strong>现象</strong>：引入 <code>react-media-recorder</code> 后，页面刷新直接报错。</li><li><strong>原因</strong>：Next.js 默认进行服务端渲染 (SSR)，而录音库依赖浏览器特有的 <code>Worker</code> API，Node.js 环境里没有。</li><li><strong>解决</strong>：使用 <code>next/dynamic</code> 进行动态导入，并禁用 SSR。<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChatInput</span> = <span class="title function_">dynamic</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/components/ChatInput&quot;</span>), &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-2：布局遮挡与滚动失效">坑位 2：布局遮挡与滚动失效</h3><ul><li><strong>现象</strong>：输入框使用 <code>absolute</code> 定位，导致聊天记录过长时被输入框遮挡，无法看到最后一条消息。</li><li><strong>解决</strong>：重构 CSS 布局，放弃绝对定位，改用 <strong>Flexbox</strong>。<ul><li>容器：<code>flex flex-col h-screen</code></li><li>消息区：<code>flex-1 overflow-y-auto</code></li><li>输入区：<code>flex-shrink-0</code> (固定在底部，挤压消息区高度)</li></ul></li></ul><h3 id="坑位-3：Markdown-样式丢失">坑位 3：Markdown 样式丢失</h3><ul><li><strong>现象</strong>：AI 回复的 Markdown 没有格式（无加粗、无列表）。</li><li><strong>解决</strong>：引入 <code>@tailwindcss/typography</code> 插件，并正确包裹 <code>prose</code> 类名。<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;prose prose-sm ...&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ReactMarkdown</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">ReactMarkdown</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-总结">5. 总结</h2><p>通过本次 v2.0 的迭代，<code>jd_agent</code> 已经不仅仅是一个简单的文本分析工具，而是一个具备<strong>多模态交互能力</strong>的智能助手。</p><ul><li><strong>技术栈</strong>: FastAPI, LangChain, Next.js, Tailwind, Web Audio API.</li><li><strong>核心突破</strong>: 解决了 LLM 生成与 TTS 播放的时序同步问题，实现了流畅的语音对话体验。</li></ul><hr><p><em>希望这篇实战记录能为正在构建 AI Agent 的开发者提供参考！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GitHub 仓库&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com/caozhaoqi/jd_agent&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/"/>
    <id>https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/</id>
    <published>2025-11-29T14:00:18.000Z</published>
    <updated>2025-11-29T14:00:59.411Z</updated>
    
    <content type="html"><![CDATA[<h1>[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</h1><blockquote><p><strong>摘要</strong>：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 <code>JD_Agent</code> 项目的里程碑式更新。我们引入了 <strong>Next.js</strong> 复刻 DeepSeek 的丝滑 UI，基于 <strong>SQLModel</strong> 实现了完整的用户鉴权与会话管理，并利用 <strong>RAG 技术</strong> 实现了“简历解析与长期记忆”功能，让 AI 真正拥有了“记住用户”的能力。</p></blockquote><hr><h2 id="1-项目演进：从-Script-到-Product">1. 项目演进：从 Script 到 Product</h2><p>在之前的版本中，我们的 <code>JD_Agent</code> 只是一个无状态的 API 接口：用户发 JD，AI 返回分析。<br>但一个真正的 AI 产品需要具备：</p><ol><li><strong>用户系统</strong>：数据隔离，每个人只能看自己的历史。</li><li><strong>交互体验</strong>：流式输出、Markdown 渲染、历史记录回溯。</li><li><strong>长期记忆</strong>：记住用户的简历背景，不需要每次 Prompt 都重复“我是 Python 开发…”。</li></ol><p>今天，我们完成了这次<strong>全栈重构</strong>。</p><hr><h2 id="2-技术栈全景">2. 技术栈全景</h2><ul><li><strong>Frontend</strong>: Next.js 14 (App Router) + Tailwind CSS + Lucide React</li><li><strong>Backend</strong>: FastAPI + Uvicorn</li><li><strong>Database</strong>: SQLModel (SQLite) + Alembic</li><li><strong>Auth</strong>: JWT (OAuth2PasswordBearer) + Passlib (Bcrypt)</li><li><strong>AI Core</strong>: LangChain + OpenAI/DeepSeek + FAISS (RAG)</li></ul><hr><h2 id="3-核心功能实现">3. 核心功能实现</h2><h3 id="3-1-完美复刻-DeepSeek-的交互界面">3.1 完美复刻 DeepSeek 的交互界面</h3><p>我们抛弃了简陋的 HTML，采用 <strong>Next.js + Tailwind</strong> 打造了现代化的 Chat UI。</p><ul><li><strong>布局攻坚</strong>：为了实现“顶部固定、侧边栏独立滚动、输入框底部悬浮且不遮挡内容”，我们采用了 <code>fixed inset-0</code> 锁死视口高度，并配合 <code>pb-[200px]</code> 的底部内边距策略。</li><li><strong>Markdown 渲染</strong>：后端返回的结构化 JSON 报告，在前端被动态组装成 Markdown，并通过 <code>react-markdown</code> 渲染出漂亮的排版。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端布局核心 Trick</span></span><br><span class="line">&lt;div className=<span class="string">&quot;fixed inset-0 flex ...&quot;</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 侧边栏 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;w-[260px] hidden md:flex ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;<span class="comment">/* 主聊天区 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;flex-1 flex flex-col h-full relative&quot;</span>&gt;</span><br><span class="line">     &#123;<span class="comment">/* 消息列表：底部留白防止被输入框遮挡 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;flex-1 overflow-y-auto pb-[200px]&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">     </span><br><span class="line">     &#123;<span class="comment">/* 悬浮输入框：背景渐变透明 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;absolute bottom-0 ... bg-gradient-to-t ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-长期记忆：简历解析与用户画像-LTM">3.2 长期记忆：简历解析与用户画像 (LTM)</h3><p>这是本次更新的<strong>灵魂功能</strong>。我们不希望 AI 聊完就忘，而是构建了一个<strong>长期记忆系统 (Long-Term Memory)</strong>。</p><p><strong>实现流程</strong>：</p><ol><li><strong>上传</strong>：用户上传 PDF/Word 简历。</li><li><strong>解析</strong>：后端使用 <code>pdfplumber</code> 提取纯文本。</li><li><strong>ETL</strong>：利用 LangChain 的 <code>resume_extractor</code> 链，从杂乱的简历中提取出<strong>结构化画像</strong>（如：<code>tech_stack: [&quot;Python&quot;, &quot;FastAPI&quot;]</code>, <code>experience: &quot;5年&quot;</code>）。</li><li><strong>存储</strong>：存入 <code>UserProfile</code> 数据库表。</li><li><strong>回想</strong>：下次用户发送 JD 时，系统自动读取 <code>UserProfile</code>，注入到 System Prompt 中。</li></ol><p><strong>后端代码片段 (Service Layer)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/interview_service.py</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request, db, user_id</span>):</span><br><span class="line">    <span class="comment"># 1. 读取长期记忆 (从数据库获取用户画像)</span></span><br><span class="line">    ltm_profile = get_user_profile_str(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 读取短期记忆 (从 ChatMessage 表获取最近对话)</span></span><br><span class="line">    chat_history = get_recent_chat_history(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 带着记忆去思考</span></span><br><span class="line">    task_tech = generate_tech_async(</span><br><span class="line">        ...,</span><br><span class="line">        user_profile=ltm_profile, <span class="comment"># &lt;--- 注入长期记忆</span></span><br><span class="line">        chat_history=chat_history <span class="comment"># &lt;--- 注入短期记忆</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="3-3-数据闭环：会话历史管理">3.3 数据闭环：会话历史管理</h3><p>为了实现侧边栏的“历史记录”功能，我们引入了 <strong>SQLModel</strong>。</p><ul><li><p><strong>表结构设计</strong>：</p><ul><li><code>User</code>: 存储用户名、加密密码。</li><li><code>ChatSession</code>: 代表一次对话（如“神州邦邦面试准备”）。</li><li><code>ChatMessage</code>: 存储具体的 User/Assistant 消息内容。</li></ul></li><li><p><strong>难点处理</strong>：Pydantic 对象无法直接存入数据库，我们在存库前将其序列化为 JSON 字符串，在读取时再反序列化，确保前端能拿到结构化的 <code>meta</code> 数据进行渲染。</p></li></ul><hr><h2 id="4-工程化踩坑实录">4. 工程化踩坑实录</h2><p>在开发过程中，我们解决了一系列真实的工程问题：</p><h3 id="坑位-1：Tailwind-CSS-样式失效">坑位 1：Tailwind CSS 样式失效</h3><ul><li><strong>现象</strong>：页面元素堆叠在左上角，样式全无。</li><li><strong>原因</strong>：Next.js 初始化时 <code>tailwind.config.js</code> 路径配置错误，且误装了不兼容的 Tailwind v4 版本。</li><li><strong>解决</strong>：降级至 <code>tailwindcss@3.4.17</code>，并手动修正 <code>content</code> 路径覆盖 <code>src/</code> 目录。</li></ul><h3 id="坑位-2：Bcrypt-版本冲突">坑位 2：Bcrypt 版本冲突</h3><ul><li><strong>现象</strong>：注册时报错 <code>AttributeError: module 'bcrypt' has no attribute '__about__'</code>。</li><li><strong>原因</strong>：<code>passlib</code> 库与最新版 <code>bcrypt 4.0+</code> 不兼容。</li><li><strong>解决</strong>：强制锁定版本 <code>pip install &quot;bcrypt==3.2.2&quot;</code>。</li></ul><h3 id="坑位-3：LangChain-参数丢失">坑位 3：LangChain 参数丢失</h3><ul><li><strong>现象</strong>：<code>KeyError: &quot;Input to ChatPromptTemplate is missing variables &#123;'user_profile'&#125;&quot;</code>。</li><li><strong>原因</strong>：在 Prompt 模板中定义了 <code>&#123;user_profile&#125;</code> 占位符，但在 Chain 调用 (<code>ainvoke</code>) 时忘记传入该参数。</li><li><strong>解决</strong>：在 Service 层获取记忆后，显式传递给 Chain。</li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p>通过今天的迭代，<code>JD_Agent</code> 已经具备了一个商业化 AI 产品的雏形：</p><ul><li><strong>好看</strong>：媲美 DeepSeek 的 UI。</li><li><strong>好用</strong>：支持简历一键解析，AI 越用越懂你。</li><li><strong>稳健</strong>：完整的鉴权与日志系统。</li></ul><p><strong>下一步计划</strong>：</p><ol><li><strong>多智能体模拟面试</strong>：引入两个 Agent 互相对话，用户旁观“模拟面试”过程（基于 SSE 流式输出）。</li><li><strong>语音交互</strong>：接入 TTS/ASR，实现真正的语音模拟面试。</li></ol><hr><p><em>技术改变生活，AI 赋能求职。如果你对这个项目感兴趣，欢迎关注我的 GitHub！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 &lt;c</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 RAG 与 Agent 协作的智能面试助手开发指南</title>
    <link href="https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/"/>
    <id>https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/</id>
    <published>2025-11-28T15:32:37.000Z</published>
    <updated>2025-11-28T15:34:27.317Z</updated>
    
    <content type="html"><![CDATA[<h1>实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南</h1><blockquote><p><strong>摘要</strong>：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记）进行回答？本文将拆解一个真实项目 <code>JD_Agent</code> 的实现过程。我们利用 <strong>FastAPI + LangChain</strong> 构建了一个智能体，它不仅能分析岗位 JD，还能通过 <strong>RAG 技术</strong> 检索我的本地 Markdown 博客，生成结合了我个人技术积累的专属面试指南。</p></blockquote><hr><h2 id="一、-为什么要做这个？（痛点与思路）">一、 为什么要做这个？（痛点与思路）</h2><p>在准备面试时，我们经常遇到两个问题：</p><ol><li><strong>JD 分析太累</strong>：每个岗位的技术栈不同，需要针对性复习。</li><li><strong>知识遗忘</strong>：明明以前写过关于 Docker 或 Redis 的博客笔记，但面试时一时想不起来细节。</li></ol><p><strong>我的解决方案</strong>：<br>构建一个 <strong>AI Agent</strong>。</p><ol><li>它能<strong>自动分析</strong>我投递的 JD（岗位描述），提取核心技术栈。</li><li>它拥有一个<strong>外挂大脑（知识库）</strong>，存储了我所有的博客文章。</li><li>在生成面试题时，它会<strong>优先参考</strong>我的博客内容，并告诉我：“这个问题你可以复习你写的这篇文章。”</li></ol><hr><h2 id="二、-核心原理：RAG-与-Agent-的协作">二、 核心原理：RAG 与 Agent 的协作</h2><p>在本项目中，我们采用了 <strong>RAG (Retrieval-Augmented Generation)</strong> 架构。</p><h3 id="1-什么是-RAG？">1. 什么是 RAG？</h3><p>如果把大模型（LLM）比作一个“超级学霸”，那 RAG 就是给了学霸一本“开卷考试的书”。</p><ul><li><strong>LLM</strong>：负责逻辑推理、语言组织。</li><li><strong>Knowledge Base</strong>：负责提供精准的、私有的事实数据（我的博客）。</li></ul><h3 id="2-协作流程图">2. 协作流程图</h3><p>整个系统的运作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User[用户输入 JD] --&gt;|1. 提交| Agent[智能体核心 (Service)]</span><br><span class="line">    </span><br><span class="line">    subgraph Analysis [阶段一: 意图识别]</span><br><span class="line">        Agent --&gt;|2. 解析 JD| Parser[LLM 解析器]</span><br><span class="line">        Parser --&gt;|提取关键词: Python, Docker| Keywords[技术栈列表]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Retrieval [阶段二: RAG 检索]</span><br><span class="line">        Keywords --&gt;|3. 查询向量库| VectorDB[(FAISS 向量库)]</span><br><span class="line">        VectorDB --&gt;|4. 返回博客片段 + 来源| Context[知识库上下文]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Generation [阶段三: 增强生成]</span><br><span class="line">        Context --&gt;|5. 注入 Prompt| Generator[LLM 生成器]</span><br><span class="line">        Generator --&gt;|6. 生成面试题 &amp; 引用来源| Output[最终报告]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="三、-关键技术实现">三、 关键技术实现</h2><h3 id="1-构建知识库-The-Embedding-Pipeline">1. 构建知识库 (The Embedding Pipeline)</h3><p>这是 RAG 的地基。我们需要把 Markdown 格式的博客文章转换成计算机能理解的“向量”。</p><p><strong>技术栈</strong>：<code>LangChain</code> + <code>BGE-Small-zh</code> + <code>FAISS</code></p><ul><li><strong>数据清洗 (ETL)</strong>：<br>使用 <code>MarkdownHeaderTextSplitter</code> 按章节切分文章，保证语义完整性。</li><li><strong>向量化 (Embedding)</strong>：<br>我们选用了 <strong>BAAI/bge-small-zh-v1.5</strong> 模型。它能将一段文字转换为 512 维的浮点数组。<blockquote><p><em>原理</em>：语义相近的句子（如“Docker容器”和“容器化部署”），在向量空间中的距离非常近。</p></blockquote></li><li><strong>存储结构</strong>：<br>存入 FAISS 的不仅是向量，还包含 <strong>Payload</strong>（原文）和 <strong>Metadata</strong>（元数据，如文件名）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：入库逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_index</span>():</span><br><span class="line">    <span class="comment"># 1. 加载博客 Markdown</span></span><br><span class="line">    docs = load_and_split_markdown(<span class="string">&quot;source/_posts&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化 BGE 模型 (使用国内镜像)</span></span><br><span class="line">    embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;BAAI/bge-small-zh-v1.5&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 向量化并存入 FAISS</span></span><br><span class="line">    vector_store = FAISS.from_documents(docs, embedding_model)</span><br><span class="line">    vector_store.save_local(<span class="string">&quot;blog_faiss_index&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-Agent-的大脑：异步编排-Orchestration">2. Agent 的大脑：异步编排 (Orchestration)</h3><p>为了让用户体验达到极致（快！），后端不能串行处理。我们利用 <strong>Python Asyncio</strong> 实现了并行任务流。</p><ul><li><strong>技术挑战</strong>：如何同时进行“公司背景调查”和“知识库检索”？</li><li><strong>解决方案</strong>：<code>asyncio.gather</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：并行编排</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 1. 先解析 JD (前置依赖)</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造查询：用 JD 里的技术栈去查博客</span></span><br><span class="line">    query = <span class="string">&quot; &quot;</span>.join(jd_meta.tech_stack)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 并行执行：(查博客) &amp; (查公司背景) &amp; (出通用题)</span></span><br><span class="line">    task_rag = kb_engine.search(query)</span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发等待结果</span></span><br><span class="line">    rag_result, company_info = <span class="keyword">await</span> asyncio.gather(task_rag, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将查到的博客内容注入 Prompt</span></span><br><span class="line">    final_report = <span class="keyword">await</span> generate_final_report(context=rag_result[<span class="string">&#x27;context&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="3-上下文注入-Context-Injection">3. 上下文注入 (Context Injection)</h3><p>这是让 AI “读懂”博客的关键一步。我们动态构建了 Prompt Template。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一个资深技术面试官。</span></span><br><span class="line"><span class="string">请根据以下【参考知识库】（这是用户的个人博客笔记）来生成面试题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">【参考知识库】：</span></span><br><span class="line"><span class="string">&#123;kb_context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请在生成题目时，明确指出用户在博客中对该知识点的理解。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、-遇到的坑与优化-Troubleshooting">四、 遇到的坑与优化 (Troubleshooting)</h2><p>在开发过程中，我们解决了几个典型的工程问题：</p><ol><li><p><strong>模型下载卡顿</strong>：</p><ul><li><em>问题</em>：HuggingFace 国内无法直连。</li><li><em>解决</em>：在代码顶部设置 <code>os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'</code> 强制走镜像。</li></ul></li><li><p><strong>Pydantic 数据校验错误</strong>：</p><ul><li><em>问题</em>：有时候 RAG 没查到数据，返回 <code>None</code>，导致接口报错。</li><li><em>解决</em>：在 Schema 定义中使用 <code>Optional[List[str]] = []</code>，增强系统的鲁棒性。</li></ul></li><li><p><strong>大模型“幻觉”</strong>：</p><ul><li><em>问题</em>：AI 编造博客里没有的内容。</li><li><em>解决</em>：在 Prompt 中加入约束——“仅依据参考知识库回答，如果知识库未提及，请忽略”。</li></ul></li></ol><hr><h2 id="五、-最终效果">五、 最终效果</h2><p>当用户输入一个包含 <strong>“Python, Docker”</strong> 的 JD 时：</p><ol><li><strong>后端</strong> 迅速定位到本地博客中的 <code>Docker部署笔记.md</code> 和 <code>Python并发编程.md</code>。</li><li><strong>AI</strong> 生成的面试指南中写道：<blockquote><p><strong>Q1: 请谈谈 Docker 的隔离机制？</strong><br><em>参考回答要点</em>：根据你的博客 <strong>《<a href="http://xn--Docker-gl3pp3z6v2awsl.md">Docker部署笔记.md</a>》</strong>，你曾总结过 Namespace 负责资源隔离，Cgroups 负责资源限制…</p></blockquote></li><li><strong>前端</strong> 界面底部会展示：<blockquote><p>📚 <strong>知识库引用</strong>：</p><ul><li>📄 <code>Docker部署笔记.md</code></li></ul></blockquote></li></ol><p>这不仅是一个面试题生成器，更是一个<strong>唤醒沉睡知识的第二大脑</strong>。</p><hr><h2 id="六、-总结">六、 总结</h2><p>本项目通过 <strong>FastAPI</strong> 构建高性能后端，<strong>LangChain</strong> 处理复杂的 LLM 逻辑，<strong>FAISS</strong> 实现毫秒级知识检索。它展示了 <strong>LLM Ops (大模型工程化)</strong> 的核心思路：<strong>不仅要会调 API，更要懂得如何管理数据流和上下文。</strong></p><p>如果你也想为自己的知识库装上 AI 引擎，欢迎参考我的 GitHub 仓库：[<a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a>]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 FastAPI + LangChain 的简单agent实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/26/agent-research-llm/"/>
    <id>https://caozhaoqi.github.io/2025/11/26/agent-research-llm/</id>
    <published>2025-11-26T13:26:13.000Z</published>
    <updated>2025-11-26T13:53:49.049Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GitHub 仓库</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在 AI Agent 开发中，如何平衡大模型的生成质量与接口的响应速度？本文将详细拆解 <code>jd_agent</code> 项目。这是一个基于岗位描述（JD）自动生成结构化面试指南的智能体。我们采用 <strong>FastAPI</strong> 作为后端，利用 <strong>LangChain</strong> 进行逻辑编排，并通过 <strong>Asyncio</strong> 实现并行推理，将任务耗时从 30s+ 优化至 10s 级。此外，本文还记录了从 OpenAI 迁移至 DeepSeek 的实战经验及工程踩坑记录。</p></blockquote><hr><h2 id="1-项目背景与痛点">1. 项目背景与痛点</h2><p>在求职过程中，针对每个岗位进行深度准备（分析技术栈、预测面试题、调研公司背景）是非常耗时的。<br>传统的 ChatGPT 交互方式虽然可行，但存在以下问题：</p><ul><li><strong>Prompt 重复劳动</strong>：每次都要输入一大段 Prompt。</li><li><strong>输出非结构化</strong>：生成的文本难以直接用于后续的数据存储或前端展示。</li><li><strong>响应缓慢</strong>：分析 JD、出技术题、出 HR 题、背调公司，如果串行执行，等待时间极长。</li></ul><p>本项目旨在通过<strong>工程化</strong>手段解决上述问题，构建一个<strong>可扩展、高并发、结构化输出</strong>的 AI Agent 后端。</p><hr><h2 id="2-技术架构设计-System-Architecture">2. 技术架构设计 (System Architecture)</h2><p>为了保证系统的可维护性和扩展性，本项目采用了<strong>分层架构 (Layered Architecture)</strong>。</p><h3 id="2-1-架构分层图">2.1 架构分层图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    Client[前端/客户端] --&gt;|HTTP/SSE| API[API Interface Layer]</span><br><span class="line">    </span><br><span class="line">    subgraph Backend [FastAPI Backend]</span><br><span class="line">        API --&gt; Service[Service Layer (Orchestration)]</span><br><span class="line">        </span><br><span class="line">        subgraph Parallel_Execution [异步并行执行区]</span><br><span class="line">            Task_A[JD Meta Parser]</span><br><span class="line">            Task_B[Tech Question Generator]</span><br><span class="line">            Task_C[Company Research Agent]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        Service --&gt; Task_A</span><br><span class="line">        Task_A --&gt; Task_B</span><br><span class="line">        Task_A --&gt; Task_C</span><br><span class="line">        </span><br><span class="line">        Task_B &amp; Task_C --&gt; Task_D[HR Question Generator]</span><br><span class="line">        </span><br><span class="line">        Task_B --&gt; Chains[LangChain Logic]</span><br><span class="line">        Task_C --&gt; Chains</span><br><span class="line">        </span><br><span class="line">        Chains --&gt; LLM_Factory[LLM Factory (OpenAI/DeepSeek)]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    Service --&gt;|Structured JSON| Client</span><br></pre></td></tr></table></figure><h3 id="2-2-核心组件">2.2 核心组件</h3><ul><li><strong>Web 框架</strong>: <code>FastAPI</code> (利用其原生异步特性处理 IO 密集型任务)。</li><li><strong>LLM 编排</strong>: <code>LangChain</code> (管理 Prompt、Chain 和 OutputParser)。</li><li><strong>数据验证</strong>: <code>Pydantic</code> (强制 LLM 输出符合 Schema 的 JSON)。</li><li><strong>并发控制</strong>: <code>Python Asyncio</code> (实现多 Chain 并行调用)。</li><li><strong>模型层</strong>: 支持 <code>OpenAI</code> 协议，实测完美兼容 <code>DeepSeek-V3</code>。</li></ul><hr><h2 id="3-核心实现细节-Implementation-Details">3. 核心实现细节 (Implementation Details)</h2><h3 id="3-1-强制结构化输出-Structured-Output">3.1 强制结构化输出 (Structured Output)</h3><p>大模型天生喜欢“聊天”，为了让它输出 JSON，我们摒弃了不稳定的正则表达式，转而使用 LangChain 的 <code>PydanticOutputParser</code>。</p><p><strong>Schema 定义 (<code>schemas/interview.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterviewReport</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    meta: JDMetaData</span><br><span class="line">    tech_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    hr_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    <span class="comment"># 使用 Optional 处理非必填项，增强鲁棒性</span></span><br><span class="line">    system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>Chain 实现 (<code>chains/tech_gen.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parser = PydanticOutputParser(pydantic_object=QuestionList)</span><br><span class="line">prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    请严格按照 JSON 格式输出:</span></span><br><span class="line"><span class="string">    &#123;format_instructions&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 注入 Pydantic 生成的 Schema 指令</span></span><br><span class="line">chain = prompt | llm | parser</span><br></pre></td></tr></table></figure><h3 id="3-2-异步并发编排-Asyncio-Optimization">3.2 异步并发编排 (Asyncio Optimization)</h3><p>这是本项目性能提升的关键。</p><ul><li><strong>串行模式</strong>：解析 JD (5s) -&gt; 查公司 (10s) -&gt; 出技术题 (10s) -&gt; 出 HR 题 (5s) = <strong>30s+</strong></li><li><strong>并行模式</strong>：解析 JD (5s) -&gt; [查公司 | 出技术题] (同时进行, 取最大值 10s) -&gt; 出 HR 题 = <strong>约 15s</strong></li></ul><p><strong>Service 层实现 (<code>services/interview_service.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request: JDRequest</span>):</span><br><span class="line">    <span class="comment"># 1. 前置依赖：必须先解析 JD</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造并行任务 (Fire tasks)</span></span><br><span class="line">    <span class="comment"># 技术题不依赖公司背景</span></span><br><span class="line">    task_tech = generate_tech_async(jd_meta.tech_stack, jd_meta.years_required)</span><br><span class="line">    <span class="comment"># 公司背调是网络 IO 密集型</span></span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 核心：并发等待</span></span><br><span class="line">    tech_qs, company_info = <span class="keyword">await</span> asyncio.gather(task_tech, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 后置依赖：HR 题依赖公司背景</span></span><br><span class="line">    hr_qs = <span class="keyword">await</span> generate_hr_async(jd_meta.soft_skills, company_info)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InterviewReport(...)</span><br></pre></td></tr></table></figure><h3 id="3-3-兼容多模型的-LLM-工厂">3.3 兼容多模型的 LLM 工厂</h3><p>为了在开发阶段节省成本（使用 DeepSeek），在生产阶段追求稳定（使用 OpenAI），我们设计了工厂模式。</p><p><strong>配置解耦 (<code>core/config.py</code>):</strong><br>通过 <code>.env</code> 文件动态切换底座，无需修改业务代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span></span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span> <span class="comment"># 默认指向 DeepSeek</span></span><br><span class="line">    MODEL_NAME: <span class="built_in">str</span> = <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-工程化踩坑与解决方案-Troubleshooting">4. 工程化踩坑与解决方案 (Troubleshooting)</h2><p>在开发过程中，我们遇到了数个真实的工程挑战，以下是排查记录。</p><h3 id="坑位-1：API-余额与鉴权混淆-429-vs-402">坑位 1：API 余额与鉴权混淆 (429 vs 402)</h3><ul><li><strong>现象</strong>: 程序崩溃，报错 <code>openai.RateLimitError: Error code: 429</code> 或 <code>402 Payment Required</code>。</li><li><strong>分析</strong>:<ul><li><code>429</code> 通常指速率限制，但 OpenAI 在余额不足时也会报这个错（<code>insufficient_quota</code>）。</li><li><code>402</code> 是明确的余额为零。</li></ul></li><li><strong>解决</strong>:<ul><li>不要死磕代码逻辑。</li><li>切换至 <strong>DeepSeek</strong>（充值 10 元人民币可用很久）或 <strong>SiliconFlow</strong>（免费额度）。</li><li>修改 <code>.env</code> 即可解决。</li></ul></li></ul><h3 id="坑位-2：Pydantic-字段校验异常">坑位 2：Pydantic 字段校验异常</h3><ul><li><strong>现象</strong>: <code>ValidationError: system_design_question Input should be a valid dictionary</code>。</li><li><strong>分析</strong>: 业务逻辑中某些情况下未生成系统设计题，返回了 <code>None</code>，但 Schema 定义默认为必填。</li><li><strong>解决</strong>: 使用 <code>Optional</code> 类型提示。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line">system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-3：SSL-证书警告-Mac-环境">坑位 3：SSL 证书警告 (Mac 环境)</h3><ul><li><strong>现象</strong>: <code>NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+</code></li><li><strong>分析</strong>: macOS 自带的 LibreSSL 版本过低，与新版 <code>urllib3</code> 不兼容。</li><li><strong>解决</strong>: 降级 urllib3 或使用 Homebrew 升级 OpenSSL。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&quot;urllib3&lt;2.0&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-4：Nginx-反向代理超时-504-Gateway-Time-out">坑位 4：Nginx 反向代理超时 (504 Gateway Time-out)</h3><ul><li><strong>现象</strong>: 爬虫或长文本生成任务耗时超过 60s，前端收到 504 错误。</li><li><strong>分析</strong>: Nginx 默认 <code>proxy_read_timeout</code> 为 60s。</li><li><strong>解决</strong>: 在 Nginx 配置中针对 API 路由增加超时时间。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600s</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p><code>jd_agent</code> 项目展示了如何将一个简单的 Prompt 交互转化为一个<strong>工业级的后端服务</strong>。</p><p><strong>核心收益</strong>:</p><ol><li><strong>效率提升</strong>: 并行处理使响应速度提升 <strong>300%</strong>。</li><li><strong>成本降低</strong>: 通过 LLM 工厂模式切换至 DeepSeek，Token 成本降低 <strong>90%</strong>。</li><li><strong>稳定性</strong>: 强类型校验和重试机制保证了服务的鲁棒性。</li></ol><p><strong>后续规划</strong>:</p><ul><li>引入 <strong>Redis</strong> 缓存 JD 解析结果，避免重复扣费。</li><li>集成 <strong>Celery</strong> 处理超长耗时的系统设计题生成。</li><li>开发 <strong>React/Next.js</strong> 前端，实现流式 Markdown 渲染。</li></ul><hr><p><em>如果你觉得这个项目对你有帮助，欢迎在 GitHub 上点个 Star ⭐️！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GitHub 仓库&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com/caozhaoqi/jd_agent&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实现高可用 MySQL 集群</title>
    <link href="https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/"/>
    <id>https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/</id>
    <published>2025-09-30T02:18:54.000Z</published>
    <updated>2025-11-25T15:05:10.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备阶段：项目结构">准备阶段：项目结构</h3><blockquote><p>首先，在您的服务器上创建一个项目文件夹，结构如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql_cluster/</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── proxysql/</span><br><span class="line">│   └── proxysql.cnf</span><br><span class="line">└── mysql/</span><br><span class="line">    ├── master/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── master.cnf</span><br><span class="line">    ├── slave1/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── slave1.cnf</span><br><span class="line">    └── slave2/</span><br><span class="line">        └── conf/</span><br><span class="line">            └── slave2.cnf</span><br></pre></td></tr></table></figure><h3 id="阶段一：编写配置文件">阶段一：编写配置文件</h3><h4 id="1-主库配置-mysql-master-conf-master-cnf">1. 主库配置 (<code>mysql/master/conf/master.cnf</code>)</h4><p>这个文件定义了主库的特定配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">100</span></span><br><span class="line"><span class="attr">log-bin</span>                 = /var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我们使用了 <code>GTID</code> 模式，这是比传统基于 <code>File</code> 和 <code>Position</code> 更现代、更可靠的复制方式。</p><h4 id="2-从库配置-mysql-slave1-conf-slave1-cnf-和-slave2-cnf">2. 从库配置 (<code>mysql/slave1/conf/slave1.cnf</code> 和 <code>slave2.cnf</code>)</h4><p>两个从库的配置类似，只需更改 <code>server-id</code>。</p><p><strong><code>slave1.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">101</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>slave2.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">102</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="3-ProxySQL-配置-proxysql-proxysql-cnf">3. ProxySQL 配置 (<code>proxysql/proxysql.cnf</code>)</h4><p>这个文件用于初始化 ProxySQL 的配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">admin_credentials</span>=<span class="string">&quot;admin:admin&quot;</span></span><br><span class="line">    <span class="attr">mysql_ifaces</span>=<span class="string">&quot;0.0.0.0:6032&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">mysql_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">connect_timeout_server</span>=<span class="number">3000</span></span><br><span class="line">    <span class="attr">monitor_username</span>=<span class="string">&quot;monitor_user&quot;</span></span><br><span class="line">    <span class="attr">monitor_password</span>=<span class="string">&quot;monitor_password&quot;</span></span><br><span class="line">    <span class="attr">monitor_connect_timeout</span>=<span class="number">2000</span></span><br><span class="line">    <span class="attr">monitor_ping_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_interval</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">commands_stats</span>=<span class="string">&quot;enabled&quot;</span></span><br><span class="line">    <span class="attr">connect_timeout_server_max</span>=<span class="number">10000</span></span><br><span class="line">    <span class="attr">stacksize</span>=<span class="number">1048576</span></span><br><span class="line">    <span class="attr">threads</span>=<span class="number">4</span></span><br><span class="line">    <span class="attr">max_connections</span>=<span class="number">2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里我们定义了 ProxySQL 的管理用户 (<code>admin:admin</code>) 和一个用于监控后端 MySQL 健康状态的监控用户 (<code>monitor_user:monitor_password</code>)。</p><h4 id="4-Docker-Compose-文件-docker-compose-yml">4. Docker Compose 文件 (<code>docker-compose.yml</code>)</h4><p>这是整个架构的核心编排文件。它定义了所有的服务、网络和数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主数据库</span></span><br><span class="line">  <span class="attr">mysql_master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_master</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">my_app_db</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/master/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库1</span></span><br><span class="line">  <span class="attr">mysql_slave1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave1/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库2</span></span><br><span class="line">  <span class="attr">mysql_slave2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave2/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ProxySQL 中间件</span></span><br><span class="line">  <span class="attr">proxysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">proxysql/proxysql:2.4.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6032:6032&quot;</span> <span class="comment"># 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6033:6033&quot;</span> <span class="comment"># 客户端连接端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./proxysql/proxysql.cnf:/etc/proxysql.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proxysql_data:/var/lib/proxysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_master_data:</span></span><br><span class="line">  <span class="attr">mysql_slave1_data:</span></span><br><span class="line">  <span class="attr">mysql_slave2_data:</span></span><br><span class="line">  <span class="attr">proxysql_data:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mysql_cluster_net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p><strong>请务必将 <code>your_root_password</code> 替换为您自己的强密码。</strong></p><h3 id="阶段二：启动和配置集群">阶段二：启动和配置集群</h3><ol><li><p><strong>启动所有服务</strong>：<br>在 <code>mysql_cluster</code> 文件夹下，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Docker 会自动拉取镜像并按顺序启动所有容器。</p></li><li><p><strong>配置主从复制</strong>：<br>我们需要进入主库容器，创建复制用户和 ProxySQL 的监控用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入主库容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_master bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># (输入您在docker-compose中设置的密码)</span></span><br></pre></td></tr></table></figure><p>在MySQL命令行中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复制用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;repl_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建ProxySQL监控用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;monitor_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>现在，配置两个从库</strong>。进入每个从库容器，执行 <code>CHANGE MASTER TO</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入从库1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_slave1 bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>在从库1的MySQL命令行中执行（对从库2重复此操作）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用GTID自动定位，比File/Position更简单</span></span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST<span class="operator">=</span><span class="string">&#x27;mysql_master&#x27;</span>,  <span class="comment">-- 使用Docker的服务名</span></span><br><span class="line">  MASTER_USER<span class="operator">=</span><span class="string">&#x27;repl_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;repl_password&#x27;</span>,</span><br><span class="line">  MASTER_AUTO_POSITION<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> SLAVE;</span><br><span class="line"><span class="comment">-- 验证状态</span></span><br><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS\G; </span><br></pre></td></tr></table></figure><p>在从库2上重复以上 <code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 的步骤。</p></li><li><p><strong>配置 ProxySQL</strong>：<br>连接到 ProxySQL 的管理后台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，是从您的宿主机连接，不是在容器里</span></span><br><span class="line">mysql -u admin -padmin -h 127.0.0.1 -P 6032</span><br></pre></td></tr></table></figure><p>在 ProxySQL 管理后台执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置监控用户凭证（与proxysql.cnf和MySQL中创建的一致）</span></span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_user&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_username&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_password&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_password&#x27;</span>;</span><br><span class="line">LOAD MYSQL VARIABLES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置后端MySQL服务器</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers(hostgroup_id, hostname, port) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;mysql_master&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 写入组 (主库)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave1&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 读取组 (从库1)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave2&#x27;</span>, <span class="number">3306</span>); <span class="comment">-- 读取组 (从库2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置应用连接用户</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_users(username, password, default_hostgroup) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;app_user&#x27;</span>, <span class="string">&#x27;app_password&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义读写分离规则</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules(rule_id, active, match_digest, destination_hostgroup, apply) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;^SELECT.*&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;.*&#x27;</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">-- 一个更简单的规则：匹配SELECT的去读取组，其他所有都去写入组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载并保存配置</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL USERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL QUERY RULES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL USERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL QUERY RULES <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure></li></ol><h3 id="proxy-sql-web">proxy-sql-web</h3><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxysql-web:</span></span><br><span class="line">    <span class="comment"># --- 修改点在这里 ---</span></span><br><span class="line">    <span class="comment"># 使用一个在 Docker Hub 上公开可用的镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kishorj/proxysql-web:latest</span></span><br><span class="line">    <span class="comment"># ------------------</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql-web</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=192.168.10.158</span> <span class="comment"># 您的 ProxySQL 服务器 IP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=6032</span>         <span class="comment"># ProxySQL 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=admin</span>          <span class="comment"># ProxySQL 管理用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=admin</span>          <span class="comment"># ProxySQL 管理密码</span></span><br></pre></td></tr></table></figure><ul><li>run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="阶段三：切换应用">阶段三：切换应用</h3><p>现在，您的整个高可用集群已经在 Docker 中运行起来了。最后一步就是将您所有200多台电脑上的应用程序的数据库连接配置，指向 ProxySQL 容器暴露的端口。</p><ul><li><strong>Host</strong>: 运行 Docker 的那台服务器的 IP 地址。</li><li><strong>Port</strong>: <code>6033</code></li><li><strong>User</strong>: <code>app_user</code></li><li><strong>Password</strong>: <code>app_password</code></li></ul><h3 id="优点总结">优点总结</h3><ul><li><strong>环境一致性</strong>：无论部署到哪台机器，整个集群的环境都是完全一致的。</li><li><strong>快速部署与销毁</strong>：使用 <code>docker-compose up -d</code> 和 <code>docker-compose down -v</code> 可以秒级创建和彻底销毁整套环境，非常适合测试和开发。</li><li><strong>简化管理</strong>：服务之间的网络和依赖关系由 Docker Compose 管理，比手动配置网络和防火墙简单得多。</li><li><strong>资源隔离</strong>：每个服务都在自己的容器中运行，互不干扰。</li></ul><p>这个 Docker 化的方案为您提供了一个可移植、可复现、高度自动化的方式来部署和管理您的MySQL读写分离集群。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;准备阶段：项目结构&quot;&gt;准备阶段：项目结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，在您的服务器上创建一个项目文件夹，结构如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Devpi与Nginx构建高可用PyPI镜像源</title>
    <link href="https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/"/>
    <id>https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/</id>
    <published>2025-09-17T06:03:20.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Devpi与Nginx构建高可用PyPI镜像源">使用Devpi与Nginx构建高可用PyPI镜像源</h2><h3 id="前言：为什么你的pip-install又超时了？">前言：为什么你的<code>pip install</code>又超时了？</h3><p>对于每一位Python开发者来说，<code>pip install</code> 无疑是最常用的命令之一。然而，团队开发中，我们常常会遇到这些痛点：</p><ul><li><strong>速度瓶颈</strong>：团队几十号人，CI/CD流水线上百个任务，全都从国外的官方PyPI源拉取包，下载速度慢得令人抓狂，严重影响开发和部署效率。</li><li><strong>单点故障</strong>：官方PyPI偶尔会抖动，或者公司出口网络出现问题，导致所有依赖安装失败，研发流程瞬间停摆。</li><li><strong>安全与合规</strong>：无法对团队使用的第三方包进行统一管理和安全审计。</li><li><strong>私有包托管</strong>：团队内部开发的公共库无处安放，只能通过Git仓库等原始方式共享。</li></ul><p>为了彻底解决这些问题，我们需要一个<strong>私有的、高速的、且永不宕机</strong>的Python包仓库。今天，我将手把手带你使用业界最强大的开源工具 <strong><code>devpi</code></strong> 和 <strong><code>Nginx</code></strong>，构建一个具备自动故障转移能力的高可用PyPI镜像源。</p><p><strong>最终目标</strong>：无论清华源、阿里源还是其他任何一个镜像挂了，我们的 <code>pip install</code> 依然能丝滑流畅地运行，对开发者完全透明！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-------------------+     +-------------------------+     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |   Tsinghua Mirror       |</span><br><span class="line">|  开发者   | --&gt; |  devpi 服务器      | --&gt; |  Nginx 反向代理          | --&gt; |  (Upstream 1)            |</span><br><span class="line">| (pip)     |     | (缓存/私有包)      |     | (处理上游故障转移)       |     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |  Aliyun Mirror         |</span><br><span class="line">+-----------+     +-------------------+     +-------------------------+ --&gt; |  (Upstream 2)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  USTC Mirror             |</span><br><span class="line">                                                                          -&gt;|  (Upstream 3)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  ... and so on           |</span><br><span class="line">                                                                            +--------------------------+</span><br></pre></td></tr></table></figure><h3 id="第一章：核心武器介绍-Devpi-与-Nginx">第一章：核心武器介绍 - Devpi 与 Nginx</h3><p>在开始之前，我们先了解一下两位主角：</p><ol><li><p><strong>Devpi</strong>: 一个功能完备的Python包服务器。它不仅仅是 <code>pypi.org</code> 的一个缓存代理，更是一个强大的私有包仓库和版本发布管理工具。我们将主要利用它的<strong>缓存镜像</strong>功能。</p></li><li><p><strong>Nginx</strong>: 一款高性能的HTTP和反向代理服务器。在这里，它将扮演我们镜像源的“智能调度员”和“故障哨兵”，负责监测上游镜像源的健康状况，并在某个源出现问题时，自动将流量切换到健康的备用源上。</p></li></ol><h3 id="第二章：基础建设-搭建Devpi缓存服务器">第二章：基础建设 - 搭建Devpi缓存服务器</h3><p>首先，我们需要一个能稳定运行的<code>devpi</code>服务。</p><h4 id="步骤-1-准备服务器与安装Devpi">步骤 1: 准备服务器与安装Devpi</h4><p>在一台Linux服务器（本教程以Ubuntu为例）上，确保已安装Python和pip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新并安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 devpi-server</span></span><br><span class="line">pip3 install devpi-server</span><br><span class="line"></span><br><span class="line">devpi-init</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤-2-初始化Devpi">步骤 2: 初始化Devpi</h4><p>这个一次性操作会为你创建数据目录和 <code>root</code> 超级管理员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devpi-init</span><br></pre></td></tr></table></figure><p>在提示中，为 <code>root</code> 用户设置一个安全的密码，并牢牢记住它。</p><h4 id="步骤-3-让Devpi在后台稳定运行">步骤 3: 让Devpi在后台稳定运行</h4><p>为了生产环境的稳定，我们将 <code>devpi</code> 配置成一个 <code>systemd</code> 系统服务，实现开机自启和后台运行。</p><ol><li><p><strong>创建服务文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下配置</strong> (注意修改 <code>User</code> 和 <code>ExecStart</code> 中的路径为你自己的):</p></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ sudo cat /etc/systemd/system/devpi.service</span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=devpi-server daemon</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=czq2</span><br><span class="line"><span class="attr">Group</span>=czq2</span><br><span class="line"><span class="attr">ExecStart</span>=/home/czq2/clip-video/venv/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><code>--host=0.0.0.0</code> 确保局域网内的其他机器可以访问。</li></ul><ol start="3"><li><strong>启动并验证服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> devpi  <span class="comment"># 开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi   <span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status devpi  <span class="comment"># 检查状态</span></span><br></pre></td></tr></table></figure>看到绿色的 <code>active (running)</code>，恭喜你，基础的 <code>devpi</code> 镜像服务已经成功运行在 <code>http://&lt;你的服务器IP&gt;:3141</code> 上了！</li></ol><ul><li>成功输出</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl start devpi</span><br><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl status devpi</span><br><span class="line">● devpi.service - devpi-server daemon</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/devpi.service; enabled; preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2025-09-17 07:19:23 UTC; 3s ago</span><br><span class="line">   Main PID: 1619813 (devpi-server)</span><br><span class="line">      Tasks: 54 (<span class="built_in">limit</span>: 309293)</span><br><span class="line">     Memory: 41.4M (peak: 553.5M)</span><br><span class="line">        CPU: 15.733s</span><br><span class="line">     CGroup: /system.slice/devpi.service</span><br><span class="line">             └─1619813 /home/czq2/clip-video/venv/bin/python3 /home/czq2/clip-video/venv/bin/devpi-server --host=0.0.0.0 --p&gt;</span><br><span class="line"></span><br><span class="line">Sep 17 07:19:23 czq2 devpi-server[1619813]: 2025-09-17 07:19:23,634 WARNI NOCTX No secret file provided, creating a new rand&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,757 INFO  [ASYN] Starting asyncio event loop</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX devpi-server version: 6.17.0</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serverdir: /home/czq2/.devpi/server</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX uuid: 0c7aa3d0d1874fd596c8936cd007d305</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serving at url: http://0.0.0.0:3141 (might b&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX using 50 threads</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX bug tracker: https://github.com/devpi/devpi/&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX Hit Ctrl-C to quit.</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,785 INFO  Serving on http://0.0.0.0:3141</span><br></pre></td></tr></table></figure><ul><li>错误分析</li></ul> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u devpi.service -n 50 --no-pager</span><br></pre></td></tr></table></figure><h3 id="第三章：构建护城河-Nginx高可用反向代理">第三章：构建护城河 - Nginx高可用反向代理</h3><p>现在，我们要为 <code>devpi</code> 构建一个坚固的前哨站，让它不再直接依赖任何单一的上游源。</p><h4 id="步骤-1-安装-Nginx">步骤 1: 安装 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nginx</span><br></pre></td></tr></table></figure><h4 id="步骤-2-编写Nginx高可用配置">步骤 2: 编写Nginx高可用配置</h4><p>这是实现自动故障转移的<strong>核心</strong>。</p><ol><li><p><strong>创建Nginx配置文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/sites-available/pypi-proxy</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下魔法配置</strong>:</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /etc/nginx/sites-available/pypi-proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义一个上游服务器组，这次全部使用 HTTPS</span></span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> pypi_mirrors_https &#123;</span><br><span class="line">    <span class="comment"># 【核心修改】直接指向 HTTPS 域名，端口 443 是默认的，可以不写</span></span><br><span class="line">    <span class="attribute">server</span> pypi.tuna.tsinghua.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.aliyun.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> pypi.mirrors.ustc.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.cloud.tencent.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> repo.huaweicloud.com:<span class="number">443</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 【核心修改】将请求代理到我们新的 HTTPS 服务器组</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 故障转移的配置保持不变</span></span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 【重要】当代理到 HTTPS 上游时，必须正确设置 Host 头</span></span><br><span class="line">        <span class="comment"># 这里的 $host 会是上游服务器组的名称，为了正确性，我们应该传递原始请求的Host</span></span><br><span class="line">        <span class="comment"># 或者直接硬编码为 pypi.tuna.tsinghua.edu.cn 等，但传递原始Host更灵活</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>; <span class="comment"># 使用 $proxy_host 变量</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># （可选，但推荐）增加 SSL 相关的代理设置</span></span><br><span class="line">        <span class="attribute">proxy_ssl_server_name</span> <span class="literal">on</span>; <span class="comment"># 这会让Nginx在TLS握手中发送正确的服务器名称(SNI)</span></span><br><span class="line">        <span class="attribute">proxy_ssl_session_reuse</span> <span class="literal">on</span>; <span class="comment"># 启用SSL会话复用以提高性能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>启用配置并重启Nginx</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /etc/nginx/sites-available/pypi-proxy /etc/nginx/sites-enabled/</span><br><span class="line"><span class="built_in">sudo</span> nginx -t          <span class="comment"># 测试配置语法</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nginx <span class="comment"># 重启Nginx</span></span><br></pre></td></tr></table></figure>现在，一个强大的、能自动切换源的反向代理已经在 <code>http://192.168.10.158:8088</code> 上为你待命。</li></ol><hr><h3 id="第四章：合体！将Devpi接入Nginx代理">第四章：合体！将Devpi接入Nginx代理</h3><p>万事俱备，只差最后一步：让 <code>devpi</code> 通过我们的 Nginx “护城河”去访问世界。</p><ol><li><p><strong>停止Devpi服务</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop devpi</span><br></pre></td></tr></table></figure></li><li><p><strong>修改Devpi的启动参数</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p>在 <code>ExecStart</code> 行的末尾，添加 <code>--mirror-url</code> 参数，指向我们的Nginx代理：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">ExecStart</span>=/home/your_username/.local/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span> --mirror-url http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">8088</span>/pypi</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重新加载并启动Devpi</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="第五章：享受成果-配置客户端">第五章：享受成果 - 配置客户端</h3><p>现在，让团队的所有开发者和CI/CD服务器都享受到这个稳定高速的镜像源吧！</p><p>在每一台客户端机器上，创建或修改 <code>~/.pip/pip.conf</code> (macOS/Linux) 或 <code>%APPDATA%\pip\pip.ini</code> (Windows) 文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">3141</span>/root/pypi/</span><br><span class="line"><span class="attr">trusted-host</span> = <span class="number">192.168</span>.<span class="number">10.158</span></span><br></pre></td></tr></table></figure><ul><li><code>index-url</code> 指向我们搭建的 <code>devpi</code> 服务。</li><li><code>trusted-host</code> 告诉 <code>pip</code> 这是一个可信任的HTTP源。</li></ul><h3 id="使用docker-compose-搭建-devpi">使用docker compose 搭建 devpi</h3><ul><li>docker-comose.yml</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 属性已过时，可以移除</span></span><br><span class="line"><span class="comment"># version: &quot;2.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务1：高可用 Nginx 反向代理</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们的 stream 配置文件挂载到容器中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="comment"># 这个服务只在内部使用，不需要暴露端口到宿主机</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务2：Devpi 服务器</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lowinli98/devpi:v0.2</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7104</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_HOST=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PORT=7104</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_ROOT_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_USER=czq</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_MIRROR_INDEX=pypi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_LIB_INDEX=devpi</span></span><br><span class="line">      <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">      <span class="comment"># 将上游镜像源指向我们内部的 nginx-proxy 服务的 443 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SOURCE_MIRROR_URL=http://nginx-proxy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="comment"># 【重要】确保 devpi 服务依赖于 nginx-proxy 服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br></pre></td></tr></table></figure><ul><li>nignx conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># nginx_conf/nginx.conf (HTTP 代理版本)</span><br><span class="line"></span><br><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 定义高可用的 PyPI 镜像上游服务器池</span><br><span class="line">    upstream pypi_mirrors_https &#123;</span><br><span class="line">        server pypi.tuna.tsinghua.edu.cn:443;</span><br><span class="line">        server mirrors.aliyun.com:443;</span><br><span class="line">        server pypi.mirrors.ustc.edu.cn:443;</span><br><span class="line">        server mirrors.cloud.tencent.com:443;</span><br><span class="line">        server pypi.douban.com:443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听容器内部的 80 端口，接收来自 devpi-lib 的 HTTP 请求</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # 将请求代理到 HTTPS 上游</span><br><span class="line">            proxy_pass https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">            # --- 代理核心配置 ---</span><br><span class="line">            proxy_next_upstream error timeout http_502 http_503 http_504;</span><br><span class="line">            proxy_connect_timeout 10s;</span><br><span class="line"></span><br><span class="line">            # --- 关键的请求头与 SSL/TLS 配置 ---</span><br><span class="line">            proxy_set_header Host $proxy_host;</span><br><span class="line">            proxy_ssl_server_name on;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_ssl_session_reuse on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>docker run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build</span><br></pre></td></tr></table></figure><h3 id="自建devpi镜像">自建devpi镜像</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终稳定版)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个官方的、轻量级的 Python 3.9 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【构建时网络优化】</span></span><br><span class="line"><span class="comment"># 将 pip 的默认源设置为高速的镜像源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【核心 Bug 修复 &amp; 版本锁定】 ---</span></span><br><span class="line"><span class="comment"># 安装应用程序及其依赖，并锁定所有核心组件的版本</span></span><br><span class="line"><span class="comment"># devpi-server 6.9.x 是一个非常稳定的系列</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据卷挂载点</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【权限修复】</span></span><br><span class="line"><span class="comment"># 将数据目录的所有者更改为非 root 用户 (UID 1000)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R 1000:1000 /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【安全实践】</span></span><br><span class="line"><span class="comment"># 将容器的默认运行用户切换为非 root 用户</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明容器将要监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动时要执行的默认命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;devpi-server&quot;</span>, <span class="string">&quot;--serverdir&quot;</span>, <span class="string">&quot;/var/lib/devpi&quot;</span>, <span class="string">&quot;--host&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7104&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (最终、决定性版本)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">    <span class="comment"># 不再使用旧的 image，而是使用 build 指令</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 表示使用当前目录下的 Dockerfile 来构建镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="comment"># 【重要】我们不再需要旧镜像的环境变量来自动化配置</span></span><br><span class="line">    <span class="comment"># 我们将在启动后，手动进行一次性配置，这更可靠</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">        <span class="comment"># environment:</span></span><br><span class="line">    <span class="comment">#   - ... (可以全部删除)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 数据卷依然需要，用于持久化 devpi 的数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol><li><strong>在你的客户端电脑上，安装 <code>devpi-client</code></strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R czq2:czq2 ./volume <span class="comment"># 更改目录权限</span></span><br><span class="line">pip install devpi-client</span><br></pre></td></tr></table></figure></li><li><ol start="2"><li><strong>登录到你的新 <code>devpi</code> 服务器</strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指向服务器</span></span><br><span class="line">devpi use http://&lt;你的服务器IP&gt;:7104</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次登录 root 用户，devpi-server 会自动创建，无需密码</span></span><br><span class="line"><span class="comment"># 然后会强制你设置新密码</span></span><br><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># (按照提示输入你的新 root 密码)</span></span><br></pre></td></tr></table></figure></li><li><ol start="3"><li><strong>【关键】配置 <code>root/pypi</code> 镜像</strong>:<br>默认的 <code>root/pypi</code> 指向 <code>pypi.org</code>。我们需要将它修改为指向我们内部的 <code>nginx-proxy</code>。</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保你已登录 root</span></span><br><span class="line">devpi index root/pypi mirror_url=http://nginx-proxy</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>: 这里的 <code>http://nginx-proxy</code> 是 <code>devpi-lib</code> 容器内部访问 <code>nginx-proxy</code> 容器的地址。<code>devpi-server</code> 在收到这个配置后，它内部发起的请求就会走这条路。</li></ul></li><li><ol start="4"><li><strong>验证</strong>:<br>在你的客户端电脑上，配置好 <code>pip</code> 指向 <code>http://&lt;服务器IP&gt;:7104/root/pypi/</code>，然后执行 <code>pip install numpy</code>。</li></ol></li></ul><h3 id="成功日志">成功日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(.venv) czq2@czq2:~/pypi-docker$ sudo docker logs devpi-lib</span><br><span class="line">2025-09-22 02:56:36,728 INFO  [req12] POST /+login</span><br><span class="line">2025-09-22 02:57:08,329 INFO  [req13] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:08,339 INFO  [req14] PATCH /root/pypi</span><br><span class="line">2025-09-22 02:57:08,342 INFO  [req14] [Wtx13] modified index root/pypi: &#123;&#x27;type&#x27;: &#x27;mirror&#x27;, &#x27;volatile&#x27;: False, &#x27;title&#x27;: &#x27;PyPI&#x27;, &#x27;mirror_url&#x27;: &#x27;http://mirrors.aliyun.com/pypi/simple/&#x27;, &#x27;mirror_web_url_fmt&#x27;: &#x27;https://pypi.org/project/&#123;name&#125;/&#x27;&#125;</span><br><span class="line">2025-09-22 02:57:08,345 INFO  [req14] [Wtx13] fswriter14: committed at 14</span><br><span class="line">2025-09-22 02:57:08,351 INFO  [req15] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:25,788 INFO  [req16] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:40,843 INFO  [req17] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:41,058 INFO  [req18] GET /root</span><br><span class="line">2025-09-22 02:57:41,533 INFO  [req19] GET /+static-4.1.0/favicon.ico</span><br><span class="line">2025-09-22 02:57:43,732 INFO  [Wtx14] fswriter15: committed at 15</span><br><span class="line">2025-09-22 02:57:43,885 INFO  [NOTI] [Rtx15] indexing &#x27;root/pypi&#x27; mirror with 658356 projects</span><br><span class="line">2025-09-22 02:57:44,305 INFO  [IDX] Indexer queue size ~ 2</span><br><span class="line">2025-09-22 02:57:46,680 INFO  [req20] GET /root</span><br><span class="line">2025-09-22 02:57:47,303 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:57:47,410 INFO  [req21] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:48,180 INFO  [req22] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:48,183 INFO  [req22] starting +simple</span><br><span class="line">2025-09-22 02:57:52,640 INFO  [req23] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:52,643 INFO  [req23] starting +simple</span><br><span class="line">2025-09-22 02:58:00,856 INFO  [IDX] Indexer queue size ~ 23</span><br><span class="line">2025-09-22 02:58:03,872 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:13,593 INFO  [IDX] Indexer queue size ~ 43</span><br><span class="line">2025-09-22 02:58:16,637 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:24,550 INFO  [IDX] Indexer queue size ~ 63</span><br><span class="line">2025-09-22 02:58:27,063 INFO  [req24] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:58:27,068 INFO  [req24] starting +simple</span><br><span class="line">2025-09-22 02:58:31,043 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:36,905 INFO  [IDX] Indexer queue size ~ 84</span><br><span class="line">2025-09-22 02:58:40,109 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:46,493 INFO  [IDX] Indexer queue size ~ 105</span><br><span class="line">2025-09-22 02:58:49,808 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:57,171 INFO  [req25] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:58:57,452 INFO  [req26] GET /root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:57,703 INFO  [req26] [Rtx15] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/68/1f/795e7f4aa2eacc59afa4fb61a2e35e510d06414dd5a802b51a012d691b37/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl&#x27;), target root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:58,698 INFO  [IDX] Indexer queue size ~ 125</span><br><span class="line">2025-09-22 02:59:02,452 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:13,134 INFO  [Wtx15] fswriter16: committed at 16</span><br><span class="line">2025-09-22 02:59:13,406 INFO  [req27] GET /root/pypi/numpy/</span><br><span class="line">2025-09-22 02:59:16,152 INFO  [IDX] Indexer queue size ~ 144</span><br><span class="line">2025-09-22 02:59:20,559 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:22,506 INFO  [Wtx16] fswriter17: committed at 17</span><br><span class="line">2025-09-22 02:59:22,974 INFO  [req28] GET /root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:23,201 INFO  [req28] [Rtx17] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/8c/3d/1e1db36cfd41f895d266b103df00ca5b3cbe965184df824dec5c08c6b803/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl&#x27;), target root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:25,317 INFO  [Wtx17] fswriter18: committed at 18</span><br><span class="line">2025-09-22 02:59:29,854 INFO  [IDX] Indexer queue size ~ 157</span><br><span class="line">2025-09-22 02:59:32,438 INFO  [req29] GET /czq/devpi</span><br><span class="line">2025-09-22 02:59:33,214 INFO  [req30] GET /czq/devpi/+simple/</span><br><span class="line">2025-09-22 02:59:33,219 INFO  [req30] starting +simple</span><br><span class="line">2025-09-22 02:59:33,222 WARNI [req30] [Rtx18] Index czq/devpi refers to non-existing base czq/pypi.</span><br><span class="line">2025-09-22 02:59:33,419 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:35,333 INFO  [req31] GET /root/dev</span><br><span class="line">2025-09-22 02:59:36,071 INFO  [req32] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:59:36,073 INFO  [req32] starting +simple</span><br><span class="line">2025-09-22 02:59:45,543 INFO  [IDX] Indexer queue size ~ 183</span><br><span class="line">2025-09-22 02:59:49,092 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:59,191 INFO  [IDX] Indexer queue size ~ 204</span><br><span class="line">2025-09-22 02:59:59,375 INFO  [req33] GET /</span><br><span class="line">2025-09-22 03:00:02,409 INFO  [req34] GET /+search</span><br><span class="line">2025-09-22 03:00:03,190 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:12,782 INFO  [IDX] Indexer queue size ~ 223</span><br><span class="line">2025-09-22 03:00:16,424 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:22,925 INFO  [IDX] Indexer queue size ~ 243</span><br></pre></td></tr></table></figure><h2 id="python-搭建高可用">python 搭建高可用</h2><ul><li>python flask</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ha_proxy.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response, request</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 高可用镜像源列表 ---</span></span><br><span class="line"><span class="comment"># 将按照这个顺序尝试。可以随意增删或调整顺序。</span></span><br><span class="line">UPSTREAM_MIRRORS = [</span><br><span class="line">    <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.aliyun.com/pypi/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://pypi.mirrors.ustc.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.cloud.tencent.com/pypi/simple&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接和读取的超时时间（秒）</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proxy</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收来自 devpi-server 的所有请求，并尝试从上游镜像列表中获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> base_url <span class="keyword">in</span> UPSTREAM_MIRRORS:</span><br><span class="line">        url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Attempting to fetch from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># `requests` 会自动使用 HTTP_PROXY/HTTPS_PROXY 环境变量</span></span><br><span class="line">            response = requests.get(url, timeout=TIMEOUT, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果请求成功 (例如 200 OK)</span></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Success from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 使用流式响应，避免大文件占用过多内存</span></span><br><span class="line">                <span class="keyword">return</span> Response(response.iter_content(chunk_size=<span class="number">8192</span>),</span><br><span class="line">                                status=response.status_code,</span><br><span class="line">                                content_type=response.headers[<span class="string">&#x27;Content-Type&#x27;</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是 404，说明这个源没有这个包，立即尝试下一个</span></span><br><span class="line">            <span class="keyword">elif</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got 404 from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                 <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 其他客户端错误，也尝试下一个</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got client error <span class="subst">&#123;response.status_code&#125;</span> from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 捕获所有网络层面的错误 (如超时、连接失败)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Failed to connect to <span class="subst">&#123;base_url&#125;</span>. Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果所有镜像源都尝试失败</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: All upstream mirrors failed for path: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&quot;All upstream mirrors failed.&quot;</span>, status=<span class="number">502</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 监听在 8000 端口，只接受来自容器内部的连接</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><ul><li>supervisord.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; supervisord.conf (最终生产版)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon=true</span><br><span class="line"></span><br><span class="line">[program:devpi]</span><br><span class="line">command=devpi-server --serverdir /var/lib/devpi --host 0.0.0.0 --port 7104</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/devpi_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/devpi_out.log</span><br><span class="line"></span><br><span class="line">[program:ha_proxy]</span><br><span class="line">command=python3 /app/ha_proxy.py</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/ha_proxy_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/ha_proxy_out.log</span><br></pre></td></tr></table></figure><h3 id="同步更新dockerfile和docker-compose-yml">同步更新dockerfile和docker-compose.yml</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终生产版)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list.d/debian.sources</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【关键修复】创建一个专用的非 root 用户 ---</span></span><br><span class="line"><span class="comment"># 创建一个名为 devpiuser 的系统组和用户，并指定其 ID 为 1000</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> adduser \</span></span><br><span class="line"><span class="language-bash">    --system \</span></span><br><span class="line"><span class="language-bash">    --group \</span></span><br><span class="line"><span class="language-bash">    --uid 1000 \</span></span><br><span class="line"><span class="language-bash">    --no-create-home \</span></span><br><span class="line"><span class="language-bash">    --disabled-password \</span></span><br><span class="line"><span class="language-bash">    devpiuser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 安装所有依赖 ---</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y supervisor &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;flask&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;requests&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 复制配置文件和脚本 ---</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ha_proxy.py /app/ha_proxy.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 权限修复 ---</span></span><br><span class="line"><span class="comment"># 使用新创建的用户名 devpiuser 来设置权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /var/log/supervisor</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/log/supervisor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器将以 root 启动，由 supervisor 负责降权</span></span><br><span class="line"><span class="comment"># USER devpiuser (这里不需要，supervisor 会处理)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/supervisord&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (与最终高可用版 Dockerfile 配合使用)</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">devpi-data:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 代理配置依然需要，ha_proxy.py 会使用它</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">devpi-data:</span></span><br></pre></td></tr></table></figure><ul><li>docker build</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build --force-recreate</span><br></pre></td></tr></table></figure><ul><li>mirror set</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将 mirror_url 指向我们内部的 HA 代理服务</span></span><br><span class="line">devpi index root/pypi mirror_url=http://127.0.0.1:8000/</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li><ol><li><a href="https://github.com/devpi/devpi">https://github.com/devpi/devpi</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Devpi与Nginx构建高可用PyPI镜像源&quot;&gt;使用Devpi与Nginx构建高可用PyPI镜像源&lt;/h2&gt;
&lt;h3 id=&quot;前言：为什么你的pip-install又超时了？&quot;&gt;前言：为什么你的&lt;code&gt;pip install&lt;/code&gt;又超时了？&lt;/h</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker Compose 快速部署 Shadowsocks 代理服务教程</title>
    <link href="https://caozhaoqi.github.io/2025/08/29/ss-build-doc/"/>
    <id>https://caozhaoqi.github.io/2025/08/29/ss-build-doc/</id>
    <published>2025-08-29T01:06:20.000Z</published>
    <updated>2025-11-25T15:05:10.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境">基础环境</h2><h4 id="1-1-更新系统软件包列表">1.1 更新系统软件包列表</h4><p>首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br></pre></td></tr></table></figure><p>d</p><h4 id="1-2-安装-Docker-的依赖项">1.2 安装 Docker 的依赖项</h4><p>接下来，安装一些必要的软件包，以允许 <code>apt</code> 通过 HTTPS 使用 Docker 的软件仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h4 id="1-3-添加-Docker-官方-GPG-密钥">1.3 添加 Docker 官方 GPG 密钥</h4><p>为了安全起见，我们需要添加 Docker 的官方 GPG 密钥。这会验证我们下载的 Docker 软件包是官方发布的，未经篡改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于存放密钥的目录</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Docker 的 GPG 密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密钥文件的权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure><h4 id="1-4-设置-Docker-的-APT-软件源">1.4 设置 Docker 的 APT 软件源</h4><p>现在，我们将 Docker 的官方软件源地址添加到我们系统的源列表中。这样，<code>apt</code> 命令就能找到并安装 Docker 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 1.5 安装 Docker 引擎和 Compose V2</span></span><br><span class="line"></span><br><span class="line">再次更新软件包列表，以包含来自 Docker 官方源的软件包信息，然后执行安装：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 再次更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker 引擎, 命令行工具, containerd 和 Docker Compose V2 插件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="1-6-可选但推荐-配置非-root-用户运行-Docker">1.6 (可选但推荐) 配置非 root 用户运行 Docker</h4><p>每次都输入 <code>sudo</code> 来运行 Docker 命令很麻烦。我们可以将当前用户添加到 <code>docker</code> 用户组，从而免去 <code>sudo</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将您的用户（$USER 是一个环境变量，代表当前用户）添加到 docker 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong> 执行此命令后，您需要<strong>完全退出 SSH 会话并重新登录</strong>，才能使权限更改生效！</p><hr><h3 id="第二步：配置并部署-Shadowsocks-服务">第二步：配置并部署 Shadowsocks 服务</h3><p>环境准备好后，我们就可以开始定义和部署我们的 Shadowsocks 服务了。</p><h4 id="2-1-创建一个工作目录">2.1 创建一个工作目录</h4><p>为我们的项目创建一个专门的目录，这样可以保持整洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 ss 的目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/ss</span><br><span class="line"><span class="built_in">cd</span> ~/ss</span><br></pre></td></tr></table></figure><h4 id="2-2-编写-docker-compose-yml-配置文件">2.2 编写 <code>docker-compose.yml</code> 配置文件</h4><p>这是整个部署的核心。我们将创建一个名为 <code>docker-compose.yml</code> 的文件，它像一份蓝图，详细描述了我们的服务应该如何运行。</p><p>使用您喜欢的文本编辑器（这里以 <code>nano</code> 为例，它比 <code>vim</code> 更易上手）创建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>然后，将以下内容<strong>复制并粘贴</strong>到编辑器中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Compose 文件格式的版本 3</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义所有服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义一个名为 &quot;shadowsocks&quot; 的服务</span></span><br><span class="line">  <span class="attr">shadowsocks:</span></span><br><span class="line">    <span class="comment"># 指定要使用的 Docker 镜像，我们使用官方的 shadowsocks-libev</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shadowsocks/shadowsocks-libev</span></span><br><span class="line">    <span class="comment"># 给运行的容器起一个固定的名字，方便我们管理</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">shadowsocks</span></span><br><span class="line">    <span class="comment"># 设置端口映射 (格式: &quot;主机端口:容器端口&quot;)</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 将服务器的 TCP 8388 端口映射到容器的 TCP 8388 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/tcp&quot;</span></span><br><span class="line">      <span class="comment"># 将服务器的 UDP 8388 端口也映射出去 (用于游戏、视频通话等)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/udp&quot;</span></span><br><span class="line">    <span class="comment"># 设置容器的重启策略</span></span><br><span class="line">    <span class="comment"># unless-stopped: 除非我们手动停止容器，否则它总是在退出后自动重启</span></span><br><span class="line">    <span class="comment"># (包括服务器重启后，服务也会自动拉起，非常省心)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="comment"># 设置容器内的环境变量，用于配置 Shadowsocks</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 设置加密方法，chacha20-ietf-poly1305 是目前推荐的安全且高效的算法</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">METHOD=chacha20-ietf-poly1305</span></span><br><span class="line">      <span class="comment"># 在这里设置您的连接密码！请务必替换成一个您自己的强密码！</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PASSWORD=YOUR_STRONG_PASSWORD_HERE</span></span><br></pre></td></tr></table></figure><p><strong>重要配置修改：</strong></p><ul><li><strong><code>PASSWORD</code></strong>: 将 <code>YOUR_STRONG_PASSWORD_HERE</code> <strong>替换为您自己设定的一个强密码</strong>。这是您的客户端连接时需要用到的凭证。</li><li><strong><code>ports</code></strong>: 如果您服务器的 <code>8388</code> 端口已被其他服务占用，您可以修改主机端口。例如，改成 <code>&quot;10086:8388/tcp&quot;</code>，这样您的客户端就需要连接服务器的 <code>10086</code> 端口。</li></ul><p>修改完成后，在 <code>nano</code> 编辑器中，按 <code>Ctrl + X</code>，然后按 <code>Y</code>，最后按 <code>Enter</code> 保存并退出。</p><h4 id="2-3-启动-Shadowsocks-服务">2.3 启动 Shadowsocks 服务</h4><p>现在，激动人心的时刻到了！在 <code>docker-compose.yml</code> 文件所在的目录（即 <code>~/ss</code>），运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：如果您在 1.6 步中配置了用户组，这里就不需要 sudo 了</span></span><br><span class="line"><span class="comment"># 新版命令 (推荐)</span></span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版命令 (也能工作)</span></span><br><span class="line"><span class="comment"># docker-compose up -d</span></span><br></pre></td></tr></table></figure><ul><li><code>up</code>: 告诉 Docker Compose 启动并运行服务。</li><li><code>-d</code>: (<code>--detach</code>) 参数表示在后台运行服务。这是必须的，否则当您关闭 SSH 窗口时，服务也会停止。</li></ul><p>Docker Compose 现在会自动：</p><ol><li>检查 <code>docker-compose.yml</code> 文件。</li><li>从 Docker Hub 上拉取 <code>shadowsocks/shadowsocks-libev</code> 镜像（如果是第一次运行）。</li><li>根据您的配置创建并启动一个名为 <code>shadowsocks</code> 的容器。</li></ol><hr><h3 id="第三步：验证服务与客户端配置">第三步：验证服务与客户端配置</h3><blockquote><p>服务启动后，我们需要确认它是否正常运行，并配置客户端进行连接。</p></blockquote><h4 id="3-1-检查容器运行状态">3.1 检查容器运行状态</h4><p>运行以下命令查看当前正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>您应该能看到类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS         PORTS                                                 NAMES</span><br><span class="line">a1b2c3d4e5f6   shadowsocks/shadowsocks-libev   &quot;/usr/bin/ss-server …&quot;   30 seconds ago   Up 29 seconds   0.0.0.0:8388-&gt;8388/tcp, 0.0.0.0:8388-&gt;8388/udp   shadowsocks</span><br></pre></td></tr></table></figure><p>请关注以下几点：</p><ul><li><strong><code>IMAGE</code></strong>: 确认是 <code>shadowsocks/shadowsocks-libev</code>。</li><li><strong><code>STATUS</code></strong>: 必须是 <code>Up ...</code>，表示正在健康运行。如果是 <code>Exited</code>，说明启动失败。</li><li><strong><code>PORTS</code></strong>: 确认端口映射正确。</li><li><strong><code>NAMES</code></strong>: 确认是 <code>shadowsocks</code>。</li></ul><h4 id="3-2-查看服务日志">3.2 查看服务日志</h4><p>如果容器启动失败，或者您想确认服务的内部运行情况，查看日志是最佳方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs shadowsocks</span><br></pre></td></tr></table></figure><p>成功的日志会显示服务正在监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO: initializing ciphers... chacha20-ietf-poly1305</span><br><span class="line">INFO: listening at 0.0.0.0:8388</span><br></pre></td></tr></table></figure><h4 id="3-3-配置您的客户端">3.3 配置您的客户端</h4><p>现在，您可以在您的电脑或手机上配置 Shadowsocks 客户端了。填入以下信息：</p><ul><li><strong>服务器地址 (Server Address)</strong>: <code>您服务器的公网 IP 地址</code></li><li><strong>服务器端口 (Server Port)</strong>: <code>8388</code> (或者您在 <code>docker-compose.yml</code> 中设置的主机端口)</li><li><strong>密码 (Password)</strong>: <code>您在 docker-compose.yml 中设置的密码</code></li><li><strong>加密方法 (Encryption/Method)</strong>: <code>chacha20-ietf-poly1305</code></li></ul><p>保存配置并连接，现在您应该可以正常使用了！</p><hr><h3 id="第四步：常用管理命令">第四步：常用管理命令</h3><ul><li><strong>停止服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure></li><li><strong>重启服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose restart</span><br></pre></td></tr></table></figure></li><li><strong>更新服务 (例如更新 Shadowsocks 镜像)</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line"><span class="comment"># 1. 拉取最新的镜像</span></span><br><span class="line">docker compose pull</span><br><span class="line"><span class="comment"># 2. 重新创建并启动容器</span></span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure></li></ul><h2 id="客户端">客户端</h2><ul><li>windows</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-windows</span><br></pre></td></tr></table></figure><ul><li>android</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-android</span><br></pre></td></tr></table></figure><h2 id="代理模式">代理模式</h2><ul><li><p>禁用 (Disabled)：不使用代理。等同于取消勾选“启用系统代理”。</p></li><li><p>PAC 模式 (PAC)：推荐日常使用。此模式下，客户端会根据一个名为 PAC (Proxy Auto-Config) 的规则列表来判断。</p></li><li><p>全局模式 (Global)：所有网络流量都强制通过代理服务器。</p></li></ul><h2 id="See">See</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-rust">https://github.com/shadowsocks/shadowsocks-rust</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows">https://github.com/shadowsocks/shadowsocks-windows</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础环境&quot;&gt;基础环境&lt;/h2&gt;
&lt;h4 id=&quot;1-1-更新系统软件包列表&quot;&gt;1.1 更新系统软件包列表&lt;/h4&gt;
&lt;p&gt;首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PyAV用于视频剪辑处理</title>
    <link href="https://caozhaoqi.github.io/2025/08/14/pyav-use-video/"/>
    <id>https://caozhaoqi.github.io/2025/08/14/pyav-use-video/</id>
    <published>2025-08-14T10:54:52.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h1>PyAV用于视频剪辑处理</h1><blockquote><p>PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：</p></blockquote><ul><li><strong>内存操作</strong>：直接在内存中处理视频帧和音频样本，无需创建大量临时文件。</li><li><strong>精细控制</strong>：你可以完全控制容器的解复用、数据包的解码、帧的处理和编码的每一个环节。</li><li><strong>硬件加速</strong>：可以利用GPU（如macOS的VideoToolbox, Linux/Windows的CUDA/NVENC）来极大地加速解码和编码过程。</li><li><strong>高度集成</strong>：可以无缝地将视频帧与NumPy、Pillow等流行的Python库结合使用。</li></ul><h3 id="PyAV的核心概念">PyAV的核心概念</h3><blockquote><p>在深入代码之前，我们先了解几个核心概念，它们直接映射自FFmpeg：</p></blockquote><ol><li><strong>容器 (Container)</strong>: 指的是视频文件本身，比如一个<code>.mp4</code>或<code>.mkv</code>文件。它是一个“容器”，里面装着各种数据流。</li><li><strong>流 (Stream)</strong>: 指的是容器内的数据轨道。一个视频文件通常至少包含一个视频流和一个音频流，有时还会有字幕流。</li><li><strong>数据包 (Packet)</strong>: 从流中读取的一小块<strong>压缩后</strong>的数据。</li><li><strong>帧 (Frame)</strong>: 一个数据包经过<strong>解码后</strong>得到的数据。对于视频流，它是一张图片；对于音频流，它是一段声音样本。</li></ol><blockquote><p>标准的处理流程是：<strong>打开容器 → 找到需要的流 → 从流中解复用(demux)数据包 → 解码(decode)数据包得到帧 → (处理帧) → 编码(encode)处理后的帧变回数据包 → 将数据包混合(mux)到新的输出容器 → 关闭容器</strong>。</p></blockquote><h2 id="简单安装">简单安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install av</span><br><span class="line">conda install av -c conda-forge</span><br></pre></td></tr></table></figure><h3 id="功能">功能</h3><ul><li><p>libavformat: containers, audio/video/subtitle streams, packets;</p></li><li><p>libavdevice (by specifying a format to containers);</p></li><li><p>libavcodec: Codec, CodecContext, BitStreamFilterContext, audio/video frames, data planes, subtitles;</p></li><li><p>libavfilter: Filter, Graph;</p></li><li><p>libswscale: VideoReformatter;</p></li><li><p>libswresample: AudioResampler;</p></li></ul><h3 id="simple-demo">simple demo</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> av</span><br><span class="line"></span><br><span class="line">av.logging.set_level(av.logging.VERBOSE)</span><br><span class="line">container = av.<span class="built_in">open</span>(path_to_video)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, frame <span class="keyword">in</span> <span class="built_in">enumerate</span>(container.decode(video=<span class="number">0</span>)):</span><br><span class="line">    frame.to_image().save(<span class="string">f&quot;frame-<span class="subst">&#123;index:04d&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 调度器函数 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params">input_video_path, output_video_path, ...</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查硬件加速是否受支持</span></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速</span></span><br><span class="line">            logger.info(<span class="string">&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(...)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                <span class="comment"># 如果硬件路径明确返回失败，则降级</span></span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(...)</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 如果硬件路径意外崩溃，则降级</span></span><br><span class="line">            logger.error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(...)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(...)</span><br></pre></td></tr></table></figure><p>接下来，我们将深入分析这两种核心实现。</p><h3 id="Part-1-健壮的基石-——-纯软件-CPU-实现">Part 1: 健壮的基石 —— 纯软件 (CPU) 实现</h3><p>这是我们后备方案的核心，也是理解PyAV基础操作的最佳入口。它不依赖任何特殊的硬件，可以在任何平台上运行。</p><h4 id="核心步骤">核心步骤</h4><ol><li><p><strong>参数准备</strong>:<br>最关键的一步是确保输出的分辨率永远是偶数。像 <code>libx264</code> 这样的H.264编码器无法处理宽度或高度为奇数的视频。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final_w = w - (w % <span class="number">2</span>)</span><br><span class="line">final_h = h - (h % <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>打开输入/输出容器</strong>:<br>使用 <code>av.open()</code>，就像Python内置的 <code>open()</code> 一样简单，但它可以同时用于读和写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">    <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建输出流</strong>:<br>最简单的方式是从输入流创建模板。这会自动复制编解码器、码率等大部分参数。然后我们再手动覆盖需要修改的参数，比如新的宽度和高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有输入流</span></span><br><span class="line">in_video_stream = in_container.streams.video[<span class="number">0</span>]</span><br><span class="line">in_audio_stream = in_container.streams.audio[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从模板创建输出流</span></span><br><span class="line">out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">out_audio_stream = out_container.add_stream_from_template(in_audio_stream)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖视频流的尺寸</span></span><br><span class="line">out_video_stream.width = final_w</span><br><span class="line">out_video_stream.height = final_h</span><br></pre></td></tr></table></figure></li><li><p><strong>核心处理循环</strong>:<br>这是最精彩的部分，完美体现了PyAV与Pillow的结合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">            <span class="comment"># a. 解码帧并转换为Pillow Image对象</span></span><br><span class="line">            img = frame.to_image()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># b. 使用Pillow的强大功能进行图像处理</span></span><br><span class="line">            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line">            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># c. 将处理后的Pillow Image转换回PyAV的VideoFrame</span></span><br><span class="line">            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># d. 编码新帧并混合到输出文件</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">        <span class="comment"># 音频直通：不解码，直接复制数据包，效率最高</span></span><br><span class="line">        packet.stream = out_audio_stream</span><br><span class="line">        out_container.mux(packet)</span><br></pre></td></tr></table></figure></li><li><p><strong>冲洗 (Flush) 编码器</strong>:<br>处理完所有帧后，编码器的内部可能还缓存着一些数据。我们通过发送一个 <code>None</code> 来告诉它结束编码，并清空所有缓冲区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">    out_container.mux(out_packet)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Part-2-极致性能-——-Metal硬件加速-GPU-实现">Part 2: 极致性能 —— Metal硬件加速 (GPU) 实现</h3><p>这是脚本的“高性能模式”，专门为macOS设计。它尽可能地将所有操作都留在GPU上，避免了昂贵的CPU&lt;-&gt;GPU数据拷贝。</p><h4 id="核心步骤-2">核心步骤</h4><ol><li><p><strong>创建硬件设备上下文</strong>:<br>这是开启硬件加速的第一步，我们告诉PyAV我们要使用苹果的 <code>videotoolbox</code> 框架。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>配置硬件解码</strong>:<br>这是现代PyAV中配置硬件解码的关键。我们不是手动设置上下文，而是为输入流的 <code>codec_context</code> 提供一个 <code>get_format</code> 回调函数。当解码器准备好时，它会调用这个函数并提供一个它支持的像素格式列表。我们的函数只需从中选择 <code>'videotoolbox'</code> 格式即可。这告诉解码器：“请直接将帧解码到GPU显存中，不要下载到CPU内存。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">    <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">        <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">            <span class="keyword">return</span> fmt</span><br><span class="line">    <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">&quot;未找到 &#x27;videotoolbox&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">in_stream.codec_context.get_format = get_hw_format</span><br></pre></td></tr></table></figure></li><li><p><strong>构建硬件滤镜图 (Filter Graph)</strong>:<br>裁剪和缩放是通过FFmpeg的滤镜系统完成的。PyAV允许我们用代码构建这个处理链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">buffer_src = graph.add_buffer(template=in_stream) <span class="comment"># 输入源</span></span><br><span class="line">buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>) <span class="comment"># 输出汇</span></span><br><span class="line"></span><br><span class="line">filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;...&#125;</span>,scale=<span class="subst">&#123;...&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：源 -&gt; 滤镜链 -&gt; 汇</span></span><br><span class="line">filters = graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>)</span><br><span class="line">buffer_src.link_to(filters)</span><br><span class="line">filters.link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">graph.configure()</span><br></pre></td></tr></table></figure><p>这里最巧妙的是，即使 <code>crop</code> 和 <code>scale</code> 滤镜是纯CPU操作，FFmpeg也会在后台<strong>自动</strong>处理硬件帧的下载（GPU-&gt;CPU）、应用滤镜、再上传（CPU-&gt;GPU）的过程。</p></li><li><p><strong>配置硬件编码</strong>:<br>我们创建一个使用 <code>h264_videotoolbox</code> 编码器的输出流。它会自动接收来自滤镜图的、已经处理好的帧（这些帧可能在CPU上，也可能在GPU上，编码器会自动处理）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out_stream = out_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">out_stream.width = final_w</span><br><span class="line">out_stream.height = final_h</span><br><span class="line">out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span> <span class="comment"># VideoToolbox 编码器偏好的像素格式</span></span><br></pre></td></tr></table></figure></li><li><p><strong>硬件处理循环</strong>:<br>循环的主体结构类似，但操作对象变成了滤镜图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode(): <span class="comment"># 解码出的 frame 是一个指向GPU显存的硬件帧</span></span><br><span class="line">    graph.push(frame) <span class="comment"># 将硬件帧推入滤镜图处理</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            filtered_frame = buffer_sink.pull() <span class="comment"># 从滤镜图拉取处理好的帧</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                output_container.mux(out_packet)</span><br><span class="line">        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实际处理">实际处理</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 检查当前 PyAV 环境是否支持硬件加速</span></span><br><span class="line">HW_ACCEL_SUPPORTED = <span class="built_in">hasattr</span>(av, <span class="string">&#x27;hwdevice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">    <span class="comment"># 进一步检查平台是否为 macOS</span></span><br><span class="line">    <span class="keyword">if</span> platform.system() == <span class="string">&#x27;Darwin&#x27;</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;硬件加速 (VideoToolbox) 可用。将优先使用 Metal 路径。&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        HW_ACCEL_SUPPORTED = <span class="literal">False</span></span><br><span class="line">        logger.warning(<span class="string">&quot;PyAV 支持硬件加速，但当前系统不是 macOS。VideoToolbox 不可用。&quot;</span>)</span><br><span class="line">        logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.warning(<span class="string">&quot;当前 PyAV 环境中未找到硬件加速模块 (&#x27;av.hwdevice&#x27;)。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式，速度会较慢。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;要解决此问题，请确保您的项目解释器配置正确，并使用了完整编译的 PyAV 库。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 主调度器函数 ---</span></span><br><span class="line"><span class="comment"># 您的外部代码应该只调用这个函数</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_x: <span class="built_in">float</span>, crop_y: <span class="built_in">float</span>, crop_w: <span class="built_in">float</span>, crop_h: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        log_queue=<span class="literal">None</span>,  <span class="comment"># log_queue 和其他参数保留以兼容您的接口</span></span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        assigned_gpu_id: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs  <span class="comment"># 捕获任何其他未使用的参数</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果支持硬件加速，则尝试使用Metal路径；否则，或Metal路径失败时，</span></span><br><span class="line"><span class="string">    自动回退到纯软件路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    crop_params = &#123;</span><br><span class="line">        <span class="string">&#x27;x&#x27;</span>: crop_x, <span class="string">&#x27;y&#x27;</span>: crop_y, <span class="string">&#x27;w&#x27;</span>: crop_w, <span class="string">&#x27;h&#x27;</span>: crop_h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速路径</span></span><br><span class="line">            logger.info(<span class="string">f&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(</span><br><span class="line">                    input_video_path, output_video_path, crop_params,</span><br><span class="line">                    min_short_side_output_px</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果一开始就不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">f&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">            input_video_path, output_video_path, crop_params,</span><br><span class="line">            min_short_side_output_px</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 硬件加速实现 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_pyav_metal</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 PyAV 和 VideoToolbox (Metal) 进行硬件加速的视频裁剪。</span></span><br><span class="line"><span class="string">    这是一个内部函数，假设硬件支持已确认。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Metal路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数准备</span></span><br><span class="line">    crop_w_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_h_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_x_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_y_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> crop_w_f &lt;= <span class="number">0</span> <span class="keyword">or</span> crop_h_f &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    final_w, final_h = crop_w_f, crop_h_f</span><br><span class="line">    needs_scaling = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(crop_w_f, crop_h_f) &lt; min_short_side_output_px:</span><br><span class="line">        needs_scaling = <span class="literal">True</span></span><br><span class="line">        scale_factor = min_short_side_output_px / <span class="built_in">min</span>(crop_w_f, crop_h_f)</span><br><span class="line">        final_w = math.ceil((crop_w_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">        final_h = math.ceil((crop_h_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 硬件设备与容器 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 创建 VideoToolbox 上下文。&quot;</span>)</span><br><span class="line">        hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br><span class="line"></span><br><span class="line">        input_container = av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        output_container = av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        in_stream = input_container.streams.video[<span class="number">0</span>]</span><br><span class="line">        in_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件解码 (现代方式) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件解码。&quot;</span>)</span><br><span class="line">        hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">            <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">                <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">                    <span class="keyword">return</span> fmt</span><br><span class="line">            <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">f&quot;未找到 &#x27;<span class="subst">&#123;hw_pix_fmt&#125;</span>&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        in_stream.codec_context.get_format = get_hw_format</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置滤镜图 ---</span></span><br><span class="line">        <span class="comment"># FFmpeg 会在后台自动插入 hwupload/hwdownload 滤镜</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置滤镜图。&quot;</span>)</span><br><span class="line">        graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">        buffer_src = graph.add_buffer(template=in_stream)</span><br><span class="line"></span><br><span class="line">        filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;crop_w_f&#125;</span>:<span class="subst">&#123;crop_h_f&#125;</span>:<span class="subst">&#123;crop_x_f&#125;</span>:<span class="subst">&#123;crop_y_f&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> needs_scaling:</span><br><span class="line">            filter_chain += <span class="string">f&quot;,scale=<span class="subst">&#123;final_w&#125;</span>:<span class="subst">&#123;final_h&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滤镜图的终点是 buffer_sink</span></span><br><span class="line">        buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接滤镜</span></span><br><span class="line">        buffer_src.link_to(graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>))</span><br><span class="line">        graph.get_filter(<span class="string">&quot;filters&quot;</span>).link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">        graph.configure()</span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 滤镜图配置成功: &#x27;<span class="subst">&#123;filter_chain&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件编码 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件编码。&quot;</span>)</span><br><span class="line">        rate = in_stream.base_rate <span class="keyword">or</span> in_stream.guessed_rate <span class="keyword">or</span> in_stream.average_rate</span><br><span class="line">        out_stream = output_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">        out_stream.width = final_w</span><br><span class="line">        out_stream.height = final_h</span><br><span class="line">        out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span>  <span class="comment"># VideoToolbox 编码器通常使用 nv12</span></span><br><span class="line">        out_stream.time_base = in_stream.time_base</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 音频流处理 (直通) ---</span></span><br><span class="line">        in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> input_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> in_audio_stream:</span><br><span class="line">            out_audio_stream = output_container.add_stream(<span class="string">&#x27;aac&#x27;</span>, template=in_audio_stream)</span><br><span class="line">            streams_to_demux = (in_stream, in_audio_stream)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out_audio_stream = <span class="literal">None</span></span><br><span class="line">            streams_to_demux = in_stream</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 核心处理循环 ---</span></span><br><span class="line">        <span class="keyword">for</span> packet <span class="keyword">in</span> input_container.demux(streams_to_demux):</span><br><span class="line">            <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                    graph.push(frame)</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            filtered_frame = buffer_sink.pull()</span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                                output_container.mux(out_packet)</span><br><span class="line">                        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> out_audio_stream <span class="keyword">and</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">                packet.stream = out_audio_stream</span><br><span class="line">                output_container.mux(packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 冲洗(Flush) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 冲洗滤镜和编码器。&quot;</span>)</span><br><span class="line">        graph.push(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                filtered_frame = buffer_sink.pull()</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                    output_container.mux(out_packet)</span><br><span class="line">            <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(<span class="literal">None</span>):</span><br><span class="line">            output_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正常关闭</span></span><br><span class="line">        output_container.close()</span><br><span class="line">        input_container.close()</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;Metal路径处理时发生致命错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 清理</span></span><br><span class="line">        <span class="keyword">if</span> output_container:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 纯软件备用方案 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_software</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用纯软件 (CPU) 进行视频裁剪的备用方法。</span></span><br><span class="line"><span class="string">    这个方法总是可用的，但速度比硬件加速慢。</span></span><br><span class="line"><span class="string">    它确保输出尺寸为偶数，以兼容H.264等编码器。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;软件路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line">    success = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 1. 参数准备 (关键修正部分) ---</span></span><br><span class="line">        x, y, w, h = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> w &lt;= <span class="number">0</span> <span class="keyword">or</span> h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;裁剪尺寸无效 (w=<span class="subst">&#123;w&#125;</span>, h=<span class="subst">&#123;h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始的最终尺寸就是裁剪后的尺寸</span></span><br><span class="line">        final_w, final_h = w, h</span><br><span class="line">        needs_scaling = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否需要缩放</span></span><br><span class="line">        <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(w, h) &lt; min_short_side_output_px:</span><br><span class="line">            needs_scaling = <span class="literal">True</span></span><br><span class="line">            scale_factor = min_short_side_output_px / <span class="built_in">min</span>(w, h)</span><br><span class="line">            final_w = <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">            final_h = <span class="built_in">int</span>(h * scale_factor)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** 核心修正：确保最终的输出尺寸永远是偶数 ***</span></span><br><span class="line">        <span class="comment"># 这对于 H.264 (libx264) 和许多其他编码器至关重要</span></span><br><span class="line">        final_w = final_w - (final_w % <span class="number">2</span>)</span><br><span class="line">        final_h = final_h - (final_h % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> final_w &lt;= <span class="number">0</span> <span class="keyword">or</span> final_h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;计算后的输出尺寸无效 (<span class="subst">&#123;final_w&#125;</span>x<span class="subst">&#123;final_h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 2. 打开容器并设置流 ---</span></span><br><span class="line">        <span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">            <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># a. 查找所有输入流</span></span><br><span class="line">                in_video_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> in_video_stream:</span><br><span class="line">                    logger.error(<span class="string">&quot;输入文件中未找到视频流。&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                in_video_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">                in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                in_subtitle_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># b. 为每个输入流创建对应的输出流</span></span><br><span class="line">                out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">                out_video_stream.width = final_w</span><br><span class="line">                out_video_stream.height = final_h</span><br><span class="line"></span><br><span class="line">                out_audio_stream = out_container.add_stream_from_template(in_audio_stream) <span class="keyword">if</span> in_audio_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                out_subtitle_stream = out_container.add_stream_from_template(</span><br><span class="line">                    in_subtitle_stream) <span class="keyword">if</span> in_subtitle_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                streams_to_demux = [s <span class="keyword">for</span> s <span class="keyword">in</span> [in_video_stream, in_audio_stream, in_subtitle_stream] <span class="keyword">if</span> s]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 3. 核心处理循环 ---</span></span><br><span class="line">                <span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">                    <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                            img = frame.to_image()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 裁剪</span></span><br><span class="line">                            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 如果需要，进行缩放</span></span><br><span class="line">                            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                                <span class="comment"># Pillow 的 resize 需要一个 (width, height) 元组</span></span><br><span class="line">                                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line"></span><br><span class="line">                            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">                            new_frame.pts = frame.pts</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span> <span class="keyword">and</span> out_audio_stream:</span><br><span class="line">                        packet.stream = out_audio_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span> <span class="keyword">and</span> out_subtitle_stream:</span><br><span class="line">                        packet.stream = out_subtitle_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 4. 冲洗(Flush)视频编码器 ---</span></span><br><span class="line">                logger.debug(<span class="string">&quot;软件路径: 冲洗视频编码器。&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">                    out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        success = <span class="literal">True</span></span><br><span class="line">        logger.info(<span class="string">f&quot;软件路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;软件路径处理时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> output_container <span class="keyword">and</span> <span class="keyword">not</span> output_container.closed:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container <span class="keyword">and</span> <span class="keyword">not</span> input_container.closed:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> success <span class="keyword">and</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">                logger.info(<span class="string">f&quot;已清理失败的输出文件: <span class="subst">&#123;output_video_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">                logger.warning(<span class="string">f&quot;清理失败的输出文件时出错: <span class="subst">&#123;err&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="one-more-thing">one more thing</h2><ul><li>gpu acc</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU Acceleration Defaults</span></span><br><span class="line">GPU_ACCELERATION_DEFAULT = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;videotoolbox&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_videotoolbox&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GPU_ACCELERATION_DEFAULT_win = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;cuda&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_nvenc&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li>1.<a href="https://github.com/PyAV-Org/PyAV/tree/main/docs/api">https://github.com/PyAV-Org/PyAV/tree/main/docs/api</a></li><li>2.<a href="https://ffmpeg.org/documentation.html">https://ffmpeg.org/documentation.html</a></li><li>3.<a href="https://pyav.basswood-io.com/docs/stable/">https://pyav.basswood-io.com/docs/stable/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PyAV用于视频剪辑处理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数字水印系统实现</title>
    <link href="https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/"/>
    <id>https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/</id>
    <published>2025-07-22T10:25:23.000Z</published>
    <updated>2025-11-25T15:05:10.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现流程框架">实现流程框架</h2><p>无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：</p><ol><li><p><strong>水印嵌入 (Watermark Embedding)</strong>：</p><ul><li><strong>输入</strong>：原始载体（如图片A）、水印信息（如字符串&quot;ID:123&quot;或一个Logo图片B）。</li><li><strong>过程</strong>：通过特定算法，将水印信息B处理后，“叠加”或“融入”到原始载体A中。</li><li><strong>输出</strong>：一个带有水印、但看起来和原始载体几乎没区别的载体A’。</li></ul></li><li><p><strong>水印提取/检测 (Watermark Extraction/Detection)</strong>：</p><ul><li><strong>输入</strong>：可能被修改过的带水印载体A’'，有时还需要原始载体A或原始水印B作为参考。</li><li><strong>过程</strong>：通过与嵌入过程相逆的算法，从载体A’'中解码出隐藏的水印信息。</li><li><strong>输出</strong>：提取出的水印信息B’，或者一个“是/否”的判断（确认是否存在某个特定水印）。</li></ul></li></ol><blockquote><p>现在，我们来看实现这些流程的具体技术。</p></blockquote><hr><h3 id="一、-空域（Spatial-Domain）技术">一、 空域（Spatial Domain）技术</h3><p><strong>核心思想</strong>：直接修改原始图像的像素值（比如RGB值）来嵌入信息。这种方法直观、简单。</p><h4 id="典型技术：LSB-Least-Significant-Bit-算法">典型技术：LSB (Least Significant Bit) 算法</h4><p>这是最经典、最简单的空域水印技术。</p><ul><li><p><strong>原理</strong>：</p><ul><li>计算机中的图像，每个像素的颜色由若干个二进制位（bits）表示。例如，一个8位的灰度图像，每个像素的灰度值范围是0-255，由8个二进制位组成。</li><li><strong>最低有效位 (LSB)</strong> 就是这8个位中最右边的那一位。改变这一位，对像素值的整体影响最小（最多改变1），人眼基本无法察觉。</li><li><strong>嵌入方法</strong>：将要隐藏的水印信息（比如一张黑白Logo图片）转换成二进制流（0和1的序列）。然后，用这个二进制流去替换原始图像中每个（或部分）像素的LSB。<ul><li>如果要嵌入<code>1</code>，就把像素的LSB改成<code>1</code>。</li><li>如果要嵌入<code>0</code>，就把像素的LSB改成<code>0</code>。</li></ul></li></ul></li><li><p><strong>提取方法</strong>：直接读取带水印图像中相应像素的LSB，就能还原出隐藏的二进制流，从而重构水印信息。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：算法非常直接。</li><li><strong>容量大</strong>：每个像素都能藏1比特信息，可以隐藏大量数据。</li><li><strong>隐蔽性好</strong>：对视觉影响极小。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>鲁棒性极差（非常脆弱）</strong>：这是它的致命弱点。任何对图像的轻微处理，如 <strong>JPEG压缩、缩放、裁剪、加个滤镜</strong>，都会破坏LSB层的数据，导致水印完全丢失。</li></ul></li><li><p><strong>应用场景</strong>：主要用于<strong>脆弱水印</strong>，即<strong>内容完整性认证</strong>。因为只要图片被改动，水印就会被破坏，从而可以证明“此图已被修改”。</p></li></ul><hr><h3 id="二、-变换域（Transform-Domain）技术">二、 变换域（Transform Domain）技术</h3><p><strong>核心思想</strong>：不直接改像素值，而是先对图像进行数学变换（如傅里叶变换、余弦变换），将其从空域转换到另一个域（如频域）。然后，在变换后的域中修改系数来嵌入水印。这是目前主流的、<strong>鲁棒水印</strong>的实现方式。</p><p><strong>为什么要这么做？</strong><br>因为像JPEG压缩这样的操作，主要丢弃的是图像的<strong>高频信息</strong>（细节），而保留<strong>中低频信息</strong>（轮廓、主要能量）。如果在中低频系数里嵌入水印，那么即使经过压缩，水印信息也能大概率被保留下来。</p><h4 id="1-基于DCT（离散余弦变换）的技术">1. 基于DCT（离散余弦变换）的技术</h4><ul><li><strong>背景</strong>：DCT是 <strong>JPEG 压缩</strong>的核心算法。它将图像分成8x8的小块，然后对每个块进行DCT变换，得到一个频率系数矩阵。这个矩阵中，左上角是低频系数（能量集中），右下角是高频系数。</li><li><strong>嵌入方法</strong>：<ol><li>将原始图像分块（如8x8）。</li><li>对每个块进行DCT变换。</li><li>选择<strong>中频区域</strong>的系数进行修改。为什么是中频？因为低频系数对视觉影响太大，高频系数容易在压缩中丢失，中频是最佳平衡点。</li><li>根据水印信息（0或1）来修改这些中频系数。例如，通过量化或比较两个系数的大小来嵌入1比特信息。</li><li>对修改后的系数矩阵进行<strong>逆DCT变换</strong> (IDCT)，得到带水印的图像块。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>鲁棒性强</strong>：对JPEG压缩、轻微噪声、亮度调整等有很好的抵抗能力。</li><li><strong>隐蔽性好</strong>：利用了人类视觉系统对中频变化不敏感的特性。</li></ul></li><li><strong>应用场景</strong>：<strong>版权保护</strong>、<strong>盗版追踪</strong>等需要强鲁棒性的场合。</li></ul><h4 id="2-基于DWT（离散小波变换）的技术">2. 基于DWT（离散小波变换）的技术</h4><ul><li><strong>背景</strong>：DWT是 <strong>JPEG 2000</strong> 压缩标准的核心。与DCT不同，DWT能对整个图像进行多分辨率分析，得到不同尺度和方向的子带（低频、水平细节、垂直细节、对角线细节）。</li><li><strong>嵌入方法</strong>：<ol><li>对整个图像进行DWT变换。</li><li>水印通常被嵌入到<strong>中、低频子带</strong>的系数中。</li><li>因为DWT提供了图像的空间和频率局部化信息，所以它对裁剪、缩放等几何攻击的抵抗性更好。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>多分辨率特性</strong>：鲁棒性比DCT更全面，尤其在抗几何攻击方面。</li><li><strong>与人类视觉系统（HVS）匹配更好</strong>：可以更精细地控制水印的嵌入强度，达到更好的隐蔽性。</li></ul></li><li><strong>应用场景</strong>：同DCT，用于需要更高鲁棒性的版权保护系统。</li></ul><h4 id="3-基于DFT（离散傅里叶变换）的技术">3. 基于DFT（离散傅里叶变换）的技术</h4><ul><li><strong>背景</strong>：DFT将图像转换成幅度和相位谱。</li><li><strong>特点</strong>：图像的幅度谱对<strong>旋转、缩放和平移（RST攻击）</strong> 具有不变性或特定的变化规律。</li><li><strong>嵌入方法</strong>：通过修改DFT变换后的<strong>幅度谱</strong>来嵌入水印。</li><li><strong>优点</strong>：<ul><li>对旋转、缩放等几何攻击具有天然的鲁棒性。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，且容易出现图像块效应。</li></ul></li><li><strong>应用场景</strong>：主要用于抵抗几何变换的特定场合。</li></ul><hr><h2 id="实现">实现</h2><h3 id="核心的Python库：">核心的Python库：</h3><ul><li><strong>Pillow (PIL Fork)</strong>: 用于图像的读写和基本的像素操作（实现LSB）。</li><li><strong>NumPy</strong>: 用于高效的数组和矩阵运算，是所有图像处理的基础。</li><li><strong>PyWavelets (pywt)</strong>: 用于实现DWT（离散小波变换）。</li><li><strong>OpenCV-Python (cv2)</strong>: 功能最强大的计算机视觉库，可以方便地实现DCT、DFT以及各种图像处理操作。</li></ul><hr><h3 id="1-空域-Spatial-Domain-LSB-算法">1. 空域 (Spatial Domain) - LSB 算法</h3><p><strong>核心库</strong>: <code>Pillow</code> (PIL), <code>NumPy</code></p><p>这个算法不依赖复杂的数学库，Pillow和NumPy足以胜任。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">image_path, secret_message</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将秘密信息嵌入到图片的LSB层&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    width, height = img.size</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 将秘密信息转换为二进制流</span></span><br><span class="line">    binary_secret = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">format</span>(<span class="built_in">ord</span>(c), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> secret_message])</span><br><span class="line">    binary_secret += <span class="string">&#x27;1111111111111110&#x27;</span> <span class="comment"># 添加结束标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_secret) &gt; width * height * <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;信息过长，无法嵌入到图片中！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data_index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 2. 遍历像素并修改LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="comment"># 遍历RGB三个通道</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> data_index &lt; <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                    <span class="comment"># 清除LSB并设置新的位</span></span><br><span class="line">                    pixel[i] = (pixel[i] &amp; <span class="number">0xFE</span>) | <span class="built_in">int</span>(binary_secret[data_index])</span><br><span class="line">                    data_index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建并保存新图片</span></span><br><span class="line">    encoded_image = Image.fromarray(img_array)</span><br><span class="line">    encoded_image.save(<span class="string">&quot;encoded_image.png&quot;</span>, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信息嵌入成功，已保存为 encoded_image.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从图片的LSB层提取秘密信息&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line">    width, height = img.size</span><br><span class="line"></span><br><span class="line">    binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 遍历像素并提取LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                binary_data += <span class="built_in">str</span>(pixel[i] &amp; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 找到结束标记并转换信息</span></span><br><span class="line">    end_marker = <span class="string">&#x27;1111111111111110&#x27;</span></span><br><span class="line">    end_index = binary_data.find(end_marker)</span><br><span class="line">    <span class="keyword">if</span> end_index != -<span class="number">1</span>:</span><br><span class="line">        secret_binary = binary_data[:end_index]</span><br><span class="line">        secret_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(secret_binary), <span class="number">8</span>):</span><br><span class="line">            byte = secret_binary[i:i+<span class="number">8</span>]</span><br><span class="line">            secret_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> secret_message</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;未找到结束标记或信息。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备一张名为 &#x27;original.png&#x27; 的图片</span></span><br><span class="line"><span class="comment"># encode_lsb(&#x27;original.png&#x27;, &quot;This is a secret message!&quot;)</span></span><br><span class="line"><span class="comment"># message = decode_lsb(&#x27;encoded_image.png&#x27;)</span></span><br><span class="line"><span class="comment"># print(f&quot;提取到的信息: &#123;message&#125;&quot;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-变换域-Transform-Domain-DCT-算法">2. 变换域 (Transform Domain) - DCT 算法</h3><p><strong>核心库</strong>: <code>OpenCV-Python (cv2)</code>, <code>NumPy</code></p><p>OpenCV 提供了非常方便的 <code>cv2.dct()</code> 和 <code>cv2.idct()</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DCT的中频带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保水印尺寸小于载体</span></span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DCT变换</span></span><br><span class="line">    img_dct = cv2.dct(np.float32(img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 对水印图像进行DCT变换 (也可以直接用二值化水印)</span></span><br><span class="line">    watermark_dct = cv2.dct(np.float32(watermark))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将水印的DCT系数加到载体的中频DCT系数上</span></span><br><span class="line">    <span class="comment"># 这里简单地将整个水印DCT加到载体DCT上，更复杂的会选择特定区域</span></span><br><span class="line">    <span class="comment"># alpha 是嵌入强度</span></span><br><span class="line">    result_dct = img_dct + alpha * watermark_dct</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 进行逆DCT变换</span></span><br><span class="line">    result_img = cv2.idct(result_dct)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 裁剪值到 0-255 并转换为uint8</span></span><br><span class="line">    result_img = np.clip(result_img, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_embedded_image.png&#x27;</span>, result_img)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DCT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 这是一个非盲水印提取的例子</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对带水印图像和原始图像分别做DCT</span></span><br><span class="line">    embedded_dct = cv2.dct(np.float32(embedded_img))</span><br><span class="line">    original_dct = cv2.dct(np.float32(original_img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 相减并除以强度因子，得到水印的DCT系数</span></span><br><span class="line">    extracted_watermark_dct = (embedded_dct - original_dct) / alpha</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 逆DCT变换，恢复水印</span></span><br><span class="line">    extracted_watermark = cv2.idct(extracted_watermark_dct)</span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dct_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.1)</span></span><br><span class="line"><span class="comment"># dct_watermark_extract(&#x27;dct_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.1)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 上述DCT示例是一个<strong>非盲水印</strong>，提取时需要原始图像。实现盲水印（无需原图）会更复杂，通常涉及在中频带选择特定的系数对进行比较，而不是直接叠加。</p><hr><h3 id="3-变换域-Transform-Domain-DWT-算法">3. 变换域 (Transform Domain) - DWT 算法</h3><p><strong>核心库</strong>: <code>PyWavelets (pywt)</code>, <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p><code>pywt</code> 是Python中进行小波变换的标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DWT的LL子带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DWT变换</span></span><br><span class="line">    <span class="comment"># &#x27;haar&#x27; 是最简单的小波基</span></span><br><span class="line">    coeffs_img = pywt.dwt2(img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL, (LH, HL, HH) = coeffs_img</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保水印尺寸与LL子带匹配</span></span><br><span class="line">    watermark_resized = cv2.resize(watermark, (LL.shape[<span class="number">1</span>], LL.shape[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 将水印添加到低频子带 (LL)</span></span><br><span class="line">    <span class="comment"># LL子带能量最集中，鲁棒性最强，但对画质影响也最大</span></span><br><span class="line">    LL_watermarked = LL + alpha * watermark_resized</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 重构图像</span></span><br><span class="line">    coeffs_watermarked = (LL_watermarked, (LH, HL, HH))</span><br><span class="line">    img_watermarked = pywt.idwt2(coeffs_watermarked, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    img_watermarked = np.clip(img_watermarked, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_embedded_image.png&#x27;</span>, img_watermarked)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DWT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 同样是非盲水印提取</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对两张图分别做DWT</span></span><br><span class="line">    coeffs_embedded = pywt.dwt2(embedded_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_embedded, _ = coeffs_embedded</span><br><span class="line">    </span><br><span class="line">    coeffs_original = pywt.dwt2(original_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_original, _ = coeffs_original</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 提取水印</span></span><br><span class="line">    extracted_watermark = (LL_embedded - LL_original) / alpha</span><br><span class="line">    </span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dwt_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.2)</span></span><br><span class="line"><span class="comment"># dwt_watermark_extract(&#x27;dwt_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.2)</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-变换域-Transform-Domain-DFT-算法">4. 变换域 (Transform Domain) - DFT 算法</h3><p><strong>核心库</strong>: <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p>DFT的实现与DCT类似，但通常用于抵抗几何攻击。这里提供一个基础的嵌入思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dft_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DFT幅度谱嵌入水印&quot;&quot;&quot;</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. DFT变换</span></span><br><span class="line">    <span class="comment"># OpenCV的dft需要输入float32，并会输出双通道复数结果</span></span><br><span class="line">    dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 将频谱中心移到图像中央，便于观察和操作</span></span><br><span class="line">    dft_shift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算幅度和相位谱</span></span><br><span class="line">    magnitude_spectrum = cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line">    phase_spectrum = cv2.phase(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 在幅度谱上添加水印</span></span><br><span class="line">    magnitude_spectrum_watermarked = magnitude_spectrum + alpha * watermark</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 根据新的幅度和旧的相位，重构DFT结果</span></span><br><span class="line">    real_part = magnitude_spectrum_watermarked * np.cos(phase_spectrum)</span><br><span class="line">    imag_part = magnitude_spectrum_watermarked * np.sin(phase_spectrum)</span><br><span class="line">    dft_shift_watermarked = cv2.merge([real_part, imag_part])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 将频谱中心移回左上角</span></span><br><span class="line">    dft_watermarked = np.fft.ifftshift(dft_shift_watermarked)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 逆DFT变换</span></span><br><span class="line">    img_back = cv2.idft(dft_watermarked)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取实部并恢复图像</span></span><br><span class="line">    img_back = cv2.magnitude(img_back[:,:,<span class="number">0</span>], img_back[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    img_back = np.clip(img_back, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dft_embedded_image.png&#x27;</span>, img_back)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DFT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dft_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=100)</span></span><br><span class="line"><span class="comment"># 提取DFT水印通常也需要原始图像，过程与DCT/DWT类似。</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖库">安装依赖库</h3><ul><li>pip安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow numpy opencv-python pywavelets</span><br></pre></td></tr></table></figure><h2 id="demo">demo</h2><h3 id="水印信息嵌入（LSB）">水印信息嵌入（LSB）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_message_to_binary</span>(<span class="params">message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a string message into its binary representation.&quot;&quot;&quot;</span></span><br><span class="line">    binary_message = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">format</span>(<span class="built_in">ord</span>(char), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> char <span class="keyword">in</span> message)</span><br><span class="line">    <span class="keyword">return</span> binary_message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_binary_to_message</span>(<span class="params">binary_message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a binary string back into a string message.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Ensure the binary string is a multiple of 8</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_message) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        logger.warning(<span class="string">&quot;Binary string length is not a multiple of 8; data may be incomplete.&quot;</span>)</span><br><span class="line">        binary_message = binary_message[:-(<span class="built_in">len</span>(binary_message) % <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    message = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_message), <span class="number">8</span>):</span><br><span class="line">        byte = binary_message[i:i + <span class="number">8</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte) == <span class="number">8</span>:</span><br><span class="line">            message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encodes a secret message into an image using the LSB (Least Significant Bit) technique.</span></span><br><span class="line"><span class="string">    The output image will be saved in a lossless format (PNG) to preserve the watermark.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path (str): The path to the source image.</span></span><br><span class="line"><span class="string">        secret_message (str): The message to hide.</span></span><br><span class="line"><span class="string">        output_image_path (str): The path to save the watermarked image.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB encoding for &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path, <span class="string">&#x27;r&#x27;</span>).convert(<span class="string">&quot;RGBA&quot;</span>) <span class="comment"># Convert to RGBA for consistency</span></span><br><span class="line">        width, height = image.size</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        channels = <span class="number">4</span>  <span class="comment"># We are using RGBA</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add a unique delimiter to know where the message ends</span></span><br><span class="line">        binary_secret_message = _message_to_binary(secret_message + <span class="string">&quot;####&quot;</span>)</span><br><span class="line">        required_pixels = <span class="built_in">len</span>(binary_secret_message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> required_pixels &gt; width * height * channels:</span><br><span class="line">            logger.error(<span class="string">&quot;Error: Message is too long to be encoded in this image.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Modify the LSB of the pixel data</span></span><br><span class="line">        data_index = <span class="number">0</span></span><br><span class="line">        flat_array = img_array.flatten()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flat_array)):</span><br><span class="line">            <span class="keyword">if</span> data_index &lt; required_pixels:</span><br><span class="line">                <span class="comment"># Change the LSB of the color value</span></span><br><span class="line">                flat_array[i] = <span class="built_in">int</span>(<span class="built_in">bin</span>(flat_array[i])[<span class="number">2</span>:-<span class="number">1</span>] + binary_secret_message[data_index], <span class="number">2</span>)</span><br><span class="line">                data_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># Stop once the message is encoded</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a new image with the modified pixel data</span></span><br><span class="line">        encoded_image = Image.fromarray(flat_array.reshape(height, width, channels).astype(<span class="string">&#x27;uint8&#x27;</span>), image.mode)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save as PNG to ensure lossless storage of the watermark</span></span><br><span class="line">        encoded_image.save(output_image_path, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;Successfully encoded message into &#x27;<span class="subst">&#123;output_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Input image not found at &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during encoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decodes a secret message from an image using the LSB technique.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path (str): The path to the watermarked image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        The decoded secret message, or None if an error occurs or no message is found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB decoding for &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pixel <span class="keyword">in</span> img_array:</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> pixel:</span><br><span class="line">                binary_data += <span class="built_in">bin</span>(value)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find the delimiter by decoding byte by byte</span></span><br><span class="line">        decoded_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_data), <span class="number">8</span>):</span><br><span class="line">            byte = binary_data[i:i+<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(byte) &lt; <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># End of data</span></span><br><span class="line">            decoded_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> decoded_message.endswith(<span class="string">&quot;####&quot;</span>):</span><br><span class="line">                logger.info(<span class="string">&quot;Successfully decoded the message.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message[:-<span class="number">4</span>]  <span class="comment"># Return message without the delimiter</span></span><br><span class="line"></span><br><span class="line">        logger.warning(<span class="string">&quot;Could not find the end-of-message delimiter in the image.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Encoded image not found at &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during decoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="水印信息验证">水印信息验证</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_img_msg</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Command-line tool to decode an invisible watermark from an image file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    image_path = Path(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> image_path.is_file():</span><br><span class="line">        logger.debug(<span class="string">f&quot;Error: File not found at &#x27;<span class="subst">&#123;image_path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">f&quot;Verifying &#x27;<span class="subst">&#123;image_path.name&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">    decoded_message = decode_lsb(<span class="built_in">str</span>(image_path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decoded_message:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ✅ Watermark Found! ---&quot;</span>)</span><br><span class="line">        <span class="comment"># Pretty logger.debug the decoded information</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> decoded_message.split(<span class="string">&#x27;|&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;:&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">                key, value = item.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;key.strip():&lt;<span class="number">15</span>&#125;</span>: <span class="subst">&#123;value.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ❌ No Watermark Found ---&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;No hidden message could be decoded from this image.&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> decoded_message</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="水印信息嵌入（EXIF）">水印信息嵌入（EXIF）</h3> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> piexif</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 UserComment 的标准前缀，UNDEFINED 表示未定义编码，允许我们使用 UTF-8。</span></span><br><span class="line"><span class="comment"># 这是符合 EXIF 规范的推荐做法。</span></span><br><span class="line">USER_COMMENT_PREFIX = <span class="string">b&#x27;UNDEFINED\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_exif</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将秘密信息作为隐形水印编码到图片的EXIF元数据中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path: 输入图片的路径。</span></span><br><span class="line"><span class="string">        secret_message: 要隐藏的信息。</span></span><br><span class="line"><span class="string">        output_image_path: 保存带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        如果编码成功，返回 True，否则返回 False。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在为 &#x27;<span class="subst">&#123;Path(input_image_path).name&#125;</span>&#x27; 添加EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开图片</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 复制原始图片信息，以便在保存时保留质量、DPI等设置</span></span><br><span class="line">        image_info = image.info.copy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否已有EXIF数据，如果没有则创建一个空的</span></span><br><span class="line">        exif_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">in</span> image_info <span class="keyword">and</span> image_info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            exif_dict = piexif.load(image_info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 确保 &#x27;Exif&#x27; 子字典存在，防止 KeyError</span></span><br><span class="line">        <span class="keyword">if</span> piexif.ImageIFD.ExifPtr <span class="keyword">not</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">             exif_dict[<span class="string">&#x27;Exif&#x27;</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 将秘密信息编码并添加标准前缀，然后放入 UserComment 字段</span></span><br><span class="line">        <span class="comment"># 这是存储任意用户数据的标准字段</span></span><br><span class="line">        user_comment_payload = USER_COMMENT_PREFIX + secret_message.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        exif_dict[<span class="string">&#x27;Exif&#x27;</span>][piexif.ExifIFD.UserComment] = user_comment_payload</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将更新后的EXIF字典转换为字节流</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 有时 EXIF 数据可能包含 piexif 不支持的格式</span></span><br><span class="line">            logger.error(<span class="string">f&quot;无法序列化 EXIF 数据: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 尝试移除可能导致问题的缩略图数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;thumbnail&#x27;</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">                <span class="keyword">del</span> exif_dict[<span class="string">&#x27;thumbnail&#x27;</span>]</span><br><span class="line">                exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 保存图片，并附上新的EXIF数据</span></span><br><span class="line">        <span class="comment"># 对于 JPEG，传递原始 info 字典以保留质量等设置</span></span><br><span class="line">        <span class="comment"># 对于 PNG 等其他格式，直接使用 exif 参数</span></span><br><span class="line">        <span class="keyword">if</span> image.<span class="built_in">format</span> == <span class="string">&#x27;JPEG&#x27;</span>:</span><br><span class="line">            image.save(output_image_path, <span class="string">&quot;jpeg&quot;</span>, exif=exif_bytes, **image_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image.save(output_image_path, exif=exif_bytes)</span><br><span class="line"></span><br><span class="line">        logger.success(<span class="string">f&quot;成功将EXIF水印写入 &#x27;<span class="subst">&#123;Path(output_image_path).name&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;输入文件未找到: <span class="subst">&#123;input_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;添加EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_exif</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从图片的EXIF元数据中解码出隐藏的秘密信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path: 带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        解码后的信息字符串，如果未找到或发生错误则返回 None。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在从 &#x27;<span class="subst">&#123;Path(encoded_image_path).name&#125;</span>&#x27; 解码EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否有EXIF数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> image.info <span class="keyword">or</span> <span class="keyword">not</span> image.info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            logger.warning(<span class="string">&quot;图片中未找到EXIF数据。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载EXIF数据</span></span><br><span class="line">        exif_dict = piexif.load(image.info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 安全地从 UserComment 字段读取信息，防止 KeyError</span></span><br><span class="line">        exif_ifd = exif_dict.get(<span class="string">&#x27;Exif&#x27;</span>, &#123;&#125;)</span><br><span class="line">        user_comment_bytes = exif_ifd.get(piexif.ExifIFD.UserComment)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user_comment_bytes:</span><br><span class="line">            <span class="comment"># [FIXED] 检查是否存在我们定义的前缀，并剥离它</span></span><br><span class="line">            <span class="keyword">if</span> user_comment_bytes.startswith(USER_COMMENT_PREFIX):</span><br><span class="line">                message_bytes = user_comment_bytes[<span class="built_in">len</span>(USER_COMMENT_PREFIX):]</span><br><span class="line">                <span class="comment"># 将字节解码回字符串</span></span><br><span class="line">                decoded_message = message_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                logger.success(<span class="string">&quot;成功解码EXIF水印。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(<span class="string">&quot;在&#x27;UserComment&#x27;字段中找到数据，但不包含预期的水印前缀。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&quot;在EXIF中未找到&#x27;UserComment&#x27;水印字段。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;文件未找到: <span class="subst">&#123;encoded_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;解码EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="技术总结对比">技术总结对比</h3><table><thead><tr><th style="text-align:left">技术类别</th><th style="text-align:left">核心算法</th><th style="text-align:left">主要优点</th><th style="text-align:left">主要缺点</th><th style="text-align:left">典型应用</th></tr></thead><tbody><tr><td style="text-align:left"><strong>空域 (Spatial Domain)</strong></td><td style="text-align:left"><strong>LSB</strong></td><td style="text-align:left">实现简单、容量大</td><td style="text-align:left"><strong>鲁棒性极差</strong>，一碰就坏</td><td style="text-align:left"><strong>完整性认证 (脆弱水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DCT</strong></td><td style="text-align:left"><strong>对压缩鲁棒</strong>、隐蔽性好</td><td style="text-align:left">对几何攻击抵抗力一般</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DWT</strong></td><td style="text-align:left"><strong>综合鲁棒性强</strong>，尤其对裁剪等</td><td style="text-align:left">算法比DCT复杂</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DFT</strong></td><td style="text-align:left"><strong>对旋转/缩放鲁棒</strong></td><td style="text-align:left">实现复杂，可能影响画质</td><td style="text-align:left"><strong>抵抗几何攻击的特殊应用</strong></td></tr></tbody></table><p>简单来说：</p><ul><li>想做<strong>防伪标签</strong>，一改就失效，用 <strong>LSB</strong>。</li><li>想做<strong>版权印章</strong>，不怕压缩和基本处理，用 <strong>DCT</strong> 或 <strong>DWT</strong>。它们是目前最实用和最主流的鲁棒水印技术。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现流程框架&quot;&gt;实现流程框架&lt;/h2&gt;
&lt;p&gt;无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水印嵌入 (Watermark Embedding)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Tailscale</title>
    <link href="https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/</id>
    <published>2025-07-17T12:10:39.000Z</published>
    <updated>2025-11-25T15:05:10.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="一、Tailscale-到底是什么？">一、Tailscale 到底是什么？</h3><p>你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。</p><ul><li><strong>传统的VPN</strong>：像是在你家（局域网）和公司（另一个局域网）之间挖了一条秘密隧道。</li><li><strong>Tailscale</strong>：更像是给你的每一台设备（NAS、电脑、手机、平板）都穿上了一件“隐身衣”，并给它们一个秘密的联络暗号。无论这些设备身处世界何地，只要它们都穿着这件“隐身衣”（安装了 Tailscale 客户端并用同一账号登录），它们就能互相看见、互相通信，仿佛就在同一个房间里。</li></ul><p>这个“虚拟局域网”是建立在互联网之上的，但它又是完全隔离和加密的，外界无法窥探。</p><h3 id="二、它如何解决你的-NAS-外链问题？">二、它如何解决你的 NAS 外链问题？</h3><p>Tailscale 通过以下几个核心功能来解决你的问题：</p><ol><li><strong>稳定的虚拟 IP 地址</strong>：一旦你的 NAS 加入了 Tailscale 网络，它会被分配一个 <code>100.x.x.x</code> 开头的、独一无二且固定的 IP 地址。你再也不用关心家里宽带的公网 IP 是不是变了。</li><li><strong>零配置穿透 (Zero-config NAT traversal)</strong>：你不需要在路由器上做任何端口转发。Tailscale 会自动想办法在你的设备之间“打洞”，建立点对点（P2P）的加密连接。这意味着数据传输速度很快，因为大部分时间数据是直连的，不经过第三方服务器中转。</li><li><strong>极高的安全性</strong>：它基于目前最先进的 VPN 协议 <strong>WireGuard®</strong> 构建，所有通信都是端到端加密的。因为你没有在路由器上开放任何端口，所以你的 NAS 不会暴露在公网上，大大降低了被黑客扫描和攻击的风险。</li><li><strong>设备间的无缝访问</strong>：只要你的电脑或手机也安装并登录了 Tailscale，你就可以在任何地方，直接通过 NAS 的那个 <code>100.x.x.x</code> 虚拟 IP 来访问它的管理页面、File Station 等所有服务，体验和在家里一模一样。</li></ol><h2 id="部署">部署</h2><h3 id="部署方式一：使用-docker-run-命令（单次部署）">部署方式一：使用 <code>docker run</code> 命令（单次部署）</h3><p>这是最直接的方式，适合快速启动。</p><h4 id="步骤-1：准备持久化目录">步骤 1：准备持久化目录</h4><p>为了让 Tailscale 的状态（主要是它的身份密钥）在容器重启后不丢失，我们需要在主机上创建一个目录来持久化存储它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH 登录到你的 NAS 或服务器</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /path/to/your/appdata/tailscale</span><br><span class="line"><span class="comment"># 注意：请将 /path/to/your/appdata 替换为你自己存放应用数据的实际路径</span></span><br><span class="line"><span class="comment"># 例如，在群晖上可能是 /volume1/docker/tailscale</span></span><br></pre></td></tr></table></figure><h4 id="步骤-2：运行-Docker-容器">步骤 2：运行 Docker 容器</h4><p>复制并执行以下命令。这条命令已经包含了运行 Tailscale 所需的所有关键配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=tailscaled \</span><br><span class="line">  -v /path/to/your/appdata/tailscale:/var/lib/tailscale \</span><br><span class="line">  -v /dev/net/tun:/dev/net/tun \</span><br><span class="line">  --network=host \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=NET_RAW \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  tailscale/tailscale</span><br></pre></td></tr></table></figure><p><strong>命令参数详解：</strong></p><ul><li><code>docker run -d</code>: 在后台（detached mode）运行容器。</li><li><code>--name=tailscaled</code>: 给容器起一个好记的名字，方便管理。</li><li><code>-v /path/to/your/appdata/tailscale:/var/lib/tailscale</code>: <strong>【核心】</strong> 将主机上的目录挂载到容器内，用于保存 Tailscale 的状态。<strong>务必替换为你自己的路径</strong>。</li><li><code>-v /dev/net/tun:/dev/net/tun</code>: 将主机的 TUN 设备挂载到容器内，这是 Tailscale 创建虚拟网卡所必需的。</li><li><code>--network=host</code>: <strong>【核心】</strong> 让容器直接使用主机的网络，这是最简单且功能最全的模式。容器可以轻松访问主机的所有端口，也方便将主机作为子网路由（Subnet Router）。</li><li><code>--cap-add=NET_ADMIN --cap-add=NET_RAW</code>: 授予容器操作网络接口所需的 Linux Capabilities 权限。</li><li><code>--restart unless-stopped</code>: 设置容器的重启策略，除非手动停止，否则 Docker 重启时会自动启动该容器。</li><li><code>tailscale/tailscale</code>: 指定要使用的官方 Docker 镜像。</li></ul><h4 id="步骤-3：将-NAS-加入你的-Tailscale-网络">步骤 3：将 NAS 加入你的 Tailscale 网络</h4><p>容器已经在运行了，但它还不知道自己是谁。我们需要执行一条命令来让它登录。</p><ol><li><p>执行以下命令，启动 Tailscale 并获取登录链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure></li><li><p>命令执行后，终端会输出一个登录 URL，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To authenticate, visit:</span><br><span class="line"></span><br><span class="line">    https://login.tailscale.com/a/123456789ABC</span><br></pre></td></tr></table></figure></li><li><p>复制这个 URL，在你的电脑浏览器中打开，用你的 Tailscale 账户登录并授权这台新设备。</p></li><li><p>授权成功后，回到你的 <a href="https://login.tailscale.com/admin/machines">Tailscale Admin Console</a> 后台，你就能看到这台新设备已经加入了你的网络。</p></li></ol><p><strong>至此，你的 NAS 已经成功通过 Docker 加入了 Tailscale 网络！</strong> 你可以在任何其他已登录 Tailscale 的设备上，通过分配的 <code>100.x.x.x</code> IP 地址来访问你的 NAS。</p><hr><h3 id="部署方式二：使用-docker-compose（推荐，便于管理）">部署方式二：使用 <code>docker-compose</code>（推荐，便于管理）</h3><p>如果你需要管理多个容器，或者希望将配置以文件形式保存下来，<code>docker-compose</code> 是更好的选择。</p><h4 id="步骤-1：创建-docker-compose-yml-文件">步骤 1：创建 <code>docker-compose.yml</code> 文件</h4><p>在你喜欢的位置（例如 <code>/volume1/docker/tailscale</code>）创建一个名为 <code>docker-compose.yml</code> 的文件，并将以下内容粘贴进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">tailscaled:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tailscale/tailscale</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tailscaled</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">my-nas</span> <span class="comment"># 在 Tailscale 管理后台显示的设备名</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/tailscale</span> <span class="comment"># 将状态保存在当前目录下的 data 文件夹</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/net/tun:/dev/net/tun</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_RAW</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>hostname</code>: 你可以自定义一个名字，这样在 Tailscale 后台一眼就能认出是哪台设备。</li><li><code>volumes</code>: <code>- ./data:/var/lib/tailscale</code> 这种相对路径的写法表示将状态文件保存在 <code>docker-compose.yml</code> 文件同级的 <code>data</code> 文件夹内，非常方便。</li></ul><h4 id="步骤-2：启动服务">步骤 2：启动服务</h4><p>在 <code>docker-compose.yml</code> 文件所在的目录中，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="步骤-3：登录和授权">步骤 3：登录和授权</h4><p>这一步和 <code>docker run</code> 方式完全一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure><p>然后复制输出的 URL 到浏览器完成授权。</p><hr><h3 id="高级功能：如何生成外链和访问内网？">高级功能：如何生成外链和访问内网？</h3><p>部署成功后，你可以利用 Tailscale 的高级功能来实现最初的目标。</p><h4 id="1-将-NAS-作为子网路由-Subnet-Router">1. 将 NAS 作为子网路由 (Subnet Router)</h4><p><strong>场景</strong>：你想通过手机（已连接 Tailscale）访问你家里的其他设备，比如打印机 (<code>192.168.1.100</code>)。</p><ol><li><p>修改启动命令，使其“宣告”它可以路由的内网网段。在执行 <code>tailscale up</code> 时加入 <code>--advertise-routes</code> 参数。</p><ul><li>你需要先 <code>down</code> 再 <code>up</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale down</span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.1.0/24</span><br><span class="line"><span class="comment"># !!! 将 192.168.1.0/24 替换为你自己的局域网网段 !!!</span></span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.10.0/24 -accept-dns=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 Tailscale Admin Console 后台，找到你的 NAS 设备，点击右侧的 “…”，选择 “Edit route settings…”。</p></li><li><p>勾选并启用你刚刚宣告的子网路由。</p></li></ol><p>现在，你任何连接了 Tailscale 的设备，都可以直接访问 <code>192.168.1.x</code> 网段的所有设备了，就像在家一样。</p><h4 id="2-使用-Tailscale-Funnel-生成外链">2. 使用 Tailscale Funnel 生成外链</h4><p><strong>场景</strong>：你想临时分享 NAS 上的一个文件给没有安装 Tailscale 的朋友。</p><ol><li><p>确保你的 Docker 容器已经通过 <code>tailscale up</code> 成功连接。</p></li><li><p>假设你想分享的服务在主机的 <code>8080</code> 端口上（比如一个临时的文件服务器）。</p><ul><li>由于我们使用了 <code>--network=host</code>，容器可以直接访问到主机的 <code>8080</code> 端口。</li></ul></li><li><p>执行 Funnel 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale funnel 8080</span><br></pre></td></tr></table></figure></li><li><p>命令会输出一个公网可访问的 HTTPS 链接，形如 <code>https://your-nas-hostname.ts.net</code>。将这个链接发给你的朋友即可。</p></li><li><p>分享完毕后，按 <code>Ctrl+C</code> 停止 Funnel，外链即刻失效，非常安全。如果想在后台运行，可以加上 <code>--bg</code> 参数。</p></li></ol><h3 id="总结：如何使用部署后的服务">总结：如何使用部署后的服务</h3><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">使用的功能</th><th style="text-align:left">具体操作</th></tr></thead><tbody><tr><td style="text-align:left"><strong>在外面用</strong></td><td style="text-align:left"><strong>Tailscale 核心连接 + MagicDNS</strong></td><td style="text-align:left">在你的电脑/手机上安装并登录 Tailscale，然后像在家里一样，用 <code>http://设备名:端口</code> 的方式访问 NAS 的各项服务。</td></tr><tr><td style="text-align:left"><strong>映射为电脑硬盘</strong></td><td style="text-align:left"><strong>SMB/AFP over Tailscale</strong></td><td style="text-align:left">在电脑的“映射网络驱动器”或“连接服务器”功能中，使用 <code>\\设备名</code> 或 <code>smb://设备名</code> 作为地址。</td></tr><tr><td style="text-align:left"><strong>分享文件给别人</strong></td><td style="text-align:left"><strong>Tailscale Funnel</strong></td><td style="text-align:left">在 NAS 上用 Python 或其他方式启动一个临时 Web 服务器，然后用 <code>tailscale funnel &lt;端口号&gt;</code> 命令生成一个临时的公网下载链接。</td></tr><tr><td style="text-align:left"><strong>访问家里其他设备</strong></td><td style="text-align:left"><strong>子网路由 (Subnet Router)</strong></td><td style="text-align:left">在部署 Tailscale 时宣告内网网段，并在管理后台启用。之后就能直接通过内网 IP 访问家里所有设备。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;h3 id=&quot;一、Tailscale-到底是什么？&quot;&gt;一、Tailscale 到底是什么？&lt;/h3&gt;
&lt;p&gt;你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统的V</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NAS 文件借助 MinIO 转换OSS</title>
    <link href="https://caozhaoqi.github.io/2025/07/16/minio-nas-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/16/minio-nas-build/</id>
    <published>2025-07-16T08:58:11.000Z</published>
    <updated>2025-11-25T15:05:10.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体架构">整体架构</h3><p>这个架构的核心思想是：<strong>MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。</strong> 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理路径下。</p><h3 id="方案优点">方案优点</h3><ol><li><strong>协议现代化</strong>：将传统的、基于文件系统的访问（如 NFS, SMB）升级为现代的、基于 HTTP 的 S3 API 访问。</li><li><strong>无需数据迁移</strong>：数据仍然存放在 NAS 上，你不需要花费大量时间去拷贝或迁移 TB 级的海量数据。MinIO 直接在 NAS 的文件系统之上运行。</li><li><strong>统一访问入口</strong>：无论你有多少个 NAS 卷或目录，都可以通过 MinIO 的 Bucket（存储桶）来组织和访问，形成一个统一的视图。</li><li><strong>生态兼容性</strong>：几乎所有现代云原生应用、大数据框架、备份工具都原生支持 S3 协议，可以无缝对接。</li><li><strong>高性能</strong>：MinIO 本身是为高性能而设计的，可以直接利用 NAS 的硬件性能。</li></ol><hr><h3 id="第一步：准备工作">第一步：准备工作</h3><ol><li><strong>一台服务器/虚拟机</strong>：你需要一台 Linux 服务器来运行 MinIO。这台服务器<strong>必须能够高速挂载（mount）你的 NAS 目录</strong>。这台服务器的 CPU 和内存资源会影响 MinIO 的性能，但对于一般的文件服务，配置要求不高（例如 2核4G 内存即可起步）。我们称这台服务器为 “MinIO Server”。</li><li><strong>网络连接</strong>：确保 MinIO Server 和 NAS 之间有高速、低延迟的网络连接（例如，千兆或万兆以太网）。</li><li><strong>NAS 目录</strong>：确定你要提供为对象存储的 NAS 上的一个或多个目录。例如，<code>/volume1/data</code>。</li></ol><h3 id="第二步：在-MinIO-Server-上挂载-NAS-目录">第二步：在 MinIO Server 上挂载 NAS 目录</h3><p>这是最关键的一步。你必须将 NAS 的共享目录挂载到 MinIO Server 的本地文件系统上。</p><p>假设你的 NAS IP 是 <code>192.168.1.100</code>，共享的目录是 <code>shared_data</code>，你希望将它挂载到 MinIO Server 的 <code>/mnt/nas_data</code> 目录。</p><h4 id="使用-NFS-挂载（推荐）">使用 NFS 挂载（推荐）</h4><ol><li><p><strong>在 NAS 上</strong>：确保 NFS 服务已开启，并且 <code>shared_data</code> 目录已经通过 NFS 共享出去，同时授权 MinIO Server 的 IP (<code>192.168.1.50</code> 假设) 有读写权限。</p></li><li><p><strong>在 MinIO Server 上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 NFS 客户端</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nfs-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建本地挂载点</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 手动挂载进行测试</span></span><br><span class="line"><span class="comment"># -o nfsvers=4 指定版本，可根据你的NAS调整</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t nfs 192.168.1.100:/shared_data /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 验证挂载是否成功</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 你应该能看到类似下面的一行</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/shared_data   50T   10T   40T   20% /mnt/nas_data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. (重要) 设置开机自动挂载，防止服务器重启后服务失效</span></span><br><span class="line"><span class="comment"># 编辑 /etc/fstab 文件</span></span><br><span class="line"><span class="built_in">sudo</span> nano /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾添加一行 (使用 nofail 选项防止NAS故障导致服务器无法启动)</span></span><br><span class="line">192.168.1.100:/shared_data /mnt/nas_data nfs defaults,nofail 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="第三步：使用-Docker-Compose-部署-MinIO">第三步：使用 Docker Compose 部署 MinIO</h3><p>使用 Docker Compose 是部署和管理 MinIO 最简单、最可靠的方式。</p><ol><li><p><strong>在 MinIO Server 上安装 Docker 和 Docker Compose。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker Compose</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-compose</span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个工作目录并编写 <code>docker-compose.yml</code> 文件。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> minio-deployment</span><br><span class="line"><span class="built_in">cd</span> minio-deployment</span><br><span class="line">nano docker-compose.yml</span><br></pre></td></tr></table></figure></li><li><p><strong>将以下内容粘贴到 <code>docker-compose.yml</code> 文件中：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="comment"># 使用官方 MinIO 镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">local-oss-server</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义环境变量 (请务必修改密码)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Access Key (用户名)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_USER:</span> <span class="string">minioadmin</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Secret Key (密码, 至少8位)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_PASSWORD:</span> <span class="string">VERY_SECRET_PASSWORD_CHANGE_ME</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># volumes 卷挂载是核心</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们刚刚挂载的 NAS 目录，映射到 MinIO 容器内部的 /data 目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas_data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas:/data2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ports 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 9000 端口是 S3 API 的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="comment"># 9001 端口是 MinIO Web 控制台的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># command 命令</span></span><br><span class="line">    <span class="comment"># 告诉 MinIO 启动一个服务器，并使用容器内的 /data 目录作为存储根目录</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span> <span class="string">/data2</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 健康检查，确保服务正常运行</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动 MinIO 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><h3 id="第四步：验证和使用">第四步：验证和使用</h3><p>现在，你的本地 OSS 服务已经搭建完成并开始运行了！</p><ol><li><p><strong>访问 Web 控制台</strong>：</p><ul><li>在浏览器中打开 <code>http://&lt;MinIO_Server_IP&gt;:9001</code>。</li><li>使用你在 <code>docker-compose.yml</code> 中设置的 <code>MINIO_ROOT_USER</code> (minioadmin) 和 <code>MINIO_ROOT_PASSWORD</code> 登录。</li></ul></li><li><p><strong>查看数据</strong>：</p><ul><li>登录后，你会看到 MinIO 的界面。点击 “Buckets”（存储桶）。</li><li><strong>你会惊喜地发现，你在 NAS 目录 <code>/mnt/nas_data</code> 下的所有一级子目录，都已经自动变成了 MinIO 的 Buckets！</strong></li><li>例如，如果你的 NAS 目录结构是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nas_data/</span><br><span class="line">├── images/</span><br><span class="line">│   ├── cat.jpg</span><br><span class="line">│   └── dog.png</span><br><span class="line">└── videos/</span><br><span class="line">    └── movie.mp4</span><br></pre></td></tr></table></figure></li><li>那么在 MinIO 控制台里，你就会看到两个 bucket：<code>images</code> 和 <code>videos</code>。你可以直接点击进入并管理里面的文件。</li></ul></li><li><p><strong>使用 S3 API 访问</strong>：</p><ul><li><strong>Endpoint (服务地址)</strong>: <code>http://&lt;MinIO_Server_IP&gt;:9000</code></li><li><strong>Access Key</strong>: <code>minioadmin</code></li><li><strong>Secret Key</strong>: <code>VERY_SECRET_PASSWORD_CHANGE_ME</code></li><li>你可以使用任何支持 S3 的客户端工具（如 <code>s3cmd</code>, <code>mc</code>, AWS SDK）来连接和操作你的数据。</li></ul><p><strong>使用 MinIO Client (mc) 的示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载 mc</span></span><br><span class="line">wget https://dl.min.io/client/mc/release/linux-amd64/mc</span><br><span class="line"><span class="built_in">chmod</span> +x mc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> mc /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置一个别名，指向你的本地 OSS</span></span><br><span class="line">mc <span class="built_in">alias</span> <span class="built_in">set</span> local-oss http://&lt;MinIO_Server_IP&gt;:9000 minioadmin VERY_SECRET_PASSWORD_CHANGE_ME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 列出所有的 bucket (即 NAS 上的一级目录)</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 列出 images bucket 里的所有文件</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss/images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 上传一个新文件到 videos bucket</span></span><br><span class="line">mc <span class="built_in">cp</span> my_new_video.mp4 local-oss/videos</span><br><span class="line"><span class="comment"># 执行后，你会在 NAS 的 /mnt/nas_data/videos/ 目录下看到 my_new_video.mp4 文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="问题">问题</h3><ul><li>重启后残留文件清理</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf .minio.sys</span><br><span class="line">docker-compose down &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过 <strong>NAS 挂载 + MinIO Docker 部署</strong> 这个简单的两步组合，你成功地将传统的 NAS 文件存储“包装”成了一个功能强大、接口标准、易于扩展的本地对象存储服务。这个方案兼具了 NAS 的大容量存储成本优势和 OSS 的现代化接口优势，是盘活存量数据资产的绝佳实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;整体架构&quot;&gt;整体架构&lt;/h3&gt;
&lt;p&gt;这个架构的核心思想是：&lt;strong&gt;MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。&lt;/strong&gt; 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
</feed>
