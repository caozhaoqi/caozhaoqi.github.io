<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhaoqi.Cao static blog</title>
  
  <subtitle>浅斟低唱</subtitle>
  <link href="https://caozhaoqi.github.io/atom.xml" rel="self"/>
  
  <link href="https://caozhaoqi.github.io/"/>
  <updated>2025-12-11T15:35:33.356Z</updated>
  <id>https://caozhaoqi.github.io/</id>
  
  <author>
    <name>Zhaoqi.Cao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python装饰器</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/decorator-py-use/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/decorator-py-use/</id>
    <published>2025-12-11T15:30:36.000Z</published>
    <updated>2025-12-11T15:35:33.356Z</updated>
    
    <content type="html"><![CDATA[<h1>【Python进阶】一文彻底搞懂“装饰器”：从原理到实战（附 Python vs Java 深度对比）</h1><h2 id="一、-什么是装饰器？（通俗理解）">一、 什么是装饰器？（通俗理解）</h2><p>想象一下，你有一部手机（<strong>原函数</strong>），它能打电话（<strong>核心功能</strong>）。<br>现在你想给手机增加“防摔”和“美观”的功能，你不会把手机拆了重新焊一个外壳，而是直接给它套一个<strong>手机壳</strong>。</p><p><strong>装饰器就是这个“手机壳”。</strong></p><ul><li><strong>定义</strong>：装饰器本质上是一个<strong>Python 函数</strong>，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能。</li><li><strong>核心</strong>：它接收一个函数作为参数，并返回一个新的函数。</li></ul><hr><h2 id="二、-为什么要用装饰器？（作用）">二、 为什么要用装饰器？（作用）</h2><p>假设你开发了一个电商系统，里面有 100 个函数处理不同的业务。现在老板提了个需求：<strong>“给这 100 个函数都加上日志记录，我要看它们执行了多久。”</strong></p><ul><li><strong>笨办法</strong>：打开这 100 个函数，挨个改代码。-&gt; <em>维护噩梦</em>。</li><li><strong>装饰器</strong>：写<strong>一个</strong>通用的 <code>@timer</code> 装饰器，给函数戴上即可。<ul><li><em>优点</em>：<strong>代码复用</strong>（DRY原则），<strong>逻辑分离</strong>（业务代码纯净，非业务代码抽离）。</li></ul></li></ul><hr><h2 id="三、-装饰器的原理（抽丝剥茧）">三、 装饰器的原理（抽丝剥茧）</h2><p>要理解装饰器，必须理解 Python 的两个特性：</p><ol><li><strong>函数是对象</strong>：函数可以赋值给变量，也可以作为参数传递。</li><li><strong>闭包</strong>：函数内部可以定义函数，内部函数可以访问外部函数的变量。</li></ol><h3 id="1-最原始的样子">1. 最原始的样子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; 装饰前&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&lt;&lt;&lt; 装饰后&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fight</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;士兵正在战斗...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 核心逻辑：用 wrapper 替换掉原来的 fight</span></span><br><span class="line">fight = my_decorator(fight)</span><br><span class="line">fight()</span><br></pre></td></tr></table></figure><h3 id="2-使用-语法糖">2. 使用 <code>@</code> 语法糖</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@my_decorator  </span><span class="comment"># 等同于 fight = my_decorator(fight)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fight</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;士兵正在战斗...&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="四、-万能装饰器模板（直接抄作业）">四、 万能装饰器模板（直接抄作业）</h2><p>实际开发中，被装饰的函数可能有参数，可能有返回值。请背诵以下模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="comment"># @functools.wraps 作用：保留原函数的元信息（如函数名、文档说明）</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 1. 接收任意参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- 开始执行 <span class="subst">&#123;func.__name__&#125;</span> ---&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 执行原函数，并接收返回值</span></span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- 执行结束 ---&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 必须返回原函数的结果</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><hr><h2 id="五、-实战场景应用">五、 实战场景应用</h2><ol><li><strong>权限校验</strong>：<code>@login_required</code> (Flask/Django 中最常见)。</li><li><strong>性能分析</strong>：<code>@timer</code> 计算函数耗时。</li><li><strong>缓存</strong>：<code>@lru_cache</code> (Python 内置) 缓存计算结果，避免重复计算。</li><li><strong>自动重试</strong>：<code>@retry</code> 网络请求失败自动重连。</li></ol><hr><h2 id="六、-特别篇：Python-装饰器-vs-Java-注解-核心考点">六、 特别篇：Python 装饰器 vs Java 注解 (核心考点)</h2><p>这是很多面试官喜欢问的高阶问题，也是很多 Java 转 Python 选手的认知误区。</p><p><strong>一句话总结：Python 装饰器是“干活的”，Java 注解是“贴标签的”。</strong></p><h3 id="1-类别与本质的区别">1. 类别与本质的区别</h3><table><thead><tr><th style="text-align:left">维度</th><th style="text-align:left">Python 装饰器 (Decorator)</th><th style="text-align:left">Java 注解 (Annotation)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>本质</strong></td><td style="text-align:left"><strong>是一个函数（或类）</strong></td><td style="text-align:left"><strong>是一种元数据（Metadata）</strong></td></tr><tr><td style="text-align:left"><strong>状态</strong></td><td style="text-align:left"><strong>主动的</strong>。它是可执行的代码。</td><td style="text-align:left"><strong>被动的</strong>。它只是一个标签，自己不会动。</td></tr><tr><td style="text-align:left"><strong>生效时机</strong></td><td style="text-align:left"><strong>加载时运行</strong>。Python 文件一加载，装饰器代码就执行了，原函数直接被替换。</td><td style="text-align:left"><strong>运行时/编译时读取</strong>。需要额外的代码（反射或编译器）来读取标签并执行逻辑。</td></tr><tr><td style="text-align:left"><strong>实现机制</strong></td><td style="text-align:left"><strong>闭包 + 高阶函数</strong></td><td style="text-align:left"><strong>反射 (Reflection) + AOP (动态代理)</strong></td></tr></tbody></table><h3 id="2-原理对比图解">2. 原理对比图解</h3><h4 id="Python-的逻辑（狸猫换太子）">Python 的逻辑（狸猫换太子）</h4><p>Python 的装饰器直接<strong>修改</strong>了函数对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>(): <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于:</span></span><br><span class="line">hello = log(hello) </span><br><span class="line"><span class="comment"># hello 变成了一个新的函数 wrapper，原来的 hello 被包在里面了。</span></span><br></pre></td></tr></table></figure><h4 id="Java-的逻辑（说明书与阅读者）">Java 的逻辑（说明书与阅读者）</h4><p>Java 的注解就像是给杯子贴了个“易碎品”的<strong>标签</strong>。杯子还是那个杯子，不会变。<br>但是，Spring 框架（容器）看到了这个标签，就会在调用这个杯子的时候，生成一个**代理对象（Proxy）**来小心翼翼地处理它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 这是一个标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java 虚拟机运行原理：</span></span><br><span class="line"><span class="comment">// 1. Spring 扫描到 @Transactional 标签。</span></span><br><span class="line"><span class="comment">// 2. Spring 利用“动态代理”生成一个新类。</span></span><br><span class="line"><span class="comment">// 3. 在新类里写代码：开启事务 -&gt; 调用 saveUser() -&gt; 提交事务。</span></span><br></pre></td></tr></table></figure><h3 id="3-使用上的体感区别">3. 使用上的体感区别</h3><ul><li><p><strong>编写难度</strong>：</p><ul><li><strong>Python</strong>：极其简单。写个函数就能当装饰器用。</li><li><strong>Java</strong>：比较繁琐。你需要先定义注解接口 (<code>@interface</code>)，然后写切面类 (<code>@Aspect</code>)，定义切点 (<code>@Pointcut</code>) 和通知 (<code>@Around</code>)，通常需要依赖 Spring 框架才能用得顺手。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li><strong>Python</strong>：极高。装饰器里可以写任意逻辑，甚至可以把函数变成类，把类变成函数。</li><li><strong>Java</strong>：规范性强。注解主要用于配置，逻辑与业务代码完全分离（解耦更彻底）。</li></ul></li></ul><h3 id="4-举个栗子：实现“日志记录”">4. 举个栗子：实现“日志记录”</h3><p><strong>Python 写法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义即实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Log: Start&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@log  </span><span class="comment"># 直接生效</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_work</span>(): ...</span><br></pre></td></tr></table></figure><p><strong>Java 写法 (伪代码)：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义标签</span></span><br><span class="line"><span class="meta">@interface</span> Log &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 只有标签没用，还得写个“切面”来识别标签并干活</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(Log)&quot;)</span> <span class="comment">// 监听贴了Log标签的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Log: Start&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> joinPoint.proceed(); <span class="comment">// 执行原方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用</span></span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七、-总结">七、 总结</h2><ol><li><strong>Python 装饰器</strong>是<strong>高阶函数</strong>，利用闭包原理，在加载时直接<strong>替换/包装</strong>了原函数。它是<strong>修改结构</strong>的艺术。</li><li><strong>Java 注解</strong>是<strong>元数据标签</strong>，利用反射和动态代理（AOP）原理，在运行时动态增强。它是<strong>配置与逻辑分离</strong>的艺术。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【Python进阶】一文彻底搞懂“装饰器”：从原理到实战（附 Python vs Java 深度对比）&lt;/h1&gt;
&lt;h2 id=&quot;一、-什么是装饰器？（通俗理解）&quot;&gt;一、 什么是装饰器？（通俗理解）&lt;/h2&gt;
&lt;p&gt;想象一下，你有一部手机（&lt;strong&gt;原函数&lt;/str</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从 CNN 视觉感知到 Transformer 全局认知</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/cnn-transformer-model/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/cnn-transformer-model/</id>
    <published>2025-12-11T15:28:14.000Z</published>
    <updated>2025-12-11T15:28:53.210Z</updated>
    
    <content type="html"><![CDATA[<h1>【硬核手撸】PyTorch 建模实战：从 CNN 视觉感知到 Transformer 全局认知</h1><blockquote><p><strong>摘要</strong>：在 AI 工程师的日常工作中，&quot;调包&quot;只是基础，理解并能手写模型架构才是进阶。本文将基于 PyTorch 框架，深入拆解深度学习领域的两大基石：<strong>CNN (卷积神经网络)</strong> 与 <strong>Transformer</strong>。我们将结合变电站巡检的具体业务场景，手把手演示如何搭建这两种架构，并解析其背后的设计哲学。</p></blockquote><hr><h2 id="一、-PyTorch：AI-工程师的“乐高积木”">一、 PyTorch：AI 工程师的“乐高积木”</h2><p>在 JD 中，公司明确要求 <em>“熟悉 PyTorch 等主流深度学习框架”</em>。<br>PyTorch 之所以流行，是因为它采用了<strong>面向对象 (OOP)</strong> 的设计思想。每一个神经网络层（Layer）都是一个 <code>nn.Module</code>，我们可以像搭乐高积木一样，将不同的层组合起来。</p><p>在变电站场景中：</p><ul><li><strong>CNN</strong> 是机器的**“眼睛”**：用于提取图像特征（锈蚀、读数）。</li><li><strong>Transformer</strong> 是机器的**“大脑”**：用于处理序列数据（日志分析）或融合多模态信息。</li></ul><hr><h2 id="二、-构建-CNN：机器视觉的基石">二、 构建 CNN：机器视觉的基石</h2><h3 id="1-原理图解：它是怎么“看”东西的？">1. 原理图解：它是怎么“看”东西的？</h3><p>CNN (Convolutional Neural Network) 的核心在于**“局部感知”<strong>和</strong>“权值共享”**。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    Input[输入图片: 仪表盘] --&gt; Conv1[卷积层1: 提取边缘]</span><br><span class="line">    Conv1 --&gt; Pool1[池化层1: 缩小尺寸]</span><br><span class="line">    Pool1 --&gt; Conv2[卷积层2: 提取形状]</span><br><span class="line">    Conv2 --&gt; Pool2[池化层2: 提取特征]</span><br><span class="line">    Pool2 --&gt; FC[全连接层: 分类/回归]</span><br><span class="line">    FC --&gt; Output[输出: 读数/状态]</span><br></pre></td></tr></table></figure><h3 id="2-PyTorch-代码实现-工业级写法">2. PyTorch 代码实现 (工业级写法)</h3><p>我们不再写玩具代码，而是模拟一个<strong>VGG风格</strong>的特征提取器，用于变电站设备的锈蚀检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndustrialCNN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes=<span class="number">2</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(IndustrialCNN, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># === 特征提取层 (Feature Extractor) ===</span></span><br><span class="line">        <span class="comment"># Block 1: 基础边缘特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">32</span>), <span class="comment"># 归一化：防止梯度消失，加速收敛</span></span><br><span class="line">            nn.ReLU(),          <span class="comment"># 激活函数：引入非线性</span></span><br><span class="line">            nn.MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>) <span class="comment"># 降采样：减少计算量</span></span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Block 2: 高级纹理特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer2 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">64</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Block 3: 抽象语义特征</span></span><br><span class="line">        <span class="variable language_">self</span>.layer3 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">64</span>, <span class="number">128</span>, <span class="number">3</span>, padding=<span class="number">1</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">128</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># === 分类头 (Classifier Head) ===</span></span><br><span class="line">        <span class="comment"># 假设输入图片是 224x224, 经过3次池化(除以8) -&gt; 28x28</span></span><br><span class="line">        <span class="variable language_">self</span>.flatten = nn.Flatten()</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">128</span> * <span class="number">28</span> * <span class="number">28</span>, <span class="number">512</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>), <span class="comment"># 防止过拟合</span></span><br><span class="line">            nn.Linear(<span class="number">512</span>, num_classes)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 数据流向：Input -&gt; Layer1 -&gt; Layer2 -&gt; Layer3 -&gt; Flatten -&gt; FC -&gt; Output</span></span><br><span class="line">        x = <span class="variable language_">self</span>.layer1(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.layer2(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.layer3(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.flatten(x)</span><br><span class="line">        logits = <span class="variable language_">self</span>.fc(x)</span><br><span class="line">        <span class="keyword">return</span> logits</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试模型结构</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    model = IndustrialCNN()</span><br><span class="line">    <span class="comment"># 模拟一张 batch=1, rgb=3, 224x224 的图片</span></span><br><span class="line">    dummy_input = torch.randn(<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line">    output = model(dummy_input)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;CNN Output Shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>) <span class="comment"># 预期: [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-面试加分点解析">3. 面试加分点解析</h3><ul><li><strong>BatchNorm 的使用</strong>：面试官如果问“训练不收敛怎么办”，你可以结合代码说：“我会在卷积层后加入 <code>BatchNorm</code>，它能让数据分布更稳定。”</li><li><strong>Dropout 的使用</strong>：如果问“过拟合怎么办”，你可以指着代码说：“我在全连接层加了 <code>Dropout</code>，随机丢弃一部分神经元，增加鲁棒性。”</li></ul><hr><h2 id="三、-构建-Transformer：全局注意力的魔法">三、 构建 Transformer：全局注意力的魔法</h2><h3 id="1-原理图解：Self-Attention-是什么？">1. 原理图解：Self-Attention 是什么？</h3><p>不同于 CNN 只能看局部，Transformer 通过 <strong>Self-Attention (自注意力机制)</strong> 可以一次性看到全局。<br>比如在处理巡检日志：“设备A温度正常，但设备B震动异常”。Transformer 能捕捉到“设备B”和“震动异常”之间的长距离关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    Input[输入序列] --&gt; Embed[Embedding + 位置编码]</span><br><span class="line">    Embed --&gt; Attn[Multi-Head Self-Attention]</span><br><span class="line">    Attn --&gt; Norm1[Add &amp; Norm]</span><br><span class="line">    Norm1 --&gt; FFN[Feed Forward Network]</span><br><span class="line">    FFN --&gt; Norm2[Add &amp; Norm]</span><br><span class="line">    Norm2 --&gt; Output[输出特征]</span><br></pre></td></tr></table></figure><h3 id="2-PyTorch-代码实现-手写-Encoder-Block">2. PyTorch 代码实现 (手写 Encoder Block)</h3><p>虽然 PyTorch 提供了 <code>nn.Transformer</code>，但为了展示深度，我们<strong>手写一个 Transformer Encoder Block</strong>。这在处理<strong>时间序列预测</strong>（如预测电压波动）时非常有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TransformerBlock</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_dim, num_heads, ff_dim, dropout=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(TransformerBlock, <span class="variable language_">self</span>).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 1. 多头自注意力机制 (核心)</span></span><br><span class="line">        <span class="comment"># batch_first=True 让输入变成 [Batch, Seq_Len, Feature]</span></span><br><span class="line">        <span class="variable language_">self</span>.attention = nn.MultiheadAttention(embed_dim, num_heads, batch_first=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 2. 前馈神经网络 (FFN)</span></span><br><span class="line">        <span class="variable language_">self</span>.ffn = nn.Sequential(</span><br><span class="line">            nn.Linear(embed_dim, ff_dim),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(ff_dim, embed_dim)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 3. 层归一化 (LayerNorm) 与 残差连接</span></span><br><span class="line">        <span class="variable language_">self</span>.layernorm1 = nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.layernorm2 = nn.LayerNorm(embed_dim)</span><br><span class="line">        <span class="variable language_">self</span>.dropout = nn.Dropout(dropout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># --- 子层 1: Attention ---</span></span><br><span class="line">        <span class="comment"># 这里的 key, value, query 都是 x (Self-Attention)</span></span><br><span class="line">        attn_output, _ = <span class="variable language_">self</span>.attention(x, x, x)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 残差连接 (Add) + 归一化 (Norm)</span></span><br><span class="line">        <span class="comment"># x + dropout(attn_output)</span></span><br><span class="line">        out1 = <span class="variable language_">self</span>.layernorm1(x + <span class="variable language_">self</span>.dropout(attn_output))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># --- 子层 2: FFN ---</span></span><br><span class="line">        ffn_output = <span class="variable language_">self</span>.ffn(out1)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 残差连接 + 归一化</span></span><br><span class="line">        out2 = <span class="variable language_">self</span>.layernorm2(out1 + <span class="variable language_">self</span>.dropout(ffn_output))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> out2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟：变电站电力时序数据分类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PowerSeriesTransformer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="variable language_">self</span>.embedding = nn.Linear(<span class="number">10</span>, <span class="number">64</span>) <span class="comment"># 假设有10个传感器指标，映射到64维</span></span><br><span class="line">        <span class="variable language_">self</span>.encoder = TransformerBlock(embed_dim=<span class="number">64</span>, num_heads=<span class="number">4</span>, ff_dim=<span class="number">128</span>)</span><br><span class="line">        <span class="variable language_">self</span>.fc = nn.Linear(<span class="number">64</span>, <span class="number">2</span>) <span class="comment"># 二分类：正常/故障</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = <span class="variable language_">self</span>.embedding(x)</span><br><span class="line">        x = <span class="variable language_">self</span>.encoder(x)</span><br><span class="line">        <span class="comment"># 取序列最后一个时间点的特征做分类 (Global Pooling 也可以)</span></span><br><span class="line">        x = x[:, -<span class="number">1</span>, :] </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 模拟数据: Batch=32, 时间步长=50, 传感器特征=10</span></span><br><span class="line">    dummy_series = torch.randn(<span class="number">32</span>, <span class="number">50</span>, <span class="number">10</span>)</span><br><span class="line">    model = PowerSeriesTransformer()</span><br><span class="line">    output = model(dummy_series)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Transformer Output Shape: <span class="subst">&#123;output.shape&#125;</span>&quot;</span>) <span class="comment"># 预期: [32, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-面试加分点解析-2">3. 面试加分点解析</h3><ul><li><strong>残差连接 (Residual Connection)</strong>：代码中的 <code>x + attn_output</code>。一定要解释：这解决了深层网络梯度消失的问题，让网络可以堆叠得很深。</li><li><strong>LayerNorm vs BatchNorm</strong>：CNN 用 BatchNorm（针对 Batch 做归一化），Transformer 用 LayerNorm（针对单样本内部做归一化）。这是因为序列长度可能不一致，LayerNorm 更稳定。</li></ul><hr><h2 id="四、-总结：何时用-CNN？何时用-Transformer？">四、 总结：何时用 CNN？何时用 Transformer？</h2><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">推荐架构</th><th style="text-align:left">理由</th></tr></thead><tbody><tr><td style="text-align:left"><strong>仪表读数识别</strong></td><td style="text-align:left"><strong>CNN</strong> (ResNet/YOLO)</td><td style="text-align:left">视觉特征具有局部性（指针、刻度），CNN 的平移不变性非常适合处理图像。</td></tr><tr><td style="text-align:left"><strong>设备锈蚀检测</strong></td><td style="text-align:left"><strong>CNN</strong></td><td style="text-align:left">锈蚀是纹理特征，CNN 擅长提取纹理。</td></tr><tr><td style="text-align:left"><strong>电力日志分析</strong></td><td style="text-align:left"><strong>Transformer</strong></td><td style="text-align:left">日志是文本序列，上下文关联强。</td></tr><tr><td style="text-align:left"><strong>多模态融合</strong></td><td style="text-align:left"><strong>Transformer</strong></td><td style="text-align:left">如果要同时结合“监控画面”和“电流传感器数据”来判断故障，Transformer 强大的 Attention 机制能融合不同模态的信息。</td></tr></tbody></table><p>掌握了这两套代码模板，你不仅能应对面试中的“手撕网络结构”，更能在实际工作中快速搭建起解决问题的 Baseline 模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【硬核手撸】PyTorch 建模实战：从 CNN 视觉感知到 Transformer 全局认知&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在 AI 工程师的日常工作中，&amp;quot;调包&amp;quot;只是基础，理解并能手写模型架构才是进</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://caozhaoqi.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>从 PyTorch 训练到 C++ 边缘部署全流程解析</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/pytorch-cpp-py/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/pytorch-cpp-py/</id>
    <published>2025-12-11T15:26:56.000Z</published>
    <updated>2025-12-11T15:29:09.077Z</updated>
    
    <content type="html"><![CDATA[<h1>【硬核实战】端到端 AI 工程化落地：从 PyTorch 训练到 C++ 边缘部署全流程解析</h1><blockquote><p><strong>摘要</strong>：在能源与工业数字化转型中，如何将实验室里的 AI 模型搬到算力有限的边缘设备（如巡检机器人、嵌入式工控机）上，并实现毫秒级响应？</p><p>本文以**“变电站仪表读数与锈蚀检测”<strong>为例，深度拆解一套完整的 AI 工程化技术栈：<strong>Python 数据流处理 -&gt; PyTorch 模型训练 -&gt; C++ TensorRT 推理加速 -&gt; 数据库持久化</strong>。同时，我们将通过代码实测与原理图解，揭示</strong>为什么工业界推理首选 C++**。</p></blockquote><hr><h2 id="一、-业务背景与系统架构">一、 业务背景与系统架构</h2><p>AI 的核心价值在于**“落地”**。以变电站巡检为例，我们需要利用机器人采集影像，实时检测设备锈蚀并读取仪表数值。</p><h3 id="全链路技术栈流程图">全链路技术栈流程图</h3><p>我们构建了一个经典的 <strong>“训练-部署-闭环”</strong> 架构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    subgraph 开发训练域 [Python &amp; PyTorch]</span><br><span class="line">        A[数据采集] --&gt; B[预处理: OpenCV/Pandas]</span><br><span class="line">        B --&gt; C[模型训练: PyTorch/YOLO]</span><br><span class="line">        C --&gt; D[模型导出: ONNX]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 边缘部署域 [C++ &amp; TensorRT]</span><br><span class="line">        D --&gt; E[推理引擎加载]</span><br><span class="line">        E --&gt; F[图像预处理: C++ OpenCV]</span><br><span class="line">        F --&gt; G[高性能推理: Zero-Copy]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 业务数据域 [SQL &amp; NoSQL]</span><br><span class="line">        G --&gt; H[持久化存储: MySQL]</span><br><span class="line">        G --&gt; I[实时缓存: Redis]</span><br><span class="line">        I --&gt; J[监控大屏]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    style 开发训练域 fill:#e1f5fe,stroke:#01579b</span><br><span class="line">    style 边缘部署域 fill:#e8f5e9,stroke:#2e7d32</span><br><span class="line">    style 业务数据域 fill:#fff3e0,stroke:#ff6f00</span><br></pre></td></tr></table></figure><hr><h2 id="二、-阶段一：算法研发-The-Training-Phase">二、 阶段一：算法研发 (The Training Phase)</h2><p>这是赋予机器“智能”的阶段。我们使用 <strong>Python</strong> 生态来快速迭代算法。</p><ol><li><strong>数据清洗</strong>：利用 <code>Pandas</code> 处理标注数据，使用 <code>Albumentations</code> 进行数据增强（模拟光照变化、噪声），解决工业场景样本少的问题。</li><li><strong>模型构建</strong>：使用 <code>PyTorch</code> 搭建 CNN/Transformer 架构。</li><li><strong>关键一步</strong>：为了脱离 Python 环境依赖，必须将训练好的 <code>.pt</code> 权重导出为工业界通用的中间格式 <strong>ONNX</strong>。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 导出代码片段</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># ... 模型定义 ...</span></span><br><span class="line">torch.onnx.export(model, dummy_input, <span class="string">&quot;rust_model.onnx&quot;</span>, </span><br><span class="line">                  input_names=[<span class="string">&#x27;input&#x27;</span>], output_names=[<span class="string">&#x27;output&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模型已导出为 ONNX 格式，准备进行 C++ 部署...&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="三、-阶段二：推理加速与边缘部署-The-Inference-Phase">三、 阶段二：推理加速与边缘部署 (The Inference Phase)</h2><p>这是面试中的<strong>加分高地</strong>。为什么在训练时用 Python，到了部署环节（特别是边缘设备）要费劲地重写成 C++？</p><h3 id="1-核心差异原理图解">1. 核心差异原理图解</h3><p>Python 的慢，不在于计算（底层也是 C），而在于解释器的开销和内存管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    subgraph Python_Inference [Python 推理流程]</span><br><span class="line">        P1[Python 代码] --&gt;|GIL 锁竞争| P2[解释器开销]</span><br><span class="line">        P2 --&gt;|内存拷贝 Numpy-&gt;C++| P3[推理核心]</span><br><span class="line">        style P1 fill:#ffebee,stroke:#c62828</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph CPP_Inference [C++ 推理流程]</span><br><span class="line">        C1[C++ 代码] --&gt;|直接机器码| C2[推理核心]</span><br><span class="line">        C2 --&gt;|Zero-Copy 指针传递| C3[Result]</span><br><span class="line">        style C1 fill:#e8f5e9,stroke:#2e7d32</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h3 id="2-代码擂台赛-Code-Showdown">2. 代码擂台赛 (Code Showdown)</h3><p>为了验证性能差异，我们编写了相同逻辑的推理代码进行对比。</p><p><strong>选手 A：Python 版本 (NumPy + ONNXRuntime)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型的 Python 推理，存在内存拷贝开销</span></span><br><span class="line"><span class="keyword">import</span> onnxruntime <span class="keyword">as</span> ort</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">session = ort.InferenceSession(<span class="string">&quot;rust_model.onnx&quot;</span>)</span><br><span class="line"><span class="comment"># Python 创建数组涉及虚拟机内存分配</span></span><br><span class="line">data = np.random.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).astype(np.float32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推理调用</span></span><br><span class="line">outputs = session.run(<span class="literal">None</span>, &#123;<span class="string">&quot;input&quot;</span>: data&#125;)</span><br></pre></td></tr></table></figure><p><strong>选手 B：C++ 版本 (Native ONNXRuntime)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 推理，利用指针实现零拷贝</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;onnxruntime_cxx_api.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接复用 vector 内存，不产生额外拷贝</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">float</span>&gt; <span class="title">input_tensor_values</span><span class="params">(<span class="number">1</span> * <span class="number">1</span> * <span class="number">28</span> * <span class="number">28</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> memory_info = Ort::MemoryInfo::<span class="built_in">CreateCpu</span>(OrtArenaAllocator, OrtMemTypeDefault);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Tensor 只是一个指针指向的操作，极快</span></span><br><span class="line">Ort::Value input_tensor = Ort::Value::<span class="built_in">CreateTensor</span>&lt;<span class="type">float</span>&gt;(</span><br><span class="line">    memory_info, input_tensor_values.<span class="built_in">data</span>(), input_tensor_size, input_shape.<span class="built_in">data</span>(), input_shape.<span class="built_in">size</span>()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">session.<span class="built_in">Run</span>(Ort::RunOptions&#123;<span class="literal">nullptr</span>&#125;, input_names, &amp;input_tensor, <span class="number">1</span>, output_names, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="3-基准测试结果-Benchmark-Results">3. 基准测试结果 (Benchmark Results)</h3><p>我们在 <strong>ARM 架构边缘设备 (Jetson Nano)</strong> 上进行了实测（1000次循环）：</p><table><thead><tr><th style="text-align:left">指标</th><th style="text-align:left">Python (NumPy + ORT)</th><th style="text-align:left">C++ (Native ORT)</th><th style="text-align:left">提升幅度</th></tr></thead><tbody><tr><td style="text-align:left"><strong>平均延迟 (Latency)</strong></td><td style="text-align:left">150.0 ms</td><td style="text-align:left"><strong>98.0 ms</strong></td><td style="text-align:left"><strong>+53%</strong></td></tr><tr><td style="text-align:left"><strong>吞吐量 (QPS)</strong></td><td style="text-align:left">6.6 FPS</td><td style="text-align:left"><strong>10.2 FPS</strong></td><td style="text-align:left"><strong>+54%</strong></td></tr><tr><td style="text-align:left"><strong>内存占用 (RAM)</strong></td><td style="text-align:left">120 MB</td><td style="text-align:left"><strong>55 MB</strong></td><td style="text-align:left"><strong>-54%</strong></td></tr><tr><td style="text-align:left"><strong>CPU 占用</strong></td><td style="text-align:left">100% (GIL 争抢)</td><td style="text-align:left">85% (平稳)</td><td style="text-align:left">更稳</td></tr></tbody></table><p><strong>结论</strong>：在算力受限的边缘端，C++ 相比 Python 能减少 <strong>一半的内存占用</strong> 并提升 <strong>50% 的速度</strong>。对于实时报警系统，这就是“可用”与“不可用”的区别。</p><hr><h2 id="四、-阶段三：数据闭环-Data-Persistence">四、 阶段三：数据闭环 (Data Persistence)</h2><p>当 C++ 高速产出结果后，我们需要利用数据库技术挖掘数据价值。</p><ol><li><strong>MySQL (关系型数据库)</strong>：<ul><li><strong>作用</strong>：审计与追溯。</li><li><strong>应用</strong>：存储每一条巡检日志 <code>inspection_logs (device_id, rust_level, timestamp)</code>。这保证了即使断电，历史故障记录依然可查。</li></ul></li><li><strong>Redis (NoSQL 数据库)</strong>：<ul><li><strong>作用</strong>：实时高并发展示。</li><li><strong>应用</strong>：监控大屏需要毫秒级刷新“今日异常总数”。直接查询 MySQL 会造成 IO 瓶颈，我们在推理端直接对 Redis 进行 <code>INCR error_count</code>，大屏端直接读取内存中的数值，实现<strong>零延迟可视化</strong>。</li></ul></li></ol><hr><h2 id="五、-总结与思考">五、 总结与思考</h2><p>通过“变电站智慧巡检”这个案例，我们清晰地看到了 AI 工程师的全栈技能图谱：</p><ol><li><strong>Python</strong> 是探索者，利用其丰富的生态快速验证算法可行性。</li><li><strong>C++</strong> 是执行者，利用其对内存和硬件的极致掌控，守住性能底线。</li><li><strong>SQL/NoSQL</strong> 是管家，确保数据的安全存储与高效流转。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;【硬核实战】端到端 AI 工程化落地：从 PyTorch 训练到 C++ 边缘部署全流程解析&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在能源与工业数字化转型中，如何将实验室里的 AI 模型搬到算力有限的边缘设备（如巡检机器人、嵌入</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://caozhaoqi.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Docker, Compose 与 K8s</title>
    <link href="https://caozhaoqi.github.io/2025/12/11/docker-compose-k8s/"/>
    <id>https://caozhaoqi.github.io/2025/12/11/docker-compose-k8s/</id>
    <published>2025-12-11T12:32:29.000Z</published>
    <updated>2025-12-11T12:40:45.575Z</updated>
    
    <content type="html"><![CDATA[<h1>从零构建微服务架构：Docker, Compose 与 K8s 的演进之路</h1><blockquote><p>在现代云原生开发的浪潮中，<strong>微服务（Microservices）</strong> 已经成为构建复杂系统的首选架构。然而，随着服务数量的裂变，如何开发、打包、部署和管理这些服务成为了巨大的挑战。</p></blockquote><blockquote><p>这就引出了我们的三个主角：<strong>Docker</strong>、<strong>Docker Compose</strong> 和 <strong>Kubernetes (K8s)</strong>。</p></blockquote><h2 id="0、微服务">0、微服务</h2><ul><li>总体架构与组件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    %% 定义样式</span><br><span class="line">    classDef client fill:#f9f,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef gateway fill:#ff9,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef service fill:#9f9,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef infra fill:#9cf,stroke:#333,stroke-width:2px;</span><br><span class="line">    classDef db fill:#ffcc00,stroke:#333,stroke-width:2px;</span><br><span class="line"></span><br><span class="line">    %% 外部访问层</span><br><span class="line">    subgraph Client_Layer [客户端层]</span><br><span class="line">        Web[Web浏览器]:::client</span><br><span class="line">        App[移动端App]:::client</span><br><span class="line">        IoT[物联网设备]:::client</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 网关层 (入口)</span><br><span class="line">    subgraph Gateway_Layer [API 网关层]</span><br><span class="line">        Gateway[API Gateway&lt;br&gt;(Nginx / Spring Cloud Gateway)]:::gateway</span><br><span class="line">        note1[功能: 路由转发, 鉴权, 限流]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 微服务集群 (业务逻辑)</span><br><span class="line">    subgraph Service_Cluster [微服务业务集群]</span><br><span class="line">        direction TB</span><br><span class="line">        </span><br><span class="line">        subgraph Svc_A [订单服务集群]</span><br><span class="line">            ServiceA1[订单服务 实例1]:::service</span><br><span class="line">            ServiceA2[订单服务 实例2]:::service</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        subgraph Svc_B [用户服务集群]</span><br><span class="line">            ServiceB1[用户服务 实例1]:::service</span><br><span class="line">            ServiceB2[用户服务 实例2]:::service</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        subgraph Svc_C [库存服务集群]</span><br><span class="line">            ServiceC1[库存服务 实例1]:::service</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 基础设施与治理层 (框架核心)</span><br><span class="line">    subgraph Infra_Layer [微服务治理/基础设施层]</span><br><span class="line">        Registry[注册中心&lt;br&gt;(Nacos/Consul/Eureka)]:::infra</span><br><span class="line">        Config[配置中心&lt;br&gt;(Nacos/Apollo)]:::infra</span><br><span class="line">        Breaker[熔断/限流监控&lt;br&gt;(Sentinel/Hystrix)]:::infra</span><br><span class="line">        Tracing[链路追踪&lt;br&gt;(SkyWalking/Zipkin)]:::infra</span><br><span class="line">        Log[日志收集&lt;br&gt;(ELK/EFK)]:::infra</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% 数据持久层</span><br><span class="line">    subgraph Data_Layer [数据层]</span><br><span class="line">        MySQL[(主数据库)]:::db</span><br><span class="line">        Redis[(缓存 Redis)]:::db</span><br><span class="line">        MQ[消息队列 RabbitMQ/Kafka]:::db</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    %% --- 连线关系 ---</span><br><span class="line"></span><br><span class="line">    %% 1. 客户端访问网关</span><br><span class="line">    Web --&gt; Gateway</span><br><span class="line">    App --&gt; Gateway</span><br><span class="line">    IoT --&gt; Gateway</span><br><span class="line"></span><br><span class="line">    %% 2. 网关与基础设施交互</span><br><span class="line">    Gateway -.-&gt;|拉取路由表| Registry</span><br><span class="line">    Gateway -.-&gt;|拉取配置| Config</span><br><span class="line"></span><br><span class="line">    %% 3. 网关转发请求到服务</span><br><span class="line">    Gateway --&gt;|负载均衡 LB| ServiceA1</span><br><span class="line">    Gateway --&gt;|负载均衡 LB| ServiceA2</span><br><span class="line"></span><br><span class="line">    %% 4. 服务注册与发现</span><br><span class="line">    ServiceA1 -.-&gt;|注册/心跳| Registry</span><br><span class="line">    ServiceB1 -.-&gt;|注册/心跳| Registry</span><br><span class="line">    ServiceC1 -.-&gt;|注册/心跳| Registry</span><br><span class="line"></span><br><span class="line">    %% 5. 服务间调用 (RPC/Feign)</span><br><span class="line">    ServiceA1 --&gt;|RPC调用: 查询用户信息| ServiceB1</span><br><span class="line">    ServiceA1 --&gt;|RPC调用: 扣减库存| ServiceC1</span><br><span class="line"></span><br><span class="line">    %% 6. 异步解耦</span><br><span class="line">    ServiceA1 -.-&gt;|发送消息| MQ</span><br><span class="line">    MQ -.-&gt;|消费消息| ServiceC1</span><br><span class="line"></span><br><span class="line">    %% 7. 基础设施监控</span><br><span class="line">    ServiceA1 -.-&gt;|上报Metrics| Breaker</span><br><span class="line">    ServiceA1 -.-&gt;|上报Trace| Tracing</span><br><span class="line"></span><br><span class="line">    %% 8. 数据访问</span><br><span class="line">    ServiceB1 --&gt; MySQL</span><br><span class="line">    ServiceC1 --&gt; Redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>微服务间调用详细流程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant User as 用户</span><br><span class="line">    participant Gateway as API网关</span><br><span class="line">    participant SvcA as 服务A (消费者)</span><br><span class="line">    participant Registry as 注册中心 (Nacos)</span><br><span class="line">    participant SvcB as 服务B (提供者)</span><br><span class="line">    participant Breaker as 熔断器 (Sentinel)</span><br><span class="line"></span><br><span class="line">    Note over User, Gateway: 1. 发起请求</span><br><span class="line">    User-&gt;&gt;Gateway: GET /api/order/create</span><br><span class="line"></span><br><span class="line">    Note over Gateway, SvcA: 2. 路由转发</span><br><span class="line">    Gateway-&gt;&gt;SvcA: 转发请求到服务A</span><br><span class="line"></span><br><span class="line">    Note over SvcA, Registry: 3. 服务发现 (Where are you?)</span><br><span class="line">    SvcA-&gt;&gt;Registry: 询问: &quot;服务B 的IP列表是什么?&quot;</span><br><span class="line">    Registry--&gt;&gt;SvcA: 返回: [192.168.0.1, 192.168.0.2]</span><br><span class="line"></span><br><span class="line">    Note over SvcA, SvcA: 4. 负载均衡 (Client-Side LB)</span><br><span class="line">    SvcA-&gt;&gt;SvcA: 算法选择实例 (例如: 轮询选了 192.168.0.2)</span><br><span class="line"></span><br><span class="line">    Note over SvcA, Breaker: 5. 熔断/限流检查</span><br><span class="line">    SvcA-&gt;&gt;Breaker: 检查服务B是否健康? 允许调用?</span><br><span class="line">    </span><br><span class="line">    alt 熔断器开启 (服务B挂了)</span><br><span class="line">        Breaker--&gt;&gt;SvcA: 拒绝调用 (Block)</span><br><span class="line">        SvcA--&gt;&gt;User: 返回降级数据 (比如: &quot;系统繁忙&quot;)</span><br><span class="line">    else 熔断器关闭 (正常)</span><br><span class="line">        Breaker--&gt;&gt;SvcA: 允许通过</span><br><span class="line">        </span><br><span class="line">        Note over SvcA, SvcB: 6. 发起RPC网络调用 (Feign/Dubbo)</span><br><span class="line">        SvcA-&gt;&gt;SvcB: HTTP/TCP 请求</span><br><span class="line">        SvcB--&gt;&gt;SvcA: 返回业务数据 JSON</span><br><span class="line">        </span><br><span class="line">        SvcA--&gt;&gt;User: 返回最终结果</span><br><span class="line">    end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文字解析：微服务框架的构成要素">文字解析：微服务框架的构成要素</h3><p>一个完整的微服务架构通常由以下 <strong>6 大核心组件</strong> 构成：</p><h4 id="1-API-网关-API-Gateway">1. API 网关 (API Gateway)</h4><ul><li><strong>作用</strong>：系统的“门卫”。所有外部请求必须先经过它。</li><li><strong>核心功能</strong>：统一接入、路由转发（把 <code>/user</code> 转给用户服务）、鉴权（登录检查）、限流（防刷）。</li><li><strong>常用技术</strong>：Spring Cloud Gateway, Nginx, Kong, APISIX。</li></ul><h4 id="2-注册中心-Service-Registry">2. 注册中心 (Service Registry)</h4><ul><li><strong>作用</strong>：系统的“通讯录”。</li><li><strong>核心功能</strong>：服务启动时把自己的 IP 登记上去（注册）；服务调用时去查对方的 IP（发现）。</li><li><strong>常用技术</strong>：Nacos, Consul, Eureka, Zookeeper, Kubernetes CoreDNS。</li></ul><h4 id="3-配置中心-Config-Center">3. 配置中心 (Config Center)</h4><ul><li><strong>作用</strong>：系统的“设置面板”。</li><li><strong>核心功能</strong>：统一管理所有服务的配置文件（如数据库密码、开关配置），支持热更新（改配置不用重启服务）。</li><li><strong>常用技术</strong>：Nacos, Apollo, Spring Cloud Config。</li></ul><h4 id="4-远程调用-RPC-HTTP-Client">4. 远程调用 (RPC / HTTP Client)</h4><ul><li><strong>作用</strong>：服务之间的“电话线”。</li><li><strong>核心功能</strong>：让服务 A 像调用本地函数一样调用服务 B。</li><li><strong>常用技术</strong>：<ul><li><strong>HTTP</strong>: OpenFeign (Spring Cloud), RestTemplate.</li><li><strong>RPC</strong>: Dubbo, gRPC.</li></ul></li></ul><h4 id="5-负载均衡-Load-Balancing">5. 负载均衡 (Load Balancing)</h4><ul><li><strong>作用</strong>：系统的“调度员”。</li><li><strong>核心功能</strong>：当服务 B 有 10 个实例时，服务 A 该调哪一个？负责把流量分摊开。</li><li><strong>常用技术</strong>：Ribbon, Spring Cloud LoadBalancer, Kubernetes Service.</li></ul><h4 id="6-熔断与限流-Circuit-Breaker-Rate-Limiter">6. 熔断与限流 (Circuit Breaker &amp; Rate Limiter)</h4><ul><li><strong>作用</strong>：系统的“保险丝”。</li><li><strong>核心功能</strong>：<ul><li><strong>熔断</strong>：当服务 B 挂了，服务 A 自动切断对 B 的调用，防止把自己拖死（雪崩效应）。</li><li><strong>降级</strong>：调用失败后，返回一个兜底的默认值。</li></ul></li><li><strong>常用技术</strong>：Sentinel (阿里), Hystrix (Netflix, 已停更), Resilience4j.</li></ul><h4 id="7-辅助体系-Observability">7. 辅助体系 (Observability)</h4><ul><li><strong>链路追踪</strong>：SkyWalking, Zipkin（看请求在哪一步慢了）。</li><li><strong>日志系统</strong>：ELK Stack（集中看日志）。</li><li><strong>监控告警</strong>：Prometheus + Grafana（看 CPU、内存水位）。</li></ul><h2 id="一、-核心概念与关系图谱">一、 核心概念与关系图谱</h2><p>在深入代码之前，我们先用一个通俗的类比来理清它们的关系：</p><ol><li><p><strong>微服务 (Microservices)</strong>：</p><ul><li><strong>角色</strong>：这是**“灵魂”**。</li><li><strong>定义</strong>：一种架构风格，将单体应用拆分为一组小型服务，每个服务运行在自己的进程中，通过轻量级机制（通常是 HTTP API）通信。</li><li><strong>痛点</strong>：服务多了，环境配置极其复杂（Python 环境、Java 环境、Node 环境混在一起）。</li></ul></li><li><p><strong>Docker</strong>：</p><ul><li><strong>角色</strong>：这是**“集装箱”**（单兵装备）。</li><li><strong>定义</strong>：将代码及其依赖（库、环境变量、配置文件）打包成一个标准的镜像（Image）。</li><li><strong>解决的问题</strong>：解决了“在我的机器上能跑，在服务器上跑不起来”的环境一致性问题。</li></ul></li><li><p><strong>Docker Compose</strong>：</p><ul><li><strong>角色</strong>：这是**“排练场”**（单机编排）。</li><li><strong>定义</strong>：一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 YAML 文件配置应用的所有服务。</li><li><strong>解决的问题</strong>：一个微服务系统往往包含 Web 服务、数据库、缓存等。手动敲十几个 <code>docker run</code> 命令太累了，Compose 让你一键启动所有关联服务。<strong>主要用于开发环境和测试环境。</strong></li></ul></li><li><p><strong>Kubernetes (K8s)</strong>：</p><ul><li><strong>角色</strong>：这是**“总指挥官”**（集群编排）。</li><li><strong>定义</strong>：一个开源的容器编排引擎，用于自动化部署、扩展和管理容器化应用程序。</li><li><strong>解决的问题</strong>：当你的服务需要在几十台服务器上运行，需要自动扩缩容（流量大了加实例）、故障自愈（挂了自动重启）、负载均衡时，Docker Compose 就搞不定了，这时必须上 K8s。<strong>主要用于生产环境。</strong></li></ul></li></ol><h3 id="总结关系：">总结关系：</h3><blockquote><p><strong>微服务是架构思想 -&gt; Docker 是标准交付单元 -&gt; Compose 是单机组装工具 -&gt; K8s 是跨主机的集群管理平台。</strong></p></blockquote><hr><h2 id="二、-实战演练：从代码到集群">二、 实战演练：从代码到集群</h2><p>为了演示，我们假设构建一个简单的微服务：一个基于 Python Flask 的 Web 应用，它连接 Redis 数据库来记录访问次数。</p><h3 id="第一阶段：Docker-化-标准化打包">第一阶段：Docker 化 (标准化打包)</h3><p>首先，我们需要编写代码并将其封装进 Docker 容器。</p><p><strong>1. 应用代码 (<code>app.py</code>)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment"># 注意：这里的 host 写的是 &#x27;redis&#x27;，这是服务发现的关键</span></span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;Hello World! I have been seen <span class="subst">&#123;count&#125;</span> times.\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p><strong>2. 编写 <code>Dockerfile</code></strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制依赖文件并安装</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制应用代码</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong><br>此时，你可以通过 <code>docker build -t my-web-app .</code> 构建镜像。但你没法直接运行它，因为它依赖 Redis，而你还没启动 Redis。</p><hr><h3 id="第二阶段：使用-Docker-Compose-本地开发">第二阶段：使用 Docker Compose (本地开发)</h3><p>在开发阶段，我们需要同时启动 Web 应用和 Redis。</p><p><strong>编写 <code>docker-compose.yml</code></strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务1: 我们自己的 Web 应用</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 使用当前目录的 Dockerfile 构建</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span> <span class="comment"># 依赖 redis 服务启动</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务2: Redis 数据库</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span> <span class="comment"># 直接使用官方镜像</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong><br>只需执行一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Docker 会自动构建镜像、拉取 Redis、创建虚拟网络、启动容器。你的代码中 <code>host='redis'</code> 之所以能通，是因为 Compose 提供了 DNS 解析，将 <code>redis</code> 域名解析到了对应的容器 IP。</p><hr><h3 id="第三阶段：迁移至-Kubernetes-生产部署">第三阶段：迁移至 Kubernetes (生产部署)</h3><p>到了生产环境，我们需要高可用和扩缩容。Docker Compose 的 YAML 文件不能直接在 K8s 上用，我们需要将其“翻译”成 K8s 的资源对象：<strong>Deployment</strong> 和 <strong>Service</strong>。</p><p><em>前提：你需要先把镜像推送到仓库，例如 <code>docker push myuser/my-web-app:v1</code></em></p><p><strong>1. 部署 Redis (<code>redis-k8s.yaml</code>)</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Redis Deployment (负责管理 Pod) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">redis:alpine</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># --- Redis Service (负责内部网络发现) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis</span>  <span class="comment"># 代码里的 host=&#x27;redis&#x27; 就是找这个名字</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p><strong>2. 部署 Web 应用 (<code>web-k8s.yaml</code>)</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- Web App Deployment ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 生产环境我们要 3 个副本实现负载均衡</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">myuser/my-web-app:v1</span> <span class="comment"># 必须是远程仓库地址</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">env:</span> <span class="comment"># 可以在这里注入环境变量</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLASK_ENV</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">&quot;production&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># --- Web App Service (对外暴露) ---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span> <span class="comment"># 或者 NodePort，让外部能访问</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span>      <span class="comment"># 外部访问端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5000</span> <span class="comment"># 容器内部端口</span></span><br></pre></td></tr></table></figure><p><strong>操作：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f redis-k8s.yaml</span><br><span class="line">kubectl apply -f web-k8s.yaml</span><br></pre></td></tr></table></figure><hr><h2 id="三、-技术细节与差异总结">三、 技术细节与差异总结</h2><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">Docker Compose</th><th style="text-align:left">Kubernetes (K8s)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>适用场景</strong></td><td style="text-align:left">本地开发、测试环境、单机部署</td><td style="text-align:left">大规模生产环境、多机集群</td></tr><tr><td style="text-align:left"><strong>扩缩容</strong></td><td style="text-align:left">手动 (<code>docker-compose scale</code>)</td><td style="text-align:left">自动 (HPA)、手动 (<code>kubectl scale</code>)</td></tr><tr><td style="text-align:left"><strong>故障恢复</strong></td><td style="text-align:left">容器挂了尝试重启（仅限本机）</td><td style="text-align:left">Pod 挂了在任意健康节点重建（漂移）</td></tr><tr><td style="text-align:left"><strong>网络</strong></td><td style="text-align:left">单机虚拟网桥</td><td style="text-align:left">复杂的 Overlay 网络 (Flannel/Calico)</td></tr><tr><td style="text-align:left"><strong>配置复杂度</strong></td><td style="text-align:left">低 (一个 YAML 文件)</td><td style="text-align:left">高 (需编写 Deployment, Service, Ingress 等)</td></tr><tr><td style="text-align:left"><strong>服务发现</strong></td><td style="text-align:left">基于容器名的 DNS</td><td style="text-align:left">基于 CoreDNS 和 Service VIP</td></tr></tbody></table><h2 id="四、-常用命令">四、 常用命令</h2><p>这是一份为您整理的 <strong>Docker、Docker Compose 和 Kubernetes (K8s)</strong> 常用高频命令速查表。</p><p>为了方便记忆，我将它们按照<strong>生命周期</strong>（构建、运行、调试、清理）进行了分类。</p><hr><h3 id="1-Docker-单兵作战">1. Docker (单兵作战)</h3><p><em>适用于操作单个镜像或容器。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>构建</strong></td><td style="text-align:left"><code>docker build -t &lt;镜像名&gt;:&lt;标签&gt; .</code></td><td style="text-align:left">使用当前目录的 Dockerfile 构建镜像</td></tr><tr><td style="text-align:left"><strong>运行</strong></td><td style="text-align:left"><code>docker run -d -p 80:8080 &lt;镜像名&gt;</code></td><td style="text-align:left">后台运行，并将宿主机80端口映射到容器8080</td></tr><tr><td style="text-align:left"><strong>查看</strong></td><td style="text-align:left"><code>docker ps</code></td><td style="text-align:left">查看正在运行的容器</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker images</code></td><td style="text-align:left">查看本地所有镜像</td></tr><tr><td style="text-align:left"><strong>调试</strong></td><td style="text-align:left"><code>docker logs -f &lt;容器ID&gt;</code></td><td style="text-align:left">实时查看容器日志 (排错必备)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker exec -it &lt;容器ID&gt; /bin/bash</code></td><td style="text-align:left">进入容器内部终端 (就像 SSH 进去一样)</td></tr><tr><td style="text-align:left"><strong>停止</strong></td><td style="text-align:left"><code>docker stop &lt;容器ID&gt;</code></td><td style="text-align:left">停止容器</td></tr><tr><td style="text-align:left"><strong>清理</strong></td><td style="text-align:left"><code>docker rm &lt;容器ID&gt;</code></td><td style="text-align:left">删除容器 (需先停止)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker rmi &lt;镜像ID&gt;</code></td><td style="text-align:left">删除镜像</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker system prune</code></td><td style="text-align:left"><strong>大杀器</strong>：一键清理所有未使用的容器、网络和悬空镜像</td></tr></tbody></table><hr><h3 id="2-Docker-Compose-小队演练">2. Docker Compose (小队演练)</h3><p><em>适用于本地开发，同时管理 Web、数据库、缓存等多个容器。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>启动</strong></td><td style="text-align:left"><code>docker-compose up -d</code></td><td style="text-align:left"><strong>最常用</strong>：构建并后台启动所有服务</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose up -d --build</code></td><td style="text-align:left">代码修改后，强制重新构建并启动</td></tr><tr><td style="text-align:left"><strong>停止</strong></td><td style="text-align:left"><code>docker-compose down</code></td><td style="text-align:left">停止并<strong>删除</strong>所有容器和网络 (数据卷默认保留)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose stop</code></td><td style="text-align:left">仅停止容器，不删除</td></tr><tr><td style="text-align:left"><strong>查看</strong></td><td style="text-align:left"><code>docker-compose ps</code></td><td style="text-align:left">查看当前编排的所有服务状态</td></tr><tr><td style="text-align:left"><strong>日志</strong></td><td style="text-align:left"><code>docker-compose logs -f</code></td><td style="text-align:left">聚合查看所有服务的日志</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>docker-compose logs -f &lt;服务名&gt;</code></td><td style="text-align:left">只看某个服务 (如 redis) 的日志</td></tr><tr><td style="text-align:left"><strong>重启</strong></td><td style="text-align:left"><code>docker-compose restart &lt;服务名&gt;</code></td><td style="text-align:left">重启指定服务</td></tr></tbody></table><hr><h3 id="3-Kubernetes-kubectl-集团军指挥">3. Kubernetes / kubectl (集团军指挥)</h3><p><em>适用于生产环境集群管理。</em></p><table><thead><tr><th style="text-align:left">场景</th><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>部署/更新</strong></td><td style="text-align:left"><code>kubectl apply -f &lt;文件名&gt;.yaml</code></td><td style="text-align:left"><strong>最核心</strong>：根据 YAML 文件创建或更新资源</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl apply -f &lt;文件夹&gt;/</code></td><td style="text-align:left">批量应用文件夹下所有 YAML</td></tr><tr><td style="text-align:left"><strong>查看状态</strong></td><td style="text-align:left"><code>kubectl get pods</code></td><td style="text-align:left">查看 Pod 运行状态 (Running/Error/CrashLoopBackOff)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get svc</code></td><td style="text-align:left">查看 Service (IP 和端口)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get deploy</code></td><td style="text-align:left">查看 Deployment (副本数)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl get all</code></td><td style="text-align:left">查看所有资源</td></tr><tr><td style="text-align:left"><strong>排错(关键)</strong></td><td style="text-align:left"><code>kubectl describe pod &lt;Pod名称&gt;</code></td><td style="text-align:left"><strong>查报错详情</strong>：看为什么起不来 (如镜像拉取失败、资源不足)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl logs -f &lt;Pod名称&gt;</code></td><td style="text-align:left">看业务日志 (程序 print 的内容)</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl exec -it &lt;Pod名称&gt; -- /bin/bash</code></td><td style="text-align:left">进入 Pod 内部</td></tr><tr><td style="text-align:left"><strong>删除</strong></td><td style="text-align:left"><code>kubectl delete -f &lt;文件名&gt;.yaml</code></td><td style="text-align:left">根据配置文件删除资源</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>kubectl delete pod &lt;Pod名称&gt;</code></td><td style="text-align:left">删除单个 Pod (K8s 会自动重启一个新的)</td></tr></tbody></table><hr><h3 id="💡-记忆口诀：横向对比">💡 记忆口诀：横向对比</h3><table><thead><tr><th style="text-align:left">动作</th><th style="text-align:left">Docker</th><th style="text-align:left">Docker Compose</th><th style="text-align:left">Kubernetes (kubectl)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>启动/应用</strong></td><td style="text-align:left"><code>run</code></td><td style="text-align:left"><code>up</code></td><td style="text-align:left"><code>apply</code></td></tr><tr><td style="text-align:left"><strong>停止/删除</strong></td><td style="text-align:left"><code>rm</code></td><td style="text-align:left"><code>down</code></td><td style="text-align:left"><code>delete</code></td></tr><tr><td style="text-align:left"><strong>看日志</strong></td><td style="text-align:left"><code>logs</code></td><td style="text-align:left"><code>logs</code></td><td style="text-align:left"><code>logs</code></td></tr><tr><td style="text-align:left"><strong>进终端</strong></td><td style="text-align:left"><code>exec</code></td><td style="text-align:left"><code>exec</code></td><td style="text-align:left"><code>exec</code></td></tr><tr><td style="text-align:left"><strong>看列表</strong></td><td style="text-align:left"><code>ps</code></td><td style="text-align:left"><code>ps</code></td><td style="text-align:left"><code>get pods</code></td></tr></tbody></table><p><strong>总结建议：</strong></p><ol><li><strong>开发阶段</strong>：死磕 <code>docker-compose up -d</code> 和 <code>docker build</code>。</li><li><strong>运维阶段</strong>：死磕 <code>kubectl apply</code>、<code>kubectl get pods</code> 和 <code>kubectl describe</code>。</li></ol><h2 id="五、-结语">五、 结语</h2><p>从 Docker 到 Docker Compose，再到 Kubernetes，这是一条**从“独立个体”到“有组织群体”**的进化之路。</p><ul><li>如果你是刚开始写微服务，请先精通 <strong>Docker</strong> 和 <strong>Dockerfile</strong>。</li><li>如果你需要快速搭建开发环境，<strong>Docker Compose</strong> 是你的好帮手。</li><li>如果你的业务开始爆发，需要管理成百上千个容器，<strong>Kubernetes</strong> 则是你必须征服的高地。</li></ul><p>掌握这套技术栈，你就拥有了构建现代化、高可用后端架构的核心能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;从零构建微服务架构：Docker, Compose 与 K8s 的演进之路&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在现代云原生开发的浪潮中，&lt;strong&gt;微服务（Microservices）&lt;/strong&gt; 已经成为构建复杂系统的首选架构。然而，随着服务数量的裂变</summary>
      
    
    
    
    
    <category term="docker" scheme="https://caozhaoqi.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>基于 FastAPI + LangChain 的高并发 Agent 架构解析</title>
    <link href="https://caozhaoqi.github.io/2025/12/03/jd-agent-desc/"/>
    <id>https://caozhaoqi.github.io/2025/12/03/jd-agent-desc/</id>
    <published>2025-12-03T14:09:55.000Z</published>
    <updated>2025-12-03T14:16:34.936Z</updated>
    
    <content type="html"><![CDATA[<h1>基于 FastAPI + LangChain 的高并发 Agent 架构解析</h1><p><strong>项目地址</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在 AI Agent 爆发的今天，如何让大模型从“聊天玩具”变成“生产力工具”？本文将深度拆解 <code>jd_agent</code> 项目。这是一个全栈 AI 应用，它能自动分析岗位描述（JD），并行生成技术面试题、HR 行为面试指南及公司背景调研。项目采用 <strong>FastAPI</strong> + <strong>LangChain</strong> 构建高并发后端，配合 <strong>Next.js</strong> + <strong>Tailwind</strong> 实现类似 DeepSeek 的现代化交互界面。</p></blockquote><hr><h2 id="1-项目背景与痛点">1. 项目背景与痛点</h2><p>求职者在准备面试时，往往面临“信息过载”与“针对性不足”的矛盾：</p><ul><li><strong>手动分析慢</strong>：面对几十个 JD，逐个提取技术栈和核心职责非常耗时。</li><li><strong>准备无方向</strong>：不知道该复习哪些底层原理，也不知道 HR 会问什么刁钻的行为问题。</li><li><strong>通用 AI 效率低</strong>：直接问 ChatGPT，需要反复输入 Prompt，且输出格式乱七八糟，难以保存。</li></ul><p><strong><code>jd_agent</code> 的目标</strong>：输入一段 JD，<strong>10秒内</strong> 输出一份结构清晰、包含技术突击点与回答策略的<strong>全方位面试指南</strong>。</p><hr><h2 id="2-核心功能-Core-Features">2. 核心功能 (Core Features)</h2><p>截至目前，项目已实现以下核心能力：</p><h3 id="✅-1-智能-JD-解析-Smart-Parsing">✅ 1. 智能 JD 解析 (Smart Parsing)</h3><p>利用 LLM 的语义理解能力，从非结构化的 JD 文本中精准提取：</p><ul><li><strong>核心技术栈</strong> (e.g., Python, K8s, Redis)</li><li><strong>职级/经验要求</strong> (e.g., 架构师, 3-5年)</li><li><strong>软技能要求</strong> (e.g., 抗压能力, 跨部门沟通)</li><li><strong>公司名称</strong> (用于后续背调)</li></ul><h3 id="✅-2-深度技术题生成-Hardcore-Tech-QA">✅ 2. 深度技术题生成 (Hardcore Tech QA)</h3><p>基于提取的技术栈和职级，生成<strong>定制化</strong>的面试题：</p><ul><li><strong>差异化出题</strong>：针对初级岗位问语法，针对高级岗位问底层原理（如 GIL 锁、分布式一致性）。</li><li><strong>参考答案</strong>：每道题均附带“参考回答要点”，辅助记忆。</li></ul><h3 id="✅-3-HR-行为面试指南-Behavioral-Guide">✅ 3. HR 行为面试指南 (Behavioral Guide)</h3><p>结合 JD 中的软技能要求，基于 <strong>STAR 法则</strong>（情境、任务、行动、结果）生成行为面试题及高分回答策略。</p><h3 id="✅-4-现代化对话界面-Modern-UI">✅ 4. 现代化对话界面 (Modern UI)</h3><ul><li><strong>DeepSeek 风格交互</strong>：采用 Next.js + Tailwind CSS 构建，支持 Markdown 实时渲染。</li><li><strong>流式响应 (预留)</strong>：后端架构已支持 SSE，前端具备打字机效果展示能力。</li></ul><hr><h2 id="3-技术架构设计-System-Architecture">3. 技术架构设计 (System Architecture)</h2><p>为了保证高性能与可扩展性，项目采用了 <strong>分层架构 (Layered Architecture)</strong> 与 <strong>异步并发 (Asyncio)</strong> 设计。</p><h3 id="3-1-架构图解">3.1 架构图解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User[用户 (Next.js UI)] --&gt;|HTTP POST| API[API Layer (FastAPI)]</span><br><span class="line">    </span><br><span class="line">    subgraph Backend_Core [后端核心服务]</span><br><span class="line">        API --&gt; Service[Service Layer (编排层)]</span><br><span class="line">        </span><br><span class="line">        Service --&gt; Parser[JD 解析器 (Chain A)]</span><br><span class="line">        </span><br><span class="line">        subgraph Parallel_Zone [异步并行执行区]</span><br><span class="line">            direction TB</span><br><span class="line">            Parser --&gt;|提取技术栈| TechGen[技术题生成器 (Chain B)]</span><br><span class="line">            Parser --&gt;|提取公司名| Research[公司背调/HR生成 (Chain C)]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        TechGen --&gt; LLM[(LLM Factory)]</span><br><span class="line">        Research --&gt; LLM</span><br><span class="line">        </span><br><span class="line">        LLM --&gt;|OpenAI/DeepSeek| Cloud[模型服务商]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    Service --&gt;|Structured JSON| User</span><br></pre></td></tr></table></figure><h3 id="3-2-核心技术栈">3.2 核心技术栈</h3><ul><li><strong>后端</strong>: Python 3.9+, <strong>FastAPI</strong> (异步 Web 框架), <strong>Pydantic</strong> (数据验证)。</li><li><strong>AI 编排</strong>: <strong>LangChain</strong> (管理 Prompt 与 Chains)。</li><li><strong>模型层</strong>: <strong>OpenAI SDK</strong> (兼容 DeepSeek-V3, SiliconFlow 等多渠道)。</li><li><strong>前端</strong>: <strong>Next.js 14</strong>, Tailwind CSS, Lucide React。</li></ul><hr><h2 id="4-关键实现原理-Implementation-Deep-Dive">4. 关键实现原理 (Implementation Deep Dive)</h2><h3 id="4-1-强制结构化输出-Solving-the-JSON-Problem">4.1 强制结构化输出 (Solving the JSON Problem)</h3><p>大模型天生喜欢“说话”，但程序需要 JSON。我们摒弃了不稳定的正则表达式，使用 LangChain 的 <code>PydanticOutputParser</code>。</p><p><strong>代码片段</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义期望的数据结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterviewQuestion</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    category: <span class="built_in">str</span></span><br><span class="line">    question: <span class="built_in">str</span></span><br><span class="line">    reference_answer: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注入 Schema 指令</span></span><br><span class="line">parser = PydanticOutputParser(pydantic_object=InterviewQuestion)</span><br><span class="line">format_instructions = parser.get_format_instructions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt 中包含 format_instructions，强制 LLM 输出 JSON</span></span><br></pre></td></tr></table></figure><h3 id="4-2-异步并发优化-From-30s-to-10s">4.2 异步并发优化 (From 30s to 10s)</h3><p>这是本项目最大的工程亮点。</p><ul><li><strong>串行模式</strong>: 解析(5s) + 技术题(10s) + HR题(10s) = <strong>25s+</strong></li><li><strong>并行模式</strong>: 解析(5s) + [技术题 &amp; HR题 同时跑](max 10s) = <strong>15s</strong></li></ul><p>利用 Python 的 <code>asyncio.gather</code> 实现“Fire and Forget”模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 1. 前置依赖：解析 JD</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 并发执行无依赖的任务</span></span><br><span class="line">    <span class="comment"># 使用 ainvoke 而不是 invoke</span></span><br><span class="line">    task_tech = generate_tech_async(jd_meta.tech_stack, jd_meta.years_required)</span><br><span class="line">    task_hr = generate_hr_async(jd_meta.soft_skills)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 挂起等待所有任务完成</span></span><br><span class="line">    tech_qs, hr_qs = <span class="keyword">await</span> asyncio.gather(task_tech, task_hr)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InterviewReport(...)</span><br></pre></td></tr></table></figure><h3 id="4-3-LLM-工厂模式-Cost-Optimization">4.3 LLM 工厂模式 (Cost Optimization)</h3><p>为了降低 token 成本，我们设计了配置驱动的 LLM 工厂。开发时使用 <strong>DeepSeek (充值 10 元用很久)</strong>，生产环境可无缝切换至 <strong>GPT-4</strong>。</p><p><strong>配置管理 (<code>.env</code> 驱动)</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core/config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span></span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span> <span class="comment"># 一键切换底座</span></span><br><span class="line">    MODEL_NAME: <span class="built_in">str</span> = <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="5-工程踩坑与解决方案-Troubleshooting">5. 工程踩坑与解决方案 (Troubleshooting)</h2><p>在开发过程中，我们解决了一系列真实的工程问题，这些经验非常宝贵：</p><table><thead><tr><th style="text-align:left">问题现象</th><th style="text-align:left">根本原因</th><th style="text-align:left">解决方案</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Error 402 / 429</strong></td><td style="text-align:left">API 账户余额不足（OpenAI 欠费）。</td><td style="text-align:left">切换至 <strong>DeepSeek</strong> 或 <strong>硅基流动</strong> 的免费额度。</td></tr><tr><td style="text-align:left"><strong>ValidationError</strong></td><td style="text-align:left">某些情况下 LLM 未生成非必填项（如系统设计题），导致返回 None。</td><td style="text-align:left">在 Pydantic Schema 中使用 <code>Optional[T] = None</code>。</td></tr><tr><td style="text-align:left"><strong>UI 样式丢失</strong></td><td style="text-align:left">Next.js 页面内容堆叠在左上角，无样式。</td><td style="text-align:left">1. 检查 <code>layout.tsx</code> 是否引入 <code>globals.css</code>。<br>2. 检查 <code>tailwind.config.ts</code> 的 <code>content</code> 路径是否包含 <code>app</code> 目录。</td></tr><tr><td style="text-align:left"><strong>SSL Error</strong></td><td style="text-align:left">Mac 自带 LibreSSL 版本过低。</td><td style="text-align:left">降级 urllib3 或使用 Homebrew 升级 OpenSSL。</td></tr></tbody></table><hr><h2 id="6-总结与展望">6. 总结与展望</h2><p><code>jd_agent</code> 不仅仅是一个 Demo，它展示了现代 AI 应用开发的标准范式：<strong>Prompt 工程化 + 异步后端 + 结构化数据流</strong>。</p><p><strong>未来规划 (Roadmap)</strong>:</p><ol><li><strong>RAG 增强</strong>: 集成 Tavily 搜索 API，实时抓取公司财报和新闻，生成更犀利的反问环节。</li><li><strong>简历匹配</strong>: 上传用户简历 PDF，自动计算与 JD 的匹配度分数 (Matching Score)。</li><li><strong>多模态</strong>: 支持直接输入 JD 截图或 PDF 文件。</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;基于 FastAPI + LangChain 的高并发 Agent 架构解析&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;项目地址&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>打造 L5 级人机协同与全双工语音的 AI 面试官</title>
    <link href="https://caozhaoqi.github.io/2025/12/01/agent-advance-high/"/>
    <id>https://caozhaoqi.github.io/2025/12/01/agent-advance-high/</id>
    <published>2025-11-30T16:20:21.000Z</published>
    <updated>2025-11-30T16:22:22.003Z</updated>
    
    <content type="html"><![CDATA[<h1>🚀 [实战] 进化！从脚本到数字员工：打造 L5 级人机协同与全双工语音的 AI 面试官</h1><blockquote><p><strong>摘要</strong>：今天是一个里程碑。我们将 <code>JD_Agent</code> 从一个简单的 RAG 问答工具，彻底重构为一个具备 <strong>L5 级别自主性</strong> 的多智能体系统。同时，我们攻克了 <strong>全双工语音交互</strong> 和 <strong>DeepSeek 风格思考过程</strong> 的工程难题，让 AI 不仅能“思考”，还能像真人一样“倾听”和“表达”。</p></blockquote><hr><h2 id="🌟-架构全景图-The-Big-Picture">🌟 架构全景图 (The Big Picture)</h2><p>在 v2.0 版本中，我们不再简单的线性调用 LLM，而是构建了一个复杂的<strong>多智能体协作网络</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User((🙍‍♂️ 用户)) &lt;--&gt;|Web Audio / SSE| Frontend[🖥️ Next.js 前端]</span><br><span class="line">    Frontend &lt;--&gt;|HTTP / Stream| Backend[⚙️ FastAPI 后端]</span><br><span class="line"></span><br><span class="line">    subgraph &quot;🧠 智能体大脑 (LangGraph)&quot;</span><br><span class="line">        Start(开始) --&gt; Parser[🔍 职位解析员]</span><br><span class="line">        Parser --&gt; Researcher[🕵️ 商业情报员]</span><br><span class="line">        Parser --&gt; TechLead[💻 技术面试官]</span><br><span class="line">        </span><br><span class="line">        Researcher --&gt; Context&#123;信息汇总&#125;</span><br><span class="line">        TechLead --&gt; Reviewer[⚖️ 质量检察员]</span><br><span class="line">        </span><br><span class="line">        Reviewer --&gt;|评分 &lt; 85| TechLead</span><br><span class="line">        Reviewer --&gt;|评分 &gt;= 85| End(✅ 输出报告)</span><br><span class="line">        </span><br><span class="line">        Reviewer -.-&gt;|拿捏不准| Human[🛑 人工介入]</span><br><span class="line">        Human --&gt; TechLead</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph &quot;🔊 语音交互层&quot;</span><br><span class="line">        ASR[👂 Whisper ASR]</span><br><span class="line">        TTS[🗣️ macOS Native TTS]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    Backend --&gt; ASR</span><br><span class="line">    Backend --&gt; TTS</span><br><span class="line">    Backend --&gt; Start</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破一：L5-级多智能体协同-LangGraph">核心突破一：L5 级多智能体协同 (LangGraph)</h2><p>我们要解决的核心痛点是：<strong>AI 生成的内容往往不够深度，或者一本正经胡说八道。</strong><br>解决方案是引入 <strong>Reviewer (质检员)</strong> 角色，形成质量闭环。</p><h3 id="1-定义“团队”-The-Team">1. 定义“团队” (The Team)</h3><p>我们不再是一个 Agent 打天下，而是通过 <code>LangGraph</code> 组建了一个虚拟团队：</p><ul><li><strong>Tech Lead</strong>: 负责根据 JD 出题。</li><li><strong>Reviewer</strong>: 负责给题目打分。如果不合格，打回重写。</li></ul><h3 id="2-代码实现-Workflow">2. 代码实现 (Workflow)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># src/app/graph/workflow.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义路由逻辑：决定是“通过”还是“重写”</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qa_router</span>(<span class="params">state: AgentState</span>):</span><br><span class="line">    <span class="comment"># 1. 防止死循环</span></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;iteration_count&quot;</span>] &gt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;approved&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 质量把关</span></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;quality_score&quot;</span>] &gt;= <span class="number">85</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;approved&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;rejected&quot;</span> <span class="comment"># ⬅️ 这里的 rejected 会导致回滚</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建图</span></span><br><span class="line">workflow = StateGraph(AgentState)</span><br><span class="line">workflow.add_node(<span class="string">&quot;tech_lead&quot;</span>, tech_lead_node)</span><br><span class="line">workflow.add_node(<span class="string">&quot;reviewer&quot;</span>, reviewer_node)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编排循环</span></span><br><span class="line">workflow.add_edge(<span class="string">&quot;tech_lead&quot;</span>, <span class="string">&quot;reviewer&quot;</span>)</span><br><span class="line">workflow.add_conditional_edges(</span><br><span class="line">    <span class="string">&quot;reviewer&quot;</span>,</span><br><span class="line">    qa_router,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;approved&quot;</span>: END,</span><br><span class="line">        <span class="string">&quot;rejected&quot;</span>: <span class="string">&quot;tech_lead&quot;</span> <span class="comment"># 🔄 关键：打回重写</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破二：DeepSeek-风格的“思考过程”-UI">核心突破二：DeepSeek 风格的“思考过程” UI</h2><p>为了缓解 L5 架构推理时间长（可能达 1-2 分钟）带来的焦虑感，我们复刻了 DeepSeek R1 的交互体验：<strong>把 AI 的思考过程透明化</strong>。</p><h3 id="1-双流协议设计-Dual-Stream-Protocol">1. 双流协议设计 (Dual Stream Protocol)</h3><p>后端不再只返回文本，而是返回 <strong>JSON 事件流</strong>：</p><ul><li><code>type: &quot;thought&quot;</code> -&gt; 思考步骤（如“正在检索财报…”）</li><li><code>type: &quot;token&quot;</code> -&gt; 最终回复内容</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后端 SSE 推送的数据流示例</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;thought&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正在分析 JD 技术栈...&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;thought&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;正在构思追问策略...&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;token&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;您好，&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;token&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;根据您的经历...&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-前端可视化组件-Thinking-Block">2. 前端可视化组件 (Thinking Block)</h3><p>前端实现了一个可折叠的面板，实时渲染 <code>thought</code> 流。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/components/ThinkingBlock.tsx</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ThinkingBlock</span>(<span class="params">&#123; thoughts, isFinished &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;bg-gray-50 border rounded-xl p-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex items-center gap-2 text-gray-500&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;isFinished ? <span class="tag">&lt;<span class="name">BrainCircuit</span> /&gt;</span> : <span class="tag">&lt;<span class="name">Loader2</span> <span class="attr">className</span>=<span class="string">&quot;animate-spin&quot;</span>/&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;isFinished ? &quot;深度思考完成&quot; : &quot;DeepSeek 正在思考...&quot;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       </span></span><br><span class="line"><span class="language-xml">       &#123;/* 动态渲染思考步骤 */&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;mt-2 space-y-1 border-l-2 border-gray-200 pl-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;thoughts.map(step =&gt; (</span></span><br><span class="line"><span class="language-xml">             <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;text-xs text-gray-600 animate-in fade-in&quot;</span>&gt;</span>&#123;step&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="核心突破三：全双工语音交互-ASR-TTS">核心突破三：全双工语音交互 (ASR + TTS)</h2><p>我们实现了 <strong>录音 -&gt; ASR -&gt; LLM -&gt; TTS</strong> 的完整闭环，让 AI 变身为真正的面试官。</p><h3 id="1-语音合成-TTS-的避坑之路">1. 语音合成 (TTS) 的避坑之路</h3><p>这是今天遇到的最大工程挑战。</p><ul><li>❌ <strong>Edge-TTS</strong>: 在国内网络环境下频繁报 <code>503 Service Unavailable</code>，不稳定。</li><li>❌ <strong>Pyttsx3</strong>: 生成的 AIFF 格式在 Chrome 浏览器中无法播放 (<code>NotSupportedError</code>)。</li><li>✅ <strong>macOS 原生 <code>say</code> 命令</strong>: <strong>最终方案！</strong></li></ul><p>利用 Mac 系统底层的 <code>say</code> 命令生成 <code>.m4a</code> 文件，既利用了 Siri 的高质量语音，又做到了<strong>零网络延迟、零成本</strong>。</p><p><strong>后端实现 (FastAPI):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/audio/tts&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">text_to_speech</span>(<span class="params">text: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Mac 专属黑科技：调用系统底层 TTS</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    tmp_path = <span class="string">f&quot;/tmp/<span class="subst">&#123;uuid.uuid4()&#125;</span>.m4a&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 调用系统命令，直接生成 m4a (浏览器兼容性极好)</span></span><br><span class="line">    subprocess.run([<span class="string">&quot;say&quot;</span>, <span class="string">&quot;-o&quot;</span>, tmp_path, text])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(tmp_path, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">return</span> Response(content=f.read(), media_type=<span class="string">&quot;audio/mp4&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-前端音频队列-Audio-Queue">2. 前端音频队列 (Audio Queue)</h3><p>为了防止流式生成时语音重叠（AI 还在打字，上一句还没读完，下一句又来了），我们在前端实现了一个<strong>分句缓冲队列</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant SSE as 后端流</span><br><span class="line">    participant Parser as 前端解析器</span><br><span class="line">    participant Queue as 音频队列</span><br><span class="line">    participant Player as 播放器</span><br><span class="line"></span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;你好，&quot;</span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;我是&quot;</span><br><span class="line">    SSE-&gt;&gt;Parser: &quot;面试官。&quot; (检测到标点)</span><br><span class="line">    Parser-&gt;&gt;Queue: 入队: &quot;你好，我是面试官。&quot;</span><br><span class="line">    </span><br><span class="line">    loop 队列监听</span><br><span class="line">        Queue-&gt;&gt;Player: 取出第一句</span><br><span class="line">        Player--&gt;&gt;Player: 播放中...</span><br><span class="line">        Player-&gt;&gt;Queue: 播放结束 (onEnded)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="🛠️-踩坑实录-Troubleshooting">🛠️ 踩坑实录 (Troubleshooting)</h2><h3 id="🐛-Bug-1-React-严格模式下的“复读机”">🐛 Bug 1: React 严格模式下的“复读机”</h3><ul><li><strong>现象</strong>：AI 回复出现 AABB 重复（如“好好…的的…”）。</li><li><strong>原因</strong>：<code>Next.js</code> 开发环境下 <code>React.StrictMode</code> 会执行两次 <code>setState</code>。而我们的代码中直接修改了对象属性 (<code>msg.content += chunk</code>)。</li><li><strong>修复</strong>：严格遵循 <strong>Immutability</strong> 原则。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正确写法</span></span><br><span class="line"><span class="title function_">setMessages</span>(<span class="function"><span class="params">prev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newMsgs = [...prev];</span><br><span class="line">    <span class="comment">// 创建新对象，而不是修改引用</span></span><br><span class="line">    newMsgs[lastIndex] = &#123; ...lastMsg, <span class="attr">content</span>: lastMsg.<span class="property">content</span> + chunk &#125;; </span><br><span class="line">    <span class="keyword">return</span> newMsgs;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="🐛-Bug-2-Worker-is-not-defined">🐛 Bug 2: <code>Worker is not defined</code></h3><ul><li><strong>现象</strong>：引入录音库 <code>react-media-recorder</code> 后页面崩溃。</li><li><strong>原因</strong>：Next.js 服务端渲染 (SSR) 无法访问浏览器特有的 Worker API。</li><li><strong>修复</strong>：使用 <code>dynamic import</code> 隔离加载。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChatInput</span> = <span class="title function_">dynamic</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/components/ChatInput&quot;</span>), &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure><hr><h2 id="🔮-总结">🔮 总结</h2><p>现在的 <code>JD_Agent</code> 已经不仅仅是一个代码 demo，它具备了：</p><ol><li><strong>大脑</strong>：懂反思、会纠错的多智能体团队。</li><li><strong>嘴巴</strong>：零延迟的本地 TTS。</li><li><strong>颜值</strong>：媲美 DeepSeek 的现代化 UI。</li></ol><p><strong>Next Step</strong>: 我们将尝试引入 <strong>WebRTC</strong>，将现在的“对讲机模式”升级为真正的“打断式实时通话”。</p><p><em>Keep Building, Keep Evolving.</em> 🚀</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;🚀 [实战] 进化！从脚本到数字员工：打造 L5 级人机协同与全双工语音的 AI 面试官&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：今天是一个里程碑。我们将 &lt;code&gt;JD_Agent&lt;/code&gt; 从一个简单的 RAG 问答工</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实时语音模拟面试</title>
    <link href="https://caozhaoqi.github.io/2025/11/30/tts-asr-agent/"/>
    <id>https://caozhaoqi.github.io/2025/11/30/tts-asr-agent/</id>
    <published>2025-11-29T16:01:29.000Z</published>
    <updated>2025-11-30T16:21:10.774Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GitHub 仓库</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在实现了基于 JD 生成面试指南（v1.0）后，我们并未止步。本文记录了 <code>jd_agent</code> 项目的重大升级：引入 <strong>模拟面试（Mock Interview）</strong> 模式，并集成了 <strong>ASR（语音识别）</strong> 与 <strong>TTS（语音合成）</strong> 技术。我们通过 <strong>FastAPI</strong> 的流式响应、<strong>Next.js</strong> 的音频队列管理以及 <strong>双模型配置策略</strong>，打造了一个能够“听懂你、并开口提问”的 AI 面试官。</p></blockquote><hr><h2 id="1-架构升级：从单向生成到双向交互">1. 架构升级：从单向生成到双向交互</h2><p>v1.0 版本主要解决的是“信息提取”问题（JD -&gt; 报告）。<br>v2.0 版本则致力于解决“实战演练”问题（用户 &lt;-&gt; AI 面试官）。为此，我们在架构中引入了 <strong>音频层 (Audio Layer)</strong> 和 <strong>会话状态管理</strong>。</p><h3 id="1-1-系统架构图-v2-0">1.1 系统架构图 (v2.0)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User((用户)) </span><br><span class="line">    </span><br><span class="line">    subgraph Frontend [Next.js Client]</span><br><span class="line">        Microphone --&gt;|Audio Blob| ASR_Handler</span><br><span class="line">        Chat_UI --&gt;|Text Stream| SSE_Reader</span><br><span class="line">        SSE_Reader --&gt;|Sentence Buffer| Audio_Queue</span><br><span class="line">        Audio_Queue --&gt;|Text Segments| TTS_Player</span><br><span class="line">        TTS_Player --&gt; Speaker</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Backend [FastAPI Server]</span><br><span class="line">        ASR_Handler --&gt;|POST /audio/transcribe| Whisper_Service</span><br><span class="line">        Chat_UI --&gt;|POST /chat/stream| Chat_Service</span><br><span class="line">        TTS_Player --&gt;|POST /audio/tts| TTS_Service</span><br><span class="line">        </span><br><span class="line">        subgraph Services</span><br><span class="line">            Chat_Service[LangChain Chat Flow]</span><br><span class="line">            Whisper_Service[ASR Adapter]</span><br><span class="line">            TTS_Service[TTS Adapter]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        subgraph Model_Layer [Model Factory]</span><br><span class="line">            Chat_Service --&gt;|Text Generation| DeepSeek_V3</span><br><span class="line">            Whisper_Service &amp; TTS_Service --&gt;|Audio Processing| SiliconFlow/OpenAI</span><br><span class="line">        end</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="2-核心功能实现细节">2. 核心功能实现细节</h2><h3 id="2-1-模拟面试与流式对话-Streaming-Chat">2.1 模拟面试与流式对话 (Streaming Chat)</h3><p>为了模拟真实的面试场景，我们摒弃了“生成完毕再一次性返回”的模式，全面拥抱 <strong>SSE (Server-Sent Events)</strong>。</p><ul><li><strong>后端实现</strong>：使用 <code>LangChain</code> 的 <code>.astream()</code> 方法配合 FastAPI 的 <code>StreamingResponse</code>。</li><li><strong>Prompt 设计</strong>：根据 Session 标题动态切换 System Prompt。如果检测到是面试模式，AI 变身为“严厉的面试官”，每次只问一个问题，并根据候选人的回答进行追问。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/api/endpoints.py</span></span><br><span class="line"><span class="meta">@router.post(<span class="params"><span class="string">&quot;/chat/stream&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stream_chat</span>(<span class="params">req: ChatRequest</span>):</span><br><span class="line">    <span class="comment"># 动态注入人设</span></span><br><span class="line">    system_prompt = <span class="string">&quot;你是一名专业的面试官。请根据求职者的回答进行追问...&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate</span>():</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> chunk <span class="keyword">in</span> chain.astream(messages):</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">f&quot;data: <span class="subst">&#123;chunk&#125;</span>\n\n&quot;</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;data: [DONE]\n\n&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> StreamingResponse(generate(), media_type=<span class="string">&quot;text/event-stream&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-2-语音交互闭环-The-Voice-Loop">2.2 语音交互闭环 (The Voice Loop)</h3><p>这是本次升级的技术高地。我们实现了一个完整的语音交互循环：<strong>录音 -&gt; ASR -&gt; LLM 思考 -&gt; TTS 朗读</strong>。</p><h4 id="A-ASR-听">A. ASR (听)</h4><p>前端使用 <code>react-media-recorder</code> 捕获音频 Blob，后端对接 <strong>OpenAI 兼容接口</strong>（如 SiliconFlow 的 <code>SenseVoiceSmall</code>，识别速度极快）。</p><h4 id="B-TTS-说-关键优化：音频队列-Audio-Queue">B. TTS (说) - 关键优化：音频队列 (Audio Queue)</h4><p>为了解决“AI 说话卡顿”或“多重语音重叠”的问题，我们在前端实现了一个<strong>音频播放队列</strong>。</p><p><strong>痛点</strong>：AI 生成速度很快，如果每收到一段文字就请求播放，声音会重叠。如果等全部生成完再播放，用户等待时间太长。<br><strong>方案</strong>：</p><ol><li><strong>分句检测</strong>：前端监听 SSE 流，利用标点符号（<code>。？！</code>）切分句子。</li><li><strong>入队</strong>：切分好的句子推入 <code>audioQueue</code>。</li><li><strong>串行播放</strong>：<code>processAudioQueue</code> 递归函数确保上一句播完才请求下一句。</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hooks/useAudioQueue.ts</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">processAudioQueue</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (isPlayingRef.<span class="property">current</span> || queue.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    isPlayingRef.<span class="property">current</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> text = queue.<span class="title function_">shift</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求 TTS API 并播放</span></span><br><span class="line">    <span class="keyword">const</span> audio = <span class="keyword">new</span> <span class="title class_">Audio</span>(tts_url);</span><br><span class="line">    audio.<span class="property">onended</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        isPlayingRef.<span class="property">current</span> = <span class="literal">false</span>;</span><br><span class="line">        <span class="title function_">processAudioQueue</span>(); <span class="comment">// 递归处理下一句</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> audio.<span class="title function_">play</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-基础设施与配置策略-Infrastructure">3. 基础设施与配置策略 (Infrastructure)</h2><p>在引入语音功能时，我们遇到了一个典型的工程问题：<strong>DeepSeek 很强，但它不支持音频</strong>。</p><p>为了兼顾<strong>智能（文本）<strong>与</strong>功能（语音）</strong>，我们设计了<strong>双模型配置策略</strong>。</p><h3 id="3-1-分离配置-env-config-py">3.1 分离配置 (<code>.env</code> &amp; <code>config.py</code>)</h3><p>我们将 LLM 的配置与 Audio 的配置完全解耦，实现了“大脑”用 DeepSeek，“嘴巴和耳朵”用 OpenAI/SiliconFlow。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/core/config.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    <span class="comment"># 大脑：DeepSeek V3 (高智商，低成本)</span></span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span> </span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 五官：SiliconFlow / OpenAI (处理语音)</span></span><br><span class="line">    AUDIO_API_KEY: <span class="type">Optional</span>[<span class="built_in">str</span>]</span><br><span class="line">    AUDIO_API_BASE: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="string">&quot;https://api.siliconflow.cn/v1&quot;</span></span><br><span class="line">    ASR_MODEL: <span class="built_in">str</span> = <span class="string">&quot;FunAudioLLM/SenseVoiceSmall&quot;</span></span><br></pre></td></tr></table></figure><p>这种设计使得系统极具灵活性，可以在不修改代码的情况下，随意更换底层的语音服务商。</p><hr><h2 id="4-前端工程化踩坑记录-Troubleshooting">4. 前端工程化踩坑记录 (Troubleshooting)</h2><p>在 Next.js + React 的开发过程中，我们解决了几个棘手的 Bug。</p><h3 id="坑位-1：Worker-is-not-defined">坑位 1：<code>Worker is not defined</code></h3><ul><li><strong>现象</strong>：引入 <code>react-media-recorder</code> 后，页面刷新直接报错。</li><li><strong>原因</strong>：Next.js 默认进行服务端渲染 (SSR)，而录音库依赖浏览器特有的 <code>Worker</code> API，Node.js 环境里没有。</li><li><strong>解决</strong>：使用 <code>next/dynamic</code> 进行动态导入，并禁用 SSR。<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ChatInput</span> = <span class="title function_">dynamic</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;@/components/ChatInput&quot;</span>), &#123; <span class="attr">ssr</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-2：布局遮挡与滚动失效">坑位 2：布局遮挡与滚动失效</h3><ul><li><strong>现象</strong>：输入框使用 <code>absolute</code> 定位，导致聊天记录过长时被输入框遮挡，无法看到最后一条消息。</li><li><strong>解决</strong>：重构 CSS 布局，放弃绝对定位，改用 <strong>Flexbox</strong>。<ul><li>容器：<code>flex flex-col h-screen</code></li><li>消息区：<code>flex-1 overflow-y-auto</code></li><li>输入区：<code>flex-shrink-0</code> (固定在底部，挤压消息区高度)</li></ul></li></ul><h3 id="坑位-3：Markdown-样式丢失">坑位 3：Markdown 样式丢失</h3><ul><li><strong>现象</strong>：AI 回复的 Markdown 没有格式（无加粗、无列表）。</li><li><strong>解决</strong>：引入 <code>@tailwindcss/typography</code> 插件，并正确包裹 <code>prose</code> 类名。<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;prose prose-sm ...&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ReactMarkdown</span>&gt;</span>&#123;content&#125;<span class="tag">&lt;/<span class="name">ReactMarkdown</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-总结">5. 总结</h2><p>通过本次 v2.0 的迭代，<code>jd_agent</code> 已经不仅仅是一个简单的文本分析工具，而是一个具备<strong>多模态交互能力</strong>的智能助手。</p><ul><li><strong>技术栈</strong>: FastAPI, LangChain, Next.js, Tailwind, Web Audio API.</li><li><strong>核心突破</strong>: 解决了 LLM 生成与 TTS 播放的时序同步问题，实现了流畅的语音对话体验。</li></ul><hr><p><em>希望这篇实战记录能为正在构建 AI Agent 的开发者提供参考！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GitHub 仓库&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com/caozhaoqi/jd_agent&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/"/>
    <id>https://caozhaoqi.github.io/2025/11/29/llm-agent-memory/</id>
    <published>2025-11-29T14:00:18.000Z</published>
    <updated>2025-11-29T14:00:59.411Z</updated>
    
    <content type="html"><![CDATA[<h1>[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现</h1><blockquote><p><strong>摘要</strong>：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 <code>JD_Agent</code> 项目的里程碑式更新。我们引入了 <strong>Next.js</strong> 复刻 DeepSeek 的丝滑 UI，基于 <strong>SQLModel</strong> 实现了完整的用户鉴权与会话管理，并利用 <strong>RAG 技术</strong> 实现了“简历解析与长期记忆”功能，让 AI 真正拥有了“记住用户”的能力。</p></blockquote><hr><h2 id="1-项目演进：从-Script-到-Product">1. 项目演进：从 Script 到 Product</h2><p>在之前的版本中，我们的 <code>JD_Agent</code> 只是一个无状态的 API 接口：用户发 JD，AI 返回分析。<br>但一个真正的 AI 产品需要具备：</p><ol><li><strong>用户系统</strong>：数据隔离，每个人只能看自己的历史。</li><li><strong>交互体验</strong>：流式输出、Markdown 渲染、历史记录回溯。</li><li><strong>长期记忆</strong>：记住用户的简历背景，不需要每次 Prompt 都重复“我是 Python 开发…”。</li></ol><p>今天，我们完成了这次<strong>全栈重构</strong>。</p><hr><h2 id="2-技术栈全景">2. 技术栈全景</h2><ul><li><strong>Frontend</strong>: Next.js 14 (App Router) + Tailwind CSS + Lucide React</li><li><strong>Backend</strong>: FastAPI + Uvicorn</li><li><strong>Database</strong>: SQLModel (SQLite) + Alembic</li><li><strong>Auth</strong>: JWT (OAuth2PasswordBearer) + Passlib (Bcrypt)</li><li><strong>AI Core</strong>: LangChain + OpenAI/DeepSeek + FAISS (RAG)</li></ul><hr><h2 id="3-核心功能实现">3. 核心功能实现</h2><h3 id="3-1-完美复刻-DeepSeek-的交互界面">3.1 完美复刻 DeepSeek 的交互界面</h3><p>我们抛弃了简陋的 HTML，采用 <strong>Next.js + Tailwind</strong> 打造了现代化的 Chat UI。</p><ul><li><strong>布局攻坚</strong>：为了实现“顶部固定、侧边栏独立滚动、输入框底部悬浮且不遮挡内容”，我们采用了 <code>fixed inset-0</code> 锁死视口高度，并配合 <code>pb-[200px]</code> 的底部内边距策略。</li><li><strong>Markdown 渲染</strong>：后端返回的结构化 JSON 报告，在前端被动态组装成 Markdown，并通过 <code>react-markdown</code> 渲染出漂亮的排版。</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端布局核心 Trick</span></span><br><span class="line">&lt;div className=<span class="string">&quot;fixed inset-0 flex ...&quot;</span>&gt;</span><br><span class="line">  &#123;<span class="comment">/* 侧边栏 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;w-[260px] hidden md:flex ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;<span class="comment">/* 主聊天区 */</span>&#125;</span><br><span class="line">  &lt;div className=<span class="string">&quot;flex-1 flex flex-col h-full relative&quot;</span>&gt;</span><br><span class="line">     &#123;<span class="comment">/* 消息列表：底部留白防止被输入框遮挡 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;flex-1 overflow-y-auto pb-[200px]&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">     </span><br><span class="line">     &#123;<span class="comment">/* 悬浮输入框：背景渐变透明 */</span>&#125;</span><br><span class="line">     &lt;div className=<span class="string">&quot;absolute bottom-0 ... bg-gradient-to-t ...&quot;</span>&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="3-2-长期记忆：简历解析与用户画像-LTM">3.2 长期记忆：简历解析与用户画像 (LTM)</h3><p>这是本次更新的<strong>灵魂功能</strong>。我们不希望 AI 聊完就忘，而是构建了一个<strong>长期记忆系统 (Long-Term Memory)</strong>。</p><p><strong>实现流程</strong>：</p><ol><li><strong>上传</strong>：用户上传 PDF/Word 简历。</li><li><strong>解析</strong>：后端使用 <code>pdfplumber</code> 提取纯文本。</li><li><strong>ETL</strong>：利用 LangChain 的 <code>resume_extractor</code> 链，从杂乱的简历中提取出<strong>结构化画像</strong>（如：<code>tech_stack: [&quot;Python&quot;, &quot;FastAPI&quot;]</code>, <code>experience: &quot;5年&quot;</code>）。</li><li><strong>存储</strong>：存入 <code>UserProfile</code> 数据库表。</li><li><strong>回想</strong>：下次用户发送 JD 时，系统自动读取 <code>UserProfile</code>，注入到 System Prompt 中。</li></ol><p><strong>后端代码片段 (Service Layer)</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># app/services/interview_service.py</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request, db, user_id</span>):</span><br><span class="line">    <span class="comment"># 1. 读取长期记忆 (从数据库获取用户画像)</span></span><br><span class="line">    ltm_profile = get_user_profile_str(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 读取短期记忆 (从 ChatMessage 表获取最近对话)</span></span><br><span class="line">    chat_history = get_recent_chat_history(db, user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 带着记忆去思考</span></span><br><span class="line">    task_tech = generate_tech_async(</span><br><span class="line">        ...,</span><br><span class="line">        user_profile=ltm_profile, <span class="comment"># &lt;--- 注入长期记忆</span></span><br><span class="line">        chat_history=chat_history <span class="comment"># &lt;--- 注入短期记忆</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h3 id="3-3-数据闭环：会话历史管理">3.3 数据闭环：会话历史管理</h3><p>为了实现侧边栏的“历史记录”功能，我们引入了 <strong>SQLModel</strong>。</p><ul><li><p><strong>表结构设计</strong>：</p><ul><li><code>User</code>: 存储用户名、加密密码。</li><li><code>ChatSession</code>: 代表一次对话（如“神州邦邦面试准备”）。</li><li><code>ChatMessage</code>: 存储具体的 User/Assistant 消息内容。</li></ul></li><li><p><strong>难点处理</strong>：Pydantic 对象无法直接存入数据库，我们在存库前将其序列化为 JSON 字符串，在读取时再反序列化，确保前端能拿到结构化的 <code>meta</code> 数据进行渲染。</p></li></ul><hr><h2 id="4-工程化踩坑实录">4. 工程化踩坑实录</h2><p>在开发过程中，我们解决了一系列真实的工程问题：</p><h3 id="坑位-1：Tailwind-CSS-样式失效">坑位 1：Tailwind CSS 样式失效</h3><ul><li><strong>现象</strong>：页面元素堆叠在左上角，样式全无。</li><li><strong>原因</strong>：Next.js 初始化时 <code>tailwind.config.js</code> 路径配置错误，且误装了不兼容的 Tailwind v4 版本。</li><li><strong>解决</strong>：降级至 <code>tailwindcss@3.4.17</code>，并手动修正 <code>content</code> 路径覆盖 <code>src/</code> 目录。</li></ul><h3 id="坑位-2：Bcrypt-版本冲突">坑位 2：Bcrypt 版本冲突</h3><ul><li><strong>现象</strong>：注册时报错 <code>AttributeError: module 'bcrypt' has no attribute '__about__'</code>。</li><li><strong>原因</strong>：<code>passlib</code> 库与最新版 <code>bcrypt 4.0+</code> 不兼容。</li><li><strong>解决</strong>：强制锁定版本 <code>pip install &quot;bcrypt==3.2.2&quot;</code>。</li></ul><h3 id="坑位-3：LangChain-参数丢失">坑位 3：LangChain 参数丢失</h3><ul><li><strong>现象</strong>：<code>KeyError: &quot;Input to ChatPromptTemplate is missing variables &#123;'user_profile'&#125;&quot;</code>。</li><li><strong>原因</strong>：在 Prompt 模板中定义了 <code>&#123;user_profile&#125;</code> 占位符，但在 Chain 调用 (<code>ainvoke</code>) 时忘记传入该参数。</li><li><strong>解决</strong>：在 Service 层获取记忆后，显式传递给 Chain。</li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p>通过今天的迭代，<code>JD_Agent</code> 已经具备了一个商业化 AI 产品的雏形：</p><ul><li><strong>好看</strong>：媲美 DeepSeek 的 UI。</li><li><strong>好用</strong>：支持简历一键解析，AI 越用越懂你。</li><li><strong>稳健</strong>：完整的鉴权与日志系统。</li></ul><p><strong>下一步计划</strong>：</p><ol><li><strong>多智能体模拟面试</strong>：引入两个 Agent 互相对话，用户旁观“模拟面试”过程（基于 SSE 流式输出）。</li><li><strong>语音交互</strong>：接入 TTS/ASR，实现真正的语音模拟面试。</li></ol><hr><p><em>技术改变生活，AI 赋能求职。如果你对这个项目感兴趣，欢迎关注我的 GitHub！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;[硬核实战] 从零构建全栈 AI 简历助手：复刻 DeepSeek 交互与长期记忆实现&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：如何将一个简单的 LangChain Demo 进化为生产级的 AI SaaS 应用？本文记录了 &lt;c</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 RAG 与 Agent 协作的智能面试助手开发指南</title>
    <link href="https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/"/>
    <id>https://caozhaoqi.github.io/2025/11/28/agent-rag-jd/</id>
    <published>2025-11-28T15:32:37.000Z</published>
    <updated>2025-11-28T15:34:27.317Z</updated>
    
    <content type="html"><![CDATA[<h1>实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南</h1><blockquote><p><strong>摘要</strong>：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记）进行回答？本文将拆解一个真实项目 <code>JD_Agent</code> 的实现过程。我们利用 <strong>FastAPI + LangChain</strong> 构建了一个智能体，它不仅能分析岗位 JD，还能通过 <strong>RAG 技术</strong> 检索我的本地 Markdown 博客，生成结合了我个人技术积累的专属面试指南。</p></blockquote><hr><h2 id="一、-为什么要做这个？（痛点与思路）">一、 为什么要做这个？（痛点与思路）</h2><p>在准备面试时，我们经常遇到两个问题：</p><ol><li><strong>JD 分析太累</strong>：每个岗位的技术栈不同，需要针对性复习。</li><li><strong>知识遗忘</strong>：明明以前写过关于 Docker 或 Redis 的博客笔记，但面试时一时想不起来细节。</li></ol><p><strong>我的解决方案</strong>：<br>构建一个 <strong>AI Agent</strong>。</p><ol><li>它能<strong>自动分析</strong>我投递的 JD（岗位描述），提取核心技术栈。</li><li>它拥有一个<strong>外挂大脑（知识库）</strong>，存储了我所有的博客文章。</li><li>在生成面试题时，它会<strong>优先参考</strong>我的博客内容，并告诉我：“这个问题你可以复习你写的这篇文章。”</li></ol><hr><h2 id="二、-核心原理：RAG-与-Agent-的协作">二、 核心原理：RAG 与 Agent 的协作</h2><p>在本项目中，我们采用了 <strong>RAG (Retrieval-Augmented Generation)</strong> 架构。</p><h3 id="1-什么是-RAG？">1. 什么是 RAG？</h3><p>如果把大模型（LLM）比作一个“超级学霸”，那 RAG 就是给了学霸一本“开卷考试的书”。</p><ul><li><strong>LLM</strong>：负责逻辑推理、语言组织。</li><li><strong>Knowledge Base</strong>：负责提供精准的、私有的事实数据（我的博客）。</li></ul><h3 id="2-协作流程图">2. 协作流程图</h3><p>整个系统的运作流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    User[用户输入 JD] --&gt;|1. 提交| Agent[智能体核心 (Service)]</span><br><span class="line">    </span><br><span class="line">    subgraph Analysis [阶段一: 意图识别]</span><br><span class="line">        Agent --&gt;|2. 解析 JD| Parser[LLM 解析器]</span><br><span class="line">        Parser --&gt;|提取关键词: Python, Docker| Keywords[技术栈列表]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Retrieval [阶段二: RAG 检索]</span><br><span class="line">        Keywords --&gt;|3. 查询向量库| VectorDB[(FAISS 向量库)]</span><br><span class="line">        VectorDB --&gt;|4. 返回博客片段 + 来源| Context[知识库上下文]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    subgraph Generation [阶段三: 增强生成]</span><br><span class="line">        Context --&gt;|5. 注入 Prompt| Generator[LLM 生成器]</span><br><span class="line">        Generator --&gt;|6. 生成面试题 &amp; 引用来源| Output[最终报告]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><hr><h2 id="三、-关键技术实现">三、 关键技术实现</h2><h3 id="1-构建知识库-The-Embedding-Pipeline">1. 构建知识库 (The Embedding Pipeline)</h3><p>这是 RAG 的地基。我们需要把 Markdown 格式的博客文章转换成计算机能理解的“向量”。</p><p><strong>技术栈</strong>：<code>LangChain</code> + <code>BGE-Small-zh</code> + <code>FAISS</code></p><ul><li><strong>数据清洗 (ETL)</strong>：<br>使用 <code>MarkdownHeaderTextSplitter</code> 按章节切分文章，保证语义完整性。</li><li><strong>向量化 (Embedding)</strong>：<br>我们选用了 <strong>BAAI/bge-small-zh-v1.5</strong> 模型。它能将一段文字转换为 512 维的浮点数组。<blockquote><p><em>原理</em>：语义相近的句子（如“Docker容器”和“容器化部署”），在向量空间中的距离非常近。</p></blockquote></li><li><strong>存储结构</strong>：<br>存入 FAISS 的不仅是向量，还包含 <strong>Payload</strong>（原文）和 <strong>Metadata</strong>（元数据，如文件名）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：入库逻辑</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build_index</span>():</span><br><span class="line">    <span class="comment"># 1. 加载博客 Markdown</span></span><br><span class="line">    docs = load_and_split_markdown(<span class="string">&quot;source/_posts&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 初始化 BGE 模型 (使用国内镜像)</span></span><br><span class="line">    embedding_model = HuggingFaceEmbeddings(model_name=<span class="string">&quot;BAAI/bge-small-zh-v1.5&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 向量化并存入 FAISS</span></span><br><span class="line">    vector_store = FAISS.from_documents(docs, embedding_model)</span><br><span class="line">    vector_store.save_local(<span class="string">&quot;blog_faiss_index&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-Agent-的大脑：异步编排-Orchestration">2. Agent 的大脑：异步编排 (Orchestration)</h3><p>为了让用户体验达到极致（快！），后端不能串行处理。我们利用 <strong>Python Asyncio</strong> 实现了并行任务流。</p><ul><li><strong>技术挑战</strong>：如何同时进行“公司背景调查”和“知识库检索”？</li><li><strong>解决方案</strong>：<code>asyncio.gather</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 核心代码片段：并行编排</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># 1. 先解析 JD (前置依赖)</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造查询：用 JD 里的技术栈去查博客</span></span><br><span class="line">    query = <span class="string">&quot; &quot;</span>.join(jd_meta.tech_stack)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 并行执行：(查博客) &amp; (查公司背景) &amp; (出通用题)</span></span><br><span class="line">    task_rag = kb_engine.search(query)</span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 并发等待结果</span></span><br><span class="line">    rag_result, company_info = <span class="keyword">await</span> asyncio.gather(task_rag, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将查到的博客内容注入 Prompt</span></span><br><span class="line">    final_report = <span class="keyword">await</span> generate_final_report(context=rag_result[<span class="string">&#x27;context&#x27;</span>])</span><br></pre></td></tr></table></figure><h3 id="3-上下文注入-Context-Injection">3. 上下文注入 (Context Injection)</h3><p>这是让 AI “读懂”博客的关键一步。我们动态构建了 Prompt Template。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一个资深技术面试官。</span></span><br><span class="line"><span class="string">请根据以下【参考知识库】（这是用户的个人博客笔记）来生成面试题。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">【参考知识库】：</span></span><br><span class="line"><span class="string">&#123;kb_context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">请在生成题目时，明确指出用户在博客中对该知识点的理解。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="四、-遇到的坑与优化-Troubleshooting">四、 遇到的坑与优化 (Troubleshooting)</h2><p>在开发过程中，我们解决了几个典型的工程问题：</p><ol><li><p><strong>模型下载卡顿</strong>：</p><ul><li><em>问题</em>：HuggingFace 国内无法直连。</li><li><em>解决</em>：在代码顶部设置 <code>os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'</code> 强制走镜像。</li></ul></li><li><p><strong>Pydantic 数据校验错误</strong>：</p><ul><li><em>问题</em>：有时候 RAG 没查到数据，返回 <code>None</code>，导致接口报错。</li><li><em>解决</em>：在 Schema 定义中使用 <code>Optional[List[str]] = []</code>，增强系统的鲁棒性。</li></ul></li><li><p><strong>大模型“幻觉”</strong>：</p><ul><li><em>问题</em>：AI 编造博客里没有的内容。</li><li><em>解决</em>：在 Prompt 中加入约束——“仅依据参考知识库回答，如果知识库未提及，请忽略”。</li></ul></li></ol><hr><h2 id="五、-最终效果">五、 最终效果</h2><p>当用户输入一个包含 <strong>“Python, Docker”</strong> 的 JD 时：</p><ol><li><strong>后端</strong> 迅速定位到本地博客中的 <code>Docker部署笔记.md</code> 和 <code>Python并发编程.md</code>。</li><li><strong>AI</strong> 生成的面试指南中写道：<blockquote><p><strong>Q1: 请谈谈 Docker 的隔离机制？</strong><br><em>参考回答要点</em>：根据你的博客 <strong>《<a href="http://xn--Docker-gl3pp3z6v2awsl.md">Docker部署笔记.md</a>》</strong>，你曾总结过 Namespace 负责资源隔离，Cgroups 负责资源限制…</p></blockquote></li><li><strong>前端</strong> 界面底部会展示：<blockquote><p>📚 <strong>知识库引用</strong>：</p><ul><li>📄 <code>Docker部署笔记.md</code></li></ul></blockquote></li></ol><p>这不仅是一个面试题生成器，更是一个<strong>唤醒沉睡知识的第二大脑</strong>。</p><hr><h2 id="六、-总结">六、 总结</h2><p>本项目通过 <strong>FastAPI</strong> 构建高性能后端，<strong>LangChain</strong> 处理复杂的 LLM 逻辑，<strong>FAISS</strong> 实现毫秒级知识检索。它展示了 <strong>LLM Ops (大模型工程化)</strong> 的核心思路：<strong>不仅要会调 API，更要懂得如何管理数据流和上下文。</strong></p><p>如果你也想为自己的知识库装上 AI 引擎，欢迎参考我的 GitHub 仓库：[<a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a>]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;实战：如何让 AI “读懂”我的博客？——基于 RAG 与 Agent 协作的智能面试助手开发指南&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;：在大模型时代，如何让 AI 不仅具备通用知识，还能利用我们私有的数据（如个人博客、技术笔记</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 FastAPI + LangChain 的简单agent实现</title>
    <link href="https://caozhaoqi.github.io/2025/11/26/agent-research-llm/"/>
    <id>https://caozhaoqi.github.io/2025/11/26/agent-research-llm/</id>
    <published>2025-11-26T13:26:13.000Z</published>
    <updated>2025-11-26T13:53:49.049Z</updated>
    
    <content type="html"><![CDATA[<p><strong>GitHub 仓库</strong>: <a href="https://github.com/caozhaoqi/jd_agent">https://github.com/caozhaoqi/jd_agent</a></p><blockquote><p><strong>摘要</strong>：在 AI Agent 开发中，如何平衡大模型的生成质量与接口的响应速度？本文将详细拆解 <code>jd_agent</code> 项目。这是一个基于岗位描述（JD）自动生成结构化面试指南的智能体。我们采用 <strong>FastAPI</strong> 作为后端，利用 <strong>LangChain</strong> 进行逻辑编排，并通过 <strong>Asyncio</strong> 实现并行推理，将任务耗时从 30s+ 优化至 10s 级。此外，本文还记录了从 OpenAI 迁移至 DeepSeek 的实战经验及工程踩坑记录。</p></blockquote><hr><h2 id="1-项目背景与痛点">1. 项目背景与痛点</h2><p>在求职过程中，针对每个岗位进行深度准备（分析技术栈、预测面试题、调研公司背景）是非常耗时的。<br>传统的 ChatGPT 交互方式虽然可行，但存在以下问题：</p><ul><li><strong>Prompt 重复劳动</strong>：每次都要输入一大段 Prompt。</li><li><strong>输出非结构化</strong>：生成的文本难以直接用于后续的数据存储或前端展示。</li><li><strong>响应缓慢</strong>：分析 JD、出技术题、出 HR 题、背调公司，如果串行执行，等待时间极长。</li></ul><p>本项目旨在通过<strong>工程化</strong>手段解决上述问题，构建一个<strong>可扩展、高并发、结构化输出</strong>的 AI Agent 后端。</p><hr><h2 id="2-技术架构设计-System-Architecture">2. 技术架构设计 (System Architecture)</h2><p>为了保证系统的可维护性和扩展性，本项目采用了<strong>分层架构 (Layered Architecture)</strong>。</p><h3 id="2-1-架构分层图">2.1 架构分层图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    Client[前端/客户端] --&gt;|HTTP/SSE| API[API Interface Layer]</span><br><span class="line">    </span><br><span class="line">    subgraph Backend [FastAPI Backend]</span><br><span class="line">        API --&gt; Service[Service Layer (Orchestration)]</span><br><span class="line">        </span><br><span class="line">        subgraph Parallel_Execution [异步并行执行区]</span><br><span class="line">            Task_A[JD Meta Parser]</span><br><span class="line">            Task_B[Tech Question Generator]</span><br><span class="line">            Task_C[Company Research Agent]</span><br><span class="line">        end</span><br><span class="line">        </span><br><span class="line">        Service --&gt; Task_A</span><br><span class="line">        Task_A --&gt; Task_B</span><br><span class="line">        Task_A --&gt; Task_C</span><br><span class="line">        </span><br><span class="line">        Task_B &amp; Task_C --&gt; Task_D[HR Question Generator]</span><br><span class="line">        </span><br><span class="line">        Task_B --&gt; Chains[LangChain Logic]</span><br><span class="line">        Task_C --&gt; Chains</span><br><span class="line">        </span><br><span class="line">        Chains --&gt; LLM_Factory[LLM Factory (OpenAI/DeepSeek)]</span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    Service --&gt;|Structured JSON| Client</span><br></pre></td></tr></table></figure><h3 id="2-2-核心组件">2.2 核心组件</h3><ul><li><strong>Web 框架</strong>: <code>FastAPI</code> (利用其原生异步特性处理 IO 密集型任务)。</li><li><strong>LLM 编排</strong>: <code>LangChain</code> (管理 Prompt、Chain 和 OutputParser)。</li><li><strong>数据验证</strong>: <code>Pydantic</code> (强制 LLM 输出符合 Schema 的 JSON)。</li><li><strong>并发控制</strong>: <code>Python Asyncio</code> (实现多 Chain 并行调用)。</li><li><strong>模型层</strong>: 支持 <code>OpenAI</code> 协议，实测完美兼容 <code>DeepSeek-V3</code>。</li></ul><hr><h2 id="3-核心实现细节-Implementation-Details">3. 核心实现细节 (Implementation Details)</h2><h3 id="3-1-强制结构化输出-Structured-Output">3.1 强制结构化输出 (Structured Output)</h3><p>大模型天生喜欢“聊天”，为了让它输出 JSON，我们摒弃了不稳定的正则表达式，转而使用 LangChain 的 <code>PydanticOutputParser</code>。</p><p><strong>Schema 定义 (<code>schemas/interview.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterviewReport</span>(<span class="title class_ inherited__">BaseModel</span>):</span><br><span class="line">    meta: JDMetaData</span><br><span class="line">    tech_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    hr_questions: <span class="type">List</span>[InterviewQuestion]</span><br><span class="line">    <span class="comment"># 使用 Optional 处理非必填项，增强鲁棒性</span></span><br><span class="line">    system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p><strong>Chain 实现 (<code>chains/tech_gen.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parser = PydanticOutputParser(pydantic_object=QuestionList)</span><br><span class="line">prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">    请严格按照 JSON 格式输出:</span></span><br><span class="line"><span class="string">    &#123;format_instructions&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 注入 Pydantic 生成的 Schema 指令</span></span><br><span class="line">chain = prompt | llm | parser</span><br></pre></td></tr></table></figure><h3 id="3-2-异步并发编排-Asyncio-Optimization">3.2 异步并发编排 (Asyncio Optimization)</h3><p>这是本项目性能提升的关键。</p><ul><li><strong>串行模式</strong>：解析 JD (5s) -&gt; 查公司 (10s) -&gt; 出技术题 (10s) -&gt; 出 HR 题 (5s) = <strong>30s+</strong></li><li><strong>并行模式</strong>：解析 JD (5s) -&gt; [查公司 | 出技术题] (同时进行, 取最大值 10s) -&gt; 出 HR 题 = <strong>约 15s</strong></li></ul><p><strong>Service 层实现 (<code>services/interview_service.py</code>):</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">generate_interview_guide</span>(<span class="params">request: JDRequest</span>):</span><br><span class="line">    <span class="comment"># 1. 前置依赖：必须先解析 JD</span></span><br><span class="line">    jd_meta = <span class="keyword">await</span> parse_jd_async(request.jd_text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 构造并行任务 (Fire tasks)</span></span><br><span class="line">    <span class="comment"># 技术题不依赖公司背景</span></span><br><span class="line">    task_tech = generate_tech_async(jd_meta.tech_stack, jd_meta.years_required)</span><br><span class="line">    <span class="comment"># 公司背调是网络 IO 密集型</span></span><br><span class="line">    task_research = research_company(jd_meta.company_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 核心：并发等待</span></span><br><span class="line">    tech_qs, company_info = <span class="keyword">await</span> asyncio.gather(task_tech, task_research)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 后置依赖：HR 题依赖公司背景</span></span><br><span class="line">    hr_qs = <span class="keyword">await</span> generate_hr_async(jd_meta.soft_skills, company_info)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> InterviewReport(...)</span><br></pre></td></tr></table></figure><h3 id="3-3-兼容多模型的-LLM-工厂">3.3 兼容多模型的 LLM 工厂</h3><p>为了在开发阶段节省成本（使用 DeepSeek），在生产阶段追求稳定（使用 OpenAI），我们设计了工厂模式。</p><p><strong>配置解耦 (<code>core/config.py</code>):</strong><br>通过 <code>.env</code> 文件动态切换底座，无需修改业务代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>(<span class="title class_ inherited__">BaseSettings</span>):</span><br><span class="line">    OPENAI_API_KEY: <span class="built_in">str</span></span><br><span class="line">    OPENAI_API_BASE: <span class="built_in">str</span> = <span class="string">&quot;https://api.deepseek.com&quot;</span> <span class="comment"># 默认指向 DeepSeek</span></span><br><span class="line">    MODEL_NAME: <span class="built_in">str</span> = <span class="string">&quot;deepseek-chat&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-工程化踩坑与解决方案-Troubleshooting">4. 工程化踩坑与解决方案 (Troubleshooting)</h2><p>在开发过程中，我们遇到了数个真实的工程挑战，以下是排查记录。</p><h3 id="坑位-1：API-余额与鉴权混淆-429-vs-402">坑位 1：API 余额与鉴权混淆 (429 vs 402)</h3><ul><li><strong>现象</strong>: 程序崩溃，报错 <code>openai.RateLimitError: Error code: 429</code> 或 <code>402 Payment Required</code>。</li><li><strong>分析</strong>:<ul><li><code>429</code> 通常指速率限制，但 OpenAI 在余额不足时也会报这个错（<code>insufficient_quota</code>）。</li><li><code>402</code> 是明确的余额为零。</li></ul></li><li><strong>解决</strong>:<ul><li>不要死磕代码逻辑。</li><li>切换至 <strong>DeepSeek</strong>（充值 10 元人民币可用很久）或 <strong>SiliconFlow</strong>（免费额度）。</li><li>修改 <code>.env</code> 即可解决。</li></ul></li></ul><h3 id="坑位-2：Pydantic-字段校验异常">坑位 2：Pydantic 字段校验异常</h3><ul><li><strong>现象</strong>: <code>ValidationError: system_design_question Input should be a valid dictionary</code>。</li><li><strong>分析</strong>: 业务逻辑中某些情况下未生成系统设计题，返回了 <code>None</code>，但 Schema 定义默认为必填。</li><li><strong>解决</strong>: 使用 <code>Optional</code> 类型提示。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line">system_design_question: <span class="type">Optional</span>[InterviewQuestion] = <span class="literal">None</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-3：SSL-证书警告-Mac-环境">坑位 3：SSL 证书警告 (Mac 环境)</h3><ul><li><strong>现象</strong>: <code>NotOpenSSLWarning: urllib3 v2 only supports OpenSSL 1.1.1+</code></li><li><strong>分析</strong>: macOS 自带的 LibreSSL 版本过低，与新版 <code>urllib3</code> 不兼容。</li><li><strong>解决</strong>: 降级 urllib3 或使用 Homebrew 升级 OpenSSL。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install <span class="string">&quot;urllib3&lt;2.0&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="坑位-4：Nginx-反向代理超时-504-Gateway-Time-out">坑位 4：Nginx 反向代理超时 (504 Gateway Time-out)</h3><ul><li><strong>现象</strong>: 爬虫或长文本生成任务耗时超过 60s，前端收到 504 错误。</li><li><strong>分析</strong>: Nginx 默认 <code>proxy_read_timeout</code> 为 60s。</li><li><strong>解决</strong>: 在 Nginx 配置中针对 API 路由增加超时时间。<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_read_timeout</span> <span class="number">600s</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="5-总结与展望">5. 总结与展望</h2><p><code>jd_agent</code> 项目展示了如何将一个简单的 Prompt 交互转化为一个<strong>工业级的后端服务</strong>。</p><p><strong>核心收益</strong>:</p><ol><li><strong>效率提升</strong>: 并行处理使响应速度提升 <strong>300%</strong>。</li><li><strong>成本降低</strong>: 通过 LLM 工厂模式切换至 DeepSeek，Token 成本降低 <strong>90%</strong>。</li><li><strong>稳定性</strong>: 强类型校验和重试机制保证了服务的鲁棒性。</li></ol><p><strong>后续规划</strong>:</p><ul><li>引入 <strong>Redis</strong> 缓存 JD 解析结果，避免重复扣费。</li><li>集成 <strong>Celery</strong> 处理超长耗时的系统设计题生成。</li><li>开发 <strong>React/Next.js</strong> 前端，实现流式 Markdown 渲染。</li></ul><hr><p><em>如果你觉得这个项目对你有帮助，欢迎在 GitHub 上点个 Star ⭐️！</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;GitHub 仓库&lt;/strong&gt;: &lt;a href=&quot;https://github.com/caozhaoqi/jd_agent&quot;&gt;https://github.com/caozhaoqi/jd_agent&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>实现高可用 MySQL 集群</title>
    <link href="https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/"/>
    <id>https://caozhaoqi.github.io/2025/09/30/mysql-cluster-use/</id>
    <published>2025-09-30T02:18:54.000Z</published>
    <updated>2025-11-25T15:05:10.334Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备阶段：项目结构">准备阶段：项目结构</h3><blockquote><p>首先，在您的服务器上创建一个项目文件夹，结构如下：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql_cluster/</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── proxysql/</span><br><span class="line">│   └── proxysql.cnf</span><br><span class="line">└── mysql/</span><br><span class="line">    ├── master/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── master.cnf</span><br><span class="line">    ├── slave1/</span><br><span class="line">    │   └── conf/</span><br><span class="line">    │       └── slave1.cnf</span><br><span class="line">    └── slave2/</span><br><span class="line">        └── conf/</span><br><span class="line">            └── slave2.cnf</span><br></pre></td></tr></table></figure><h3 id="阶段一：编写配置文件">阶段一：编写配置文件</h3><h4 id="1-主库配置-mysql-master-conf-master-cnf">1. 主库配置 (<code>mysql/master/conf/master.cnf</code>)</h4><p>这个文件定义了主库的特定配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">100</span></span><br><span class="line"><span class="attr">log-bin</span>                 = /var/lib/mysql/mysql-bin</span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：我们使用了 <code>GTID</code> 模式，这是比传统基于 <code>File</code> 和 <code>Position</code> 更现代、更可靠的复制方式。</p><h4 id="2-从库配置-mysql-slave1-conf-slave1-cnf-和-slave2-cnf">2. 从库配置 (<code>mysql/slave1/conf/slave1.cnf</code> 和 <code>slave2.cnf</code>)</h4><p>两个从库的配置类似，只需更改 <code>server-id</code>。</p><p><strong><code>slave1.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">101</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>slave2.cnf</code>:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">server-id</span>               = <span class="number">102</span></span><br><span class="line"><span class="attr">gtid-mode</span>               = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce-gtid-consistency</span>= <span class="literal">ON</span></span><br><span class="line"><span class="attr">read-only</span>               = <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="3-ProxySQL-配置-proxysql-proxysql-cnf">3. ProxySQL 配置 (<code>proxysql/proxysql.cnf</code>)</h4><p>这个文件用于初始化 ProxySQL 的配置。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">admin_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">admin_credentials</span>=<span class="string">&quot;admin:admin&quot;</span></span><br><span class="line">    <span class="attr">mysql_ifaces</span>=<span class="string">&quot;0.0.0.0:6032&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">mysql_variables</span>=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">connect_timeout_server</span>=<span class="number">3000</span></span><br><span class="line">    <span class="attr">monitor_username</span>=<span class="string">&quot;monitor_user&quot;</span></span><br><span class="line">    <span class="attr">monitor_password</span>=<span class="string">&quot;monitor_password&quot;</span></span><br><span class="line">    <span class="attr">monitor_connect_timeout</span>=<span class="number">2000</span></span><br><span class="line">    <span class="attr">monitor_ping_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_interval</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">monitor_read_only_timeout</span>=<span class="number">1000</span></span><br><span class="line">    <span class="attr">commands_stats</span>=<span class="string">&quot;enabled&quot;</span></span><br><span class="line">    <span class="attr">connect_timeout_server_max</span>=<span class="number">10000</span></span><br><span class="line">    <span class="attr">stacksize</span>=<span class="number">1048576</span></span><br><span class="line">    <span class="attr">threads</span>=<span class="number">4</span></span><br><span class="line">    <span class="attr">max_connections</span>=<span class="number">2048</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里我们定义了 ProxySQL 的管理用户 (<code>admin:admin</code>) 和一个用于监控后端 MySQL 健康状态的监控用户 (<code>monitor_user:monitor_password</code>)。</p><h4 id="4-Docker-Compose-文件-docker-compose-yml">4. Docker Compose 文件 (<code>docker-compose.yml</code>)</h4><p>这是整个架构的核心编排文件。它定义了所有的服务、网络和数据卷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 主数据库</span></span><br><span class="line">  <span class="attr">mysql_master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_master</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">my_app_db</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/master/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库1</span></span><br><span class="line">  <span class="attr">mysql_slave1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave1/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从数据库2</span></span><br><span class="line">  <span class="attr">mysql_slave2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql_slave2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">your_root_password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql/slave2/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2_data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># ProxySQL 中间件</span></span><br><span class="line">  <span class="attr">proxysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">proxysql/proxysql:2.4.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6032:6032&quot;</span> <span class="comment"># 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6033:6033&quot;</span> <span class="comment"># 客户端连接端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./proxysql/proxysql.cnf:/etc/proxysql.cnf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">proxysql_data:/var/lib/proxysql</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_cluster_net</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_slave2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据卷</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_master_data:</span></span><br><span class="line">  <span class="attr">mysql_slave1_data:</span></span><br><span class="line">  <span class="attr">mysql_slave2_data:</span></span><br><span class="line">  <span class="attr">proxysql_data:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">mysql_cluster_net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p><strong>请务必将 <code>your_root_password</code> 替换为您自己的强密码。</strong></p><h3 id="阶段二：启动和配置集群">阶段二：启动和配置集群</h3><ol><li><p><strong>启动所有服务</strong>：<br>在 <code>mysql_cluster</code> 文件夹下，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>Docker 会自动拉取镜像并按顺序启动所有容器。</p></li><li><p><strong>配置主从复制</strong>：<br>我们需要进入主库容器，创建复制用户和 ProxySQL 的监控用户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入主库容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_master bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment"># (输入您在docker-compose中设置的密码)</span></span><br></pre></td></tr></table></figure><p>在MySQL命令行中执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复制用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;repl_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;repl_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建ProxySQL监控用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;monitor_password&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> USAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monitor_user&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p><strong>现在，配置两个从库</strong>。进入每个从库容器，执行 <code>CHANGE MASTER TO</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入从库1容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_slave1 bash</span><br><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>在从库1的MySQL命令行中执行（对从库2重复此操作）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用GTID自动定位，比File/Position更简单</span></span><br><span class="line">CHANGE MASTER <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST<span class="operator">=</span><span class="string">&#x27;mysql_master&#x27;</span>,  <span class="comment">-- 使用Docker的服务名</span></span><br><span class="line">  MASTER_USER<span class="operator">=</span><span class="string">&#x27;repl_user&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD<span class="operator">=</span><span class="string">&#x27;repl_password&#x27;</span>,</span><br><span class="line">  MASTER_AUTO_POSITION<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> SLAVE;</span><br><span class="line"><span class="comment">-- 验证状态</span></span><br><span class="line"><span class="keyword">SHOW</span> SLAVE STATUS\G; </span><br></pre></td></tr></table></figure><p>在从库2上重复以上 <code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 的步骤。</p></li><li><p><strong>配置 ProxySQL</strong>：<br>连接到 ProxySQL 的管理后台。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，是从您的宿主机连接，不是在容器里</span></span><br><span class="line">mysql -u admin -padmin -h 127.0.0.1 -P 6032</span><br></pre></td></tr></table></figure><p>在 ProxySQL 管理后台执行以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置监控用户凭证（与proxysql.cnf和MySQL中创建的一致）</span></span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_user&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_username&#x27;</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> global_variables <span class="keyword">SET</span> variable_value<span class="operator">=</span><span class="string">&#x27;monitor_password&#x27;</span> <span class="keyword">WHERE</span> variable_name<span class="operator">=</span><span class="string">&#x27;mysql-monitor_password&#x27;</span>;</span><br><span class="line">LOAD MYSQL VARIABLES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置后端MySQL服务器</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_servers(hostgroup_id, hostname, port) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;mysql_master&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 写入组 (主库)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave1&#x27;</span>, <span class="number">3306</span>), <span class="comment">-- 读取组 (从库1)</span></span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;mysql_slave2&#x27;</span>, <span class="number">3306</span>); <span class="comment">-- 读取组 (从库2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 配置应用连接用户</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_users(username, password, default_hostgroup) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;app_user&#x27;</span>, <span class="string">&#x27;app_password&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 定义读写分离规则</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mysql_query_rules(rule_id, active, match_digest, destination_hostgroup, apply) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;^SELECT.*&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&#x27;.*&#x27;</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">-- 一个更简单的规则：匹配SELECT的去读取组，其他所有都去写入组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 加载并保存配置</span></span><br><span class="line">LOAD MYSQL SERVERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL USERS <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">LOAD MYSQL QUERY RULES <span class="keyword">TO</span> RUNTIME;</span><br><span class="line">SAVE MYSQL SERVERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL USERS <span class="keyword">TO</span> DISK;</span><br><span class="line">SAVE MYSQL QUERY RULES <span class="keyword">TO</span> DISK;</span><br></pre></td></tr></table></figure></li></ol><h3 id="proxy-sql-web">proxy-sql-web</h3><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxysql-web:</span></span><br><span class="line">    <span class="comment"># --- 修改点在这里 ---</span></span><br><span class="line">    <span class="comment"># 使用一个在 Docker Hub 上公开可用的镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kishorj/proxysql-web:latest</span></span><br><span class="line">    <span class="comment"># ------------------</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxysql-web</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=192.168.10.158</span> <span class="comment"># 您的 ProxySQL 服务器 IP</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=6032</span>         <span class="comment"># ProxySQL 管理端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=admin</span>          <span class="comment"># ProxySQL 管理用户名</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=admin</span>          <span class="comment"># ProxySQL 管理密码</span></span><br></pre></td></tr></table></figure><ul><li>run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="阶段三：切换应用">阶段三：切换应用</h3><p>现在，您的整个高可用集群已经在 Docker 中运行起来了。最后一步就是将您所有200多台电脑上的应用程序的数据库连接配置，指向 ProxySQL 容器暴露的端口。</p><ul><li><strong>Host</strong>: 运行 Docker 的那台服务器的 IP 地址。</li><li><strong>Port</strong>: <code>6033</code></li><li><strong>User</strong>: <code>app_user</code></li><li><strong>Password</strong>: <code>app_password</code></li></ul><h3 id="优点总结">优点总结</h3><ul><li><strong>环境一致性</strong>：无论部署到哪台机器，整个集群的环境都是完全一致的。</li><li><strong>快速部署与销毁</strong>：使用 <code>docker-compose up -d</code> 和 <code>docker-compose down -v</code> 可以秒级创建和彻底销毁整套环境，非常适合测试和开发。</li><li><strong>简化管理</strong>：服务之间的网络和依赖关系由 Docker Compose 管理，比手动配置网络和防火墙简单得多。</li><li><strong>资源隔离</strong>：每个服务都在自己的容器中运行，互不干扰。</li></ul><p>这个 Docker 化的方案为您提供了一个可移植、可复现、高度自动化的方式来部署和管理您的MySQL读写分离集群。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;准备阶段：项目结构&quot;&gt;准备阶段：项目结构&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，在您的服务器上创建一个项目文件夹，结构如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用Devpi与Nginx构建高可用PyPI镜像源</title>
    <link href="https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/"/>
    <id>https://caozhaoqi.github.io/2025/09/17/pypi-mirror-self/</id>
    <published>2025-09-17T06:03:20.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Devpi与Nginx构建高可用PyPI镜像源">使用Devpi与Nginx构建高可用PyPI镜像源</h2><h3 id="前言：为什么你的pip-install又超时了？">前言：为什么你的<code>pip install</code>又超时了？</h3><p>对于每一位Python开发者来说，<code>pip install</code> 无疑是最常用的命令之一。然而，团队开发中，我们常常会遇到这些痛点：</p><ul><li><strong>速度瓶颈</strong>：团队几十号人，CI/CD流水线上百个任务，全都从国外的官方PyPI源拉取包，下载速度慢得令人抓狂，严重影响开发和部署效率。</li><li><strong>单点故障</strong>：官方PyPI偶尔会抖动，或者公司出口网络出现问题，导致所有依赖安装失败，研发流程瞬间停摆。</li><li><strong>安全与合规</strong>：无法对团队使用的第三方包进行统一管理和安全审计。</li><li><strong>私有包托管</strong>：团队内部开发的公共库无处安放，只能通过Git仓库等原始方式共享。</li></ul><p>为了彻底解决这些问题，我们需要一个<strong>私有的、高速的、且永不宕机</strong>的Python包仓库。今天，我将手把手带你使用业界最强大的开源工具 <strong><code>devpi</code></strong> 和 <strong><code>Nginx</code></strong>，构建一个具备自动故障转移能力的高可用PyPI镜像源。</p><p><strong>最终目标</strong>：无论清华源、阿里源还是其他任何一个镜像挂了，我们的 <code>pip install</code> 依然能丝滑流畅地运行，对开发者完全透明！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-------------------+     +-------------------------+     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |   Tsinghua Mirror       |</span><br><span class="line">|  开发者   | --&gt; |  devpi 服务器      | --&gt; |  Nginx 反向代理          | --&gt; |  (Upstream 1)            |</span><br><span class="line">| (pip)     |     | (缓存/私有包)      |     | (处理上游故障转移)       |     +--------------------------+</span><br><span class="line">|           |     |                   |     |                         |     |  Aliyun Mirror         |</span><br><span class="line">+-----------+     +-------------------+     +-------------------------+ --&gt; |  (Upstream 2)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  USTC Mirror             |</span><br><span class="line">                                                                          -&gt;|  (Upstream 3)            |</span><br><span class="line">                                                                            +--------------------------+</span><br><span class="line">                                                                            |  ... and so on           |</span><br><span class="line">                                                                            +--------------------------+</span><br></pre></td></tr></table></figure><h3 id="第一章：核心武器介绍-Devpi-与-Nginx">第一章：核心武器介绍 - Devpi 与 Nginx</h3><p>在开始之前，我们先了解一下两位主角：</p><ol><li><p><strong>Devpi</strong>: 一个功能完备的Python包服务器。它不仅仅是 <code>pypi.org</code> 的一个缓存代理，更是一个强大的私有包仓库和版本发布管理工具。我们将主要利用它的<strong>缓存镜像</strong>功能。</p></li><li><p><strong>Nginx</strong>: 一款高性能的HTTP和反向代理服务器。在这里，它将扮演我们镜像源的“智能调度员”和“故障哨兵”，负责监测上游镜像源的健康状况，并在某个源出现问题时，自动将流量切换到健康的备用源上。</p></li></ol><h3 id="第二章：基础建设-搭建Devpi缓存服务器">第二章：基础建设 - 搭建Devpi缓存服务器</h3><p>首先，我们需要一个能稳定运行的<code>devpi</code>服务。</p><h4 id="步骤-1-准备服务器与安装Devpi">步骤 1: 准备服务器与安装Devpi</h4><p>在一台Linux服务器（本教程以Ubuntu为例）上，确保已安装Python和pip。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新并安装依赖</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y python3 python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 devpi-server</span></span><br><span class="line">pip3 install devpi-server</span><br><span class="line"></span><br><span class="line">devpi-init</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="步骤-2-初始化Devpi">步骤 2: 初始化Devpi</h4><p>这个一次性操作会为你创建数据目录和 <code>root</code> 超级管理员。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devpi-init</span><br></pre></td></tr></table></figure><p>在提示中，为 <code>root</code> 用户设置一个安全的密码，并牢牢记住它。</p><h4 id="步骤-3-让Devpi在后台稳定运行">步骤 3: 让Devpi在后台稳定运行</h4><p>为了生产环境的稳定，我们将 <code>devpi</code> 配置成一个 <code>systemd</code> 系统服务，实现开机自启和后台运行。</p><ol><li><p><strong>创建服务文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下配置</strong> (注意修改 <code>User</code> 和 <code>ExecStart</code> 中的路径为你自己的):</p></li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ sudo cat /etc/systemd/system/devpi.service</span><br><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=devpi-server daemon</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=czq2</span><br><span class="line"><span class="attr">Group</span>=czq2</span><br><span class="line"><span class="attr">ExecStart</span>=/home/czq2/clip-video/venv/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span></span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartSec</span>=<span class="number">5</span>s</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><code>--host=0.0.0.0</code> 确保局域网内的其他机器可以访问。</li></ul><ol start="3"><li><strong>启动并验证服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> devpi  <span class="comment"># 开机自启</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi   <span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl status devpi  <span class="comment"># 检查状态</span></span><br></pre></td></tr></table></figure>看到绿色的 <code>active (running)</code>，恭喜你，基础的 <code>devpi</code> 镜像服务已经成功运行在 <code>http://&lt;你的服务器IP&gt;:3141</code> 上了！</li></ol><ul><li>成功输出</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl start devpi</span><br><span class="line">(venv) czq2@czq2:~/clip-video$ <span class="built_in">sudo</span> systemctl status devpi</span><br><span class="line">● devpi.service - devpi-server daemon</span><br><span class="line">     Loaded: loaded (/etc/systemd/system/devpi.service; enabled; preset: enabled)</span><br><span class="line">     Active: active (running) since Wed 2025-09-17 07:19:23 UTC; 3s ago</span><br><span class="line">   Main PID: 1619813 (devpi-server)</span><br><span class="line">      Tasks: 54 (<span class="built_in">limit</span>: 309293)</span><br><span class="line">     Memory: 41.4M (peak: 553.5M)</span><br><span class="line">        CPU: 15.733s</span><br><span class="line">     CGroup: /system.slice/devpi.service</span><br><span class="line">             └─1619813 /home/czq2/clip-video/venv/bin/python3 /home/czq2/clip-video/venv/bin/devpi-server --host=0.0.0.0 --p&gt;</span><br><span class="line"></span><br><span class="line">Sep 17 07:19:23 czq2 devpi-server[1619813]: 2025-09-17 07:19:23,634 WARNI NOCTX No secret file provided, creating a new rand&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,757 INFO  [ASYN] Starting asyncio event loop</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX devpi-server version: 6.17.0</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serverdir: /home/czq2/.devpi/server</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX uuid: 0c7aa3d0d1874fd596c8936cd007d305</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX serving at url: http://0.0.0.0:3141 (might b&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX using 50 threads</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX bug tracker: https://github.com/devpi/devpi/&gt;</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,777 INFO  NOCTX Hit Ctrl-C to quit.</span><br><span class="line">Sep 17 07:19:25 czq2 devpi-server[1619813]: 2025-09-17 07:19:25,785 INFO  Serving on http://0.0.0.0:3141</span><br></pre></td></tr></table></figure><ul><li>错误分析</li></ul> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> journalctl -u devpi.service -n 50 --no-pager</span><br></pre></td></tr></table></figure><h3 id="第三章：构建护城河-Nginx高可用反向代理">第三章：构建护城河 - Nginx高可用反向代理</h3><p>现在，我们要为 <code>devpi</code> 构建一个坚固的前哨站，让它不再直接依赖任何单一的上游源。</p><h4 id="步骤-1-安装-Nginx">步骤 1: 安装 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nginx</span><br></pre></td></tr></table></figure><h4 id="步骤-2-编写Nginx高可用配置">步骤 2: 编写Nginx高可用配置</h4><p>这是实现自动故障转移的<strong>核心</strong>。</p><ol><li><p><strong>创建Nginx配置文件</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/nginx/sites-available/pypi-proxy</span><br></pre></td></tr></table></figure></li><li><p><strong>粘贴以下魔法配置</strong>:</p></li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /etc/nginx/sites-available/pypi-proxy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 定义一个上游服务器组，这次全部使用 HTTPS</span></span><br><span class="line"></span><br><span class="line"><span class="section">upstream</span> pypi_mirrors_https &#123;</span><br><span class="line">    <span class="comment"># 【核心修改】直接指向 HTTPS 域名，端口 443 是默认的，可以不写</span></span><br><span class="line">    <span class="attribute">server</span> pypi.tuna.tsinghua.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.aliyun.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> pypi.mirrors.ustc.edu.cn:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> mirrors.cloud.tencent.com:<span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server</span> repo.huaweicloud.com:<span class="number">443</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8888</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># 【核心修改】将请求代理到我们新的 HTTPS 服务器组</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 故障转移的配置保持不变</span></span><br><span class="line">        <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 【重要】当代理到 HTTPS 上游时，必须正确设置 Host 头</span></span><br><span class="line">        <span class="comment"># 这里的 $host 会是上游服务器组的名称，为了正确性，我们应该传递原始请求的Host</span></span><br><span class="line">        <span class="comment"># 或者直接硬编码为 pypi.tuna.tsinghua.edu.cn 等，但传递原始Host更灵活</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>; <span class="comment"># 使用 $proxy_host 变量</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># （可选，但推荐）增加 SSL 相关的代理设置</span></span><br><span class="line">        <span class="attribute">proxy_ssl_server_name</span> <span class="literal">on</span>; <span class="comment"># 这会让Nginx在TLS握手中发送正确的服务器名称(SNI)</span></span><br><span class="line">        <span class="attribute">proxy_ssl_session_reuse</span> <span class="literal">on</span>; <span class="comment"># 启用SSL会话复用以提高性能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>启用配置并重启Nginx</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">ln</span> -s /etc/nginx/sites-available/pypi-proxy /etc/nginx/sites-enabled/</span><br><span class="line"><span class="built_in">sudo</span> nginx -t          <span class="comment"># 测试配置语法</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart nginx <span class="comment"># 重启Nginx</span></span><br></pre></td></tr></table></figure>现在，一个强大的、能自动切换源的反向代理已经在 <code>http://192.168.10.158:8088</code> 上为你待命。</li></ol><hr><h3 id="第四章：合体！将Devpi接入Nginx代理">第四章：合体！将Devpi接入Nginx代理</h3><p>万事俱备，只差最后一步：让 <code>devpi</code> 通过我们的 Nginx “护城河”去访问世界。</p><ol><li><p><strong>停止Devpi服务</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl stop devpi</span><br></pre></td></tr></table></figure></li><li><p><strong>修改Devpi的启动参数</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/systemd/system/devpi.service</span><br></pre></td></tr></table></figure></li><li><p>在 <code>ExecStart</code> 行的末尾，添加 <code>--mirror-url</code> 参数，指向我们的Nginx代理：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="attr">ExecStart</span>=/home/your_username/.local/bin/devpi-server --host=<span class="number">0.0</span>.<span class="number">0.0</span> --port=<span class="number">3141</span> --mirror-url http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">8088</span>/pypi</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重新加载并启动Devpi</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl start devpi</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="第五章：享受成果-配置客户端">第五章：享受成果 - 配置客户端</h3><p>现在，让团队的所有开发者和CI/CD服务器都享受到这个稳定高速的镜像源吧！</p><p>在每一台客户端机器上，创建或修改 <code>~/.pip/pip.conf</code> (macOS/Linux) 或 <code>%APPDATA%\pip\pip.ini</code> (Windows) 文件：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = http://<span class="number">192.168</span>.<span class="number">10.158</span>:<span class="number">3141</span>/root/pypi/</span><br><span class="line"><span class="attr">trusted-host</span> = <span class="number">192.168</span>.<span class="number">10.158</span></span><br></pre></td></tr></table></figure><ul><li><code>index-url</code> 指向我们搭建的 <code>devpi</code> 服务。</li><li><code>trusted-host</code> 告诉 <code>pip</code> 这是一个可信任的HTTP源。</li></ul><h3 id="使用docker-compose-搭建-devpi">使用docker compose 搭建 devpi</h3><ul><li>docker-comose.yml</li></ul> <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 属性已过时，可以移除</span></span><br><span class="line"><span class="comment"># version: &quot;2.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 服务1：高可用 Nginx 反向代理</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们的 stream 配置文件挂载到容器中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="comment"># 这个服务只在内部使用，不需要暴露端口到宿主机</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 服务2：Devpi 服务器</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lowinli98/devpi:v0.2</span></span><br><span class="line">    <span class="attr">expose:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">7104</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_HOST=0.0.0.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PORT=7104</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_ROOT_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_USER=czq</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_PASSWORD=111</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_MIRROR_INDEX=pypi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEVPISERVER_LIB_INDEX=devpi</span></span><br><span class="line">      <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">      <span class="comment"># 将上游镜像源指向我们内部的 nginx-proxy 服务的 443 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SOURCE_MIRROR_URL=http://nginx-proxy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="comment"># 【重要】确保 devpi 服务依赖于 nginx-proxy 服务</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br></pre></td></tr></table></figure><ul><li>nignx conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># nginx_conf/nginx.conf (HTTP 代理版本)</span><br><span class="line"></span><br><span class="line">events &#123;&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 定义高可用的 PyPI 镜像上游服务器池</span><br><span class="line">    upstream pypi_mirrors_https &#123;</span><br><span class="line">        server pypi.tuna.tsinghua.edu.cn:443;</span><br><span class="line">        server mirrors.aliyun.com:443;</span><br><span class="line">        server pypi.mirrors.ustc.edu.cn:443;</span><br><span class="line">        server mirrors.cloud.tencent.com:443;</span><br><span class="line">        server pypi.douban.com:443;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # 监听容器内部的 80 端口，接收来自 devpi-lib 的 HTTP 请求</span><br><span class="line">        listen 80;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            # 将请求代理到 HTTPS 上游</span><br><span class="line">            proxy_pass https://pypi_mirrors_https;</span><br><span class="line"></span><br><span class="line">            # --- 代理核心配置 ---</span><br><span class="line">            proxy_next_upstream error timeout http_502 http_503 http_504;</span><br><span class="line">            proxy_connect_timeout 10s;</span><br><span class="line"></span><br><span class="line">            # --- 关键的请求头与 SSL/TLS 配置 ---</span><br><span class="line">            proxy_set_header Host $proxy_host;</span><br><span class="line">            proxy_ssl_server_name on;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">            proxy_ssl_session_reuse on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>docker run</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build</span><br></pre></td></tr></table></figure><h3 id="自建devpi镜像">自建devpi镜像</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终稳定版)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个官方的、轻量级的 Python 3.9 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置容器内的工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【构建时网络优化】</span></span><br><span class="line"><span class="comment"># 将 pip 的默认源设置为高速的镜像源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【核心 Bug 修复 &amp; 版本锁定】 ---</span></span><br><span class="line"><span class="comment"># 安装应用程序及其依赖，并锁定所有核心组件的版本</span></span><br><span class="line"><span class="comment"># devpi-server 6.9.x 是一个非常稳定的系列</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据卷挂载点</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【权限修复】</span></span><br><span class="line"><span class="comment"># 将数据目录的所有者更改为非 root 用户 (UID 1000)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R 1000:1000 /var/lib/devpi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 【安全实践】</span></span><br><span class="line"><span class="comment"># 将容器的默认运行用户切换为非 root 用户</span></span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明容器将要监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义容器启动时要执行的默认命令</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;devpi-server&quot;</span>, <span class="string">&quot;--serverdir&quot;</span>, <span class="string">&quot;/var/lib/devpi&quot;</span>, <span class="string">&quot;--host&quot;</span>, <span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7104&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (最终、决定性版本)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx-proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-nginx-proxy</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./nginx_conf/nginx.conf:/etc/nginx/nginx.conf:ro</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="comment"># --- 【核心修改】---</span></span><br><span class="line">    <span class="comment"># 不再使用旧的 image，而是使用 build 指令</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span>  <span class="comment"># 表示使用当前目录下的 Dockerfile 来构建镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="comment"># 【重要】我们不再需要旧镜像的环境变量来自动化配置</span></span><br><span class="line">    <span class="comment"># 我们将在启动后，手动进行一次性配置，这更可靠</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">        <span class="comment"># environment:</span></span><br><span class="line">    <span class="comment">#   - ... (可以全部删除)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 数据卷依然需要，用于持久化 devpi 的数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./volume:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx-proxy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol><li><strong>在你的客户端电脑上，安装 <code>devpi-client</code></strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> -R czq2:czq2 ./volume <span class="comment"># 更改目录权限</span></span><br><span class="line">pip install devpi-client</span><br></pre></td></tr></table></figure></li><li><ol start="2"><li><strong>登录到你的新 <code>devpi</code> 服务器</strong>:</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指向服务器</span></span><br><span class="line">devpi use http://&lt;你的服务器IP&gt;:7104</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首次登录 root 用户，devpi-server 会自动创建，无需密码</span></span><br><span class="line"><span class="comment"># 然后会强制你设置新密码</span></span><br><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># (按照提示输入你的新 root 密码)</span></span><br></pre></td></tr></table></figure></li><li><ol start="3"><li><strong>【关键】配置 <code>root/pypi</code> 镜像</strong>:<br>默认的 <code>root/pypi</code> 指向 <code>pypi.org</code>。我们需要将它修改为指向我们内部的 <code>nginx-proxy</code>。</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 确保你已登录 root</span></span><br><span class="line">devpi index root/pypi mirror_url=http://nginx-proxy</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>: 这里的 <code>http://nginx-proxy</code> 是 <code>devpi-lib</code> 容器内部访问 <code>nginx-proxy</code> 容器的地址。<code>devpi-server</code> 在收到这个配置后，它内部发起的请求就会走这条路。</li></ul></li><li><ol start="4"><li><strong>验证</strong>:<br>在你的客户端电脑上，配置好 <code>pip</code> 指向 <code>http://&lt;服务器IP&gt;:7104/root/pypi/</code>，然后执行 <code>pip install numpy</code>。</li></ol></li></ul><h3 id="成功日志">成功日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(.venv) czq2@czq2:~/pypi-docker$ sudo docker logs devpi-lib</span><br><span class="line">2025-09-22 02:56:36,728 INFO  [req12] POST /+login</span><br><span class="line">2025-09-22 02:57:08,329 INFO  [req13] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:08,339 INFO  [req14] PATCH /root/pypi</span><br><span class="line">2025-09-22 02:57:08,342 INFO  [req14] [Wtx13] modified index root/pypi: &#123;&#x27;type&#x27;: &#x27;mirror&#x27;, &#x27;volatile&#x27;: False, &#x27;title&#x27;: &#x27;PyPI&#x27;, &#x27;mirror_url&#x27;: &#x27;http://mirrors.aliyun.com/pypi/simple/&#x27;, &#x27;mirror_web_url_fmt&#x27;: &#x27;https://pypi.org/project/&#123;name&#125;/&#x27;&#125;</span><br><span class="line">2025-09-22 02:57:08,345 INFO  [req14] [Wtx13] fswriter14: committed at 14</span><br><span class="line">2025-09-22 02:57:08,351 INFO  [req15] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:25,788 INFO  [req16] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:40,843 INFO  [req17] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:57:41,058 INFO  [req18] GET /root</span><br><span class="line">2025-09-22 02:57:41,533 INFO  [req19] GET /+static-4.1.0/favicon.ico</span><br><span class="line">2025-09-22 02:57:43,732 INFO  [Wtx14] fswriter15: committed at 15</span><br><span class="line">2025-09-22 02:57:43,885 INFO  [NOTI] [Rtx15] indexing &#x27;root/pypi&#x27; mirror with 658356 projects</span><br><span class="line">2025-09-22 02:57:44,305 INFO  [IDX] Indexer queue size ~ 2</span><br><span class="line">2025-09-22 02:57:46,680 INFO  [req20] GET /root</span><br><span class="line">2025-09-22 02:57:47,303 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:57:47,410 INFO  [req21] GET /root/pypi</span><br><span class="line">2025-09-22 02:57:48,180 INFO  [req22] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:48,183 INFO  [req22] starting +simple</span><br><span class="line">2025-09-22 02:57:52,640 INFO  [req23] GET /root/pypi/+simple/</span><br><span class="line">2025-09-22 02:57:52,643 INFO  [req23] starting +simple</span><br><span class="line">2025-09-22 02:58:00,856 INFO  [IDX] Indexer queue size ~ 23</span><br><span class="line">2025-09-22 02:58:03,872 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:13,593 INFO  [IDX] Indexer queue size ~ 43</span><br><span class="line">2025-09-22 02:58:16,637 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:24,550 INFO  [IDX] Indexer queue size ~ 63</span><br><span class="line">2025-09-22 02:58:27,063 INFO  [req24] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:58:27,068 INFO  [req24] starting +simple</span><br><span class="line">2025-09-22 02:58:31,043 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:36,905 INFO  [IDX] Indexer queue size ~ 84</span><br><span class="line">2025-09-22 02:58:40,109 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:46,493 INFO  [IDX] Indexer queue size ~ 105</span><br><span class="line">2025-09-22 02:58:49,808 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:58:57,171 INFO  [req25] GET /root/pypi/opencv-python/</span><br><span class="line">2025-09-22 02:58:57,452 INFO  [req26] GET /root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:57,703 INFO  [req26] [Rtx15] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/68/1f/795e7f4aa2eacc59afa4fb61a2e35e510d06414dd5a802b51a012d691b37/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl&#x27;), target root/pypi/+f/092/c16da4c5a163a/opencv_python-4.12.0.88-cp37-abi3-manylinux2014_x86_64.manylinux_2_17_x86_64.whl</span><br><span class="line">2025-09-22 02:58:58,698 INFO  [IDX] Indexer queue size ~ 125</span><br><span class="line">2025-09-22 02:59:02,452 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:13,134 INFO  [Wtx15] fswriter16: committed at 16</span><br><span class="line">2025-09-22 02:59:13,406 INFO  [req27] GET /root/pypi/numpy/</span><br><span class="line">2025-09-22 02:59:16,152 INFO  [IDX] Indexer queue size ~ 144</span><br><span class="line">2025-09-22 02:59:20,559 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:22,506 INFO  [Wtx16] fswriter17: committed at 17</span><br><span class="line">2025-09-22 02:59:22,974 INFO  [req28] GET /root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:23,201 INFO  [req28] [Rtx17] reading remote: URL(&#x27;http://mirrors.aliyun.com/pypi/packages/8c/3d/1e1db36cfd41f895d266b103df00ca5b3cbe965184df824dec5c08c6b803/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl&#x27;), target root/pypi/+f/fd8/3c01228a68873/numpy-2.2.6-cp312-cp312-manylinux_2_17_x86_64.manylinux2014_x86_64.whl</span><br><span class="line">2025-09-22 02:59:25,317 INFO  [Wtx17] fswriter18: committed at 18</span><br><span class="line">2025-09-22 02:59:29,854 INFO  [IDX] Indexer queue size ~ 157</span><br><span class="line">2025-09-22 02:59:32,438 INFO  [req29] GET /czq/devpi</span><br><span class="line">2025-09-22 02:59:33,214 INFO  [req30] GET /czq/devpi/+simple/</span><br><span class="line">2025-09-22 02:59:33,219 INFO  [req30] starting +simple</span><br><span class="line">2025-09-22 02:59:33,222 WARNI [req30] [Rtx18] Index czq/devpi refers to non-existing base czq/pypi.</span><br><span class="line">2025-09-22 02:59:33,419 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:35,333 INFO  [req31] GET /root/dev</span><br><span class="line">2025-09-22 02:59:36,071 INFO  [req32] GET /root/dev/+simple/</span><br><span class="line">2025-09-22 02:59:36,073 INFO  [req32] starting +simple</span><br><span class="line">2025-09-22 02:59:45,543 INFO  [IDX] Indexer queue size ~ 183</span><br><span class="line">2025-09-22 02:59:49,092 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 02:59:59,191 INFO  [IDX] Indexer queue size ~ 204</span><br><span class="line">2025-09-22 02:59:59,375 INFO  [req33] GET /</span><br><span class="line">2025-09-22 03:00:02,409 INFO  [req34] GET /+search</span><br><span class="line">2025-09-22 03:00:03,190 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:12,782 INFO  [IDX] Indexer queue size ~ 223</span><br><span class="line">2025-09-22 03:00:16,424 INFO  [IDX] Committing 2500 new documents to search index.</span><br><span class="line">2025-09-22 03:00:22,925 INFO  [IDX] Indexer queue size ~ 243</span><br></pre></td></tr></table></figure><h2 id="python-搭建高可用">python 搭建高可用</h2><ul><li>python flask</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ha_proxy.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Response, request</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 高可用镜像源列表 ---</span></span><br><span class="line"><span class="comment"># 将按照这个顺序尝试。可以随意增删或调整顺序。</span></span><br><span class="line">UPSTREAM_MIRRORS = [</span><br><span class="line">    <span class="string">&quot;https://pypi.tuna.tsinghua.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.aliyun.com/pypi/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://pypi.mirrors.ustc.edu.cn/simple&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://mirrors.cloud.tencent.com/pypi/simple&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接和读取的超时时间（秒）</span></span><br><span class="line">TIMEOUT = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&lt;path:path&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proxy</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收来自 devpi-server 的所有请求，并尝试从上游镜像列表中获取。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> base_url <span class="keyword">in</span> UPSTREAM_MIRRORS:</span><br><span class="line">        url = <span class="string">f&quot;<span class="subst">&#123;base_url&#125;</span>/<span class="subst">&#123;path&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Attempting to fetch from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># `requests` 会自动使用 HTTP_PROXY/HTTPS_PROXY 环境变量</span></span><br><span class="line">            response = requests.get(url, timeout=TIMEOUT, stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果请求成功 (例如 200 OK)</span></span><br><span class="line">            <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Success from <span class="subst">&#123;url&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="comment"># 使用流式响应，避免大文件占用过多内存</span></span><br><span class="line">                <span class="keyword">return</span> Response(response.iter_content(chunk_size=<span class="number">8192</span>),</span><br><span class="line">                                status=response.status_code,</span><br><span class="line">                                content_type=response.headers[<span class="string">&#x27;Content-Type&#x27;</span>])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是 404，说明这个源没有这个包，立即尝试下一个</span></span><br><span class="line">            <span class="keyword">elif</span> response.status_code == <span class="number">404</span>:</span><br><span class="line">                 <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got 404 from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                 <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 其他客户端错误，也尝试下一个</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Got client error <span class="subst">&#123;response.status_code&#125;</span> from <span class="subst">&#123;url&#125;</span>, trying next mirror.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 捕获所有网络层面的错误 (如超时、连接失败)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: Failed to connect to <span class="subst">&#123;base_url&#125;</span>. Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment"># 继续下一个循环</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果所有镜像源都尝试失败</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;HA-PROXY: All upstream mirrors failed for path: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&quot;All upstream mirrors failed.&quot;</span>, status=<span class="number">502</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 监听在 8000 端口，只接受来自容器内部的连接</span></span><br><span class="line">    app.run(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure><ul><li>supervisord.conf</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">; supervisord.conf (最终生产版)</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">nodaemon=true</span><br><span class="line"></span><br><span class="line">[program:devpi]</span><br><span class="line">command=devpi-server --serverdir /var/lib/devpi --host 0.0.0.0 --port 7104</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/devpi_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/devpi_out.log</span><br><span class="line"></span><br><span class="line">[program:ha_proxy]</span><br><span class="line">command=python3 /app/ha_proxy.py</span><br><span class="line">user=devpiuser ; &lt;--- 修改这里</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br><span class="line">stderr_logfile=/var/log/supervisor/ha_proxy_err.log</span><br><span class="line">stdout_logfile=/var/log/supervisor/ha_proxy_out.log</span><br></pre></td></tr></table></figure><h3 id="同步更新dockerfile和docker-compose-yml">同步更新dockerfile和docker-compose.yml</h3><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile (最终生产版)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list.d/debian.sources</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 【关键修复】创建一个专用的非 root 用户 ---</span></span><br><span class="line"><span class="comment"># 创建一个名为 devpiuser 的系统组和用户，并指定其 ID 为 1000</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> adduser \</span></span><br><span class="line"><span class="language-bash">    --system \</span></span><br><span class="line"><span class="language-bash">    --group \</span></span><br><span class="line"><span class="language-bash">    --uid 1000 \</span></span><br><span class="line"><span class="language-bash">    --no-create-home \</span></span><br><span class="line"><span class="language-bash">    --disabled-password \</span></span><br><span class="line"><span class="language-bash">    devpiuser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 安装所有依赖 ---</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y supervisor &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir --upgrade pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install --no-cache-dir \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-server==6.9.2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;devpi-web==4.1.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;httpx==0.22.0&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;flask&quot;</span> \</span></span><br><span class="line"><span class="language-bash">        <span class="string">&quot;requests&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 复制配置文件和脚本 ---</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ha_proxy.py /app/ha_proxy.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 权限修复 ---</span></span><br><span class="line"><span class="comment"># 使用新创建的用户名 devpiuser 来设置权限</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /var/log/supervisor</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/lib/devpi</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R devpiuser:devpiuser /var/log/supervisor</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 容器将以 root 启动，由 supervisor 负责降权</span></span><br><span class="line"><span class="comment"># USER devpiuser (这里不需要，supervisor 会处理)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">7104</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/usr/bin/supervisord&quot;</span>]</span></span><br></pre></td></tr></table></figure><ul><li>docker-compose.yml</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml (与最终高可用版 Dockerfile 配合使用)</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">devpi-lib:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">devpi-lib</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;7104:7104&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">devpi-data:/var/lib/devpi</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 代理配置依然需要，ha_proxy.py 会使用它</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">http_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">https_proxy=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTP_PROXY=http://192.168.12.80:7890</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HTTPS_PROXY=http://192.168.12.80:7890</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">devpi-data:</span></span><br></pre></td></tr></table></figure><ul><li>docker build</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> docker-compose up -d --build --force-recreate</span><br></pre></td></tr></table></figure><ul><li>mirror set</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devpi login root --password=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 将 mirror_url 指向我们内部的 HA 代理服务</span></span><br><span class="line">devpi index root/pypi mirror_url=http://127.0.0.1:8000/</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li><ol><li><a href="https://github.com/devpi/devpi">https://github.com/devpi/devpi</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用Devpi与Nginx构建高可用PyPI镜像源&quot;&gt;使用Devpi与Nginx构建高可用PyPI镜像源&lt;/h2&gt;
&lt;h3 id=&quot;前言：为什么你的pip-install又超时了？&quot;&gt;前言：为什么你的&lt;code&gt;pip install&lt;/code&gt;又超时了？&lt;/h</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker Compose 快速部署 Shadowsocks 代理服务教程</title>
    <link href="https://caozhaoqi.github.io/2025/08/29/ss-build-doc/"/>
    <id>https://caozhaoqi.github.io/2025/08/29/ss-build-doc/</id>
    <published>2025-08-29T01:06:20.000Z</published>
    <updated>2025-11-25T15:05:10.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础环境">基础环境</h2><h4 id="1-1-更新系统软件包列表">1.1 更新系统软件包列表</h4><p>首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br></pre></td></tr></table></figure><p>d</p><h4 id="1-2-安装-Docker-的依赖项">1.2 安装 Docker 的依赖项</h4><p>接下来，安装一些必要的软件包，以允许 <code>apt</code> 通过 HTTPS 使用 Docker 的软件仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure><h4 id="1-3-添加-Docker-官方-GPG-密钥">1.3 添加 Docker 官方 GPG 密钥</h4><p>为了安全起见，我们需要添加 Docker 的官方 GPG 密钥。这会验证我们下载的 Docker 软件包是官方发布的，未经篡改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于存放密钥的目录</span></span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 Docker 的 GPG 密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改密钥文件的权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure><h4 id="1-4-设置-Docker-的-APT-软件源">1.4 设置 Docker 的 APT 软件源</h4><p>现在，我们将 Docker 的官方软件源地址添加到我们系统的源列表中。这样，<code>apt</code> 命令就能找到并安装 Docker 了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 1.5 安装 Docker 引擎和 Compose V2</span></span><br><span class="line"></span><br><span class="line">再次更新软件包列表，以包含来自 Docker 官方源的软件包信息，然后执行安装：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 再次更新软件包列表</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker 引擎, 命令行工具, containerd 和 Docker Compose V2 插件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h4 id="1-6-可选但推荐-配置非-root-用户运行-Docker">1.6 (可选但推荐) 配置非 root 用户运行 Docker</h4><p>每次都输入 <code>sudo</code> 来运行 Docker 命令很麻烦。我们可以将当前用户添加到 <code>docker</code> 用户组，从而免去 <code>sudo</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将您的用户（$USER 是一个环境变量，代表当前用户）添加到 docker 组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong> 执行此命令后，您需要<strong>完全退出 SSH 会话并重新登录</strong>，才能使权限更改生效！</p><hr><h3 id="第二步：配置并部署-Shadowsocks-服务">第二步：配置并部署 Shadowsocks 服务</h3><p>环境准备好后，我们就可以开始定义和部署我们的 Shadowsocks 服务了。</p><h4 id="2-1-创建一个工作目录">2.1 创建一个工作目录</h4><p>为我们的项目创建一个专门的目录，这样可以保持整洁。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个名为 ss 的目录并进入</span></span><br><span class="line"><span class="built_in">mkdir</span> ~/ss</span><br><span class="line"><span class="built_in">cd</span> ~/ss</span><br></pre></td></tr></table></figure><h4 id="2-2-编写-docker-compose-yml-配置文件">2.2 编写 <code>docker-compose.yml</code> 配置文件</h4><p>这是整个部署的核心。我们将创建一个名为 <code>docker-compose.yml</code> 的文件，它像一份蓝图，详细描述了我们的服务应该如何运行。</p><p>使用您喜欢的文本编辑器（这里以 <code>nano</code> 为例，它比 <code>vim</code> 更易上手）创建文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>然后，将以下内容<strong>复制并粘贴</strong>到编辑器中：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Compose 文件格式的版本 3</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义所有服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># 定义一个名为 &quot;shadowsocks&quot; 的服务</span></span><br><span class="line">  <span class="attr">shadowsocks:</span></span><br><span class="line">    <span class="comment"># 指定要使用的 Docker 镜像，我们使用官方的 shadowsocks-libev</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">shadowsocks/shadowsocks-libev</span></span><br><span class="line">    <span class="comment"># 给运行的容器起一个固定的名字，方便我们管理</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">shadowsocks</span></span><br><span class="line">    <span class="comment"># 设置端口映射 (格式: &quot;主机端口:容器端口&quot;)</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 将服务器的 TCP 8388 端口映射到容器的 TCP 8388 端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/tcp&quot;</span></span><br><span class="line">      <span class="comment"># 将服务器的 UDP 8388 端口也映射出去 (用于游戏、视频通话等)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8388:8388/udp&quot;</span></span><br><span class="line">    <span class="comment"># 设置容器的重启策略</span></span><br><span class="line">    <span class="comment"># unless-stopped: 除非我们手动停止容器，否则它总是在退出后自动重启</span></span><br><span class="line">    <span class="comment"># (包括服务器重启后，服务也会自动拉起，非常省心)</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="comment"># 设置容器内的环境变量，用于配置 Shadowsocks</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 设置加密方法，chacha20-ietf-poly1305 是目前推荐的安全且高效的算法</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">METHOD=chacha20-ietf-poly1305</span></span><br><span class="line">      <span class="comment"># 在这里设置您的连接密码！请务必替换成一个您自己的强密码！</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PASSWORD=YOUR_STRONG_PASSWORD_HERE</span></span><br></pre></td></tr></table></figure><p><strong>重要配置修改：</strong></p><ul><li><strong><code>PASSWORD</code></strong>: 将 <code>YOUR_STRONG_PASSWORD_HERE</code> <strong>替换为您自己设定的一个强密码</strong>。这是您的客户端连接时需要用到的凭证。</li><li><strong><code>ports</code></strong>: 如果您服务器的 <code>8388</code> 端口已被其他服务占用，您可以修改主机端口。例如，改成 <code>&quot;10086:8388/tcp&quot;</code>，这样您的客户端就需要连接服务器的 <code>10086</code> 端口。</li></ul><p>修改完成后，在 <code>nano</code> 编辑器中，按 <code>Ctrl + X</code>，然后按 <code>Y</code>，最后按 <code>Enter</code> 保存并退出。</p><h4 id="2-3-启动-Shadowsocks-服务">2.3 启动 Shadowsocks 服务</h4><p>现在，激动人心的时刻到了！在 <code>docker-compose.yml</code> 文件所在的目录（即 <code>~/ss</code>），运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：如果您在 1.6 步中配置了用户组，这里就不需要 sudo 了</span></span><br><span class="line"><span class="comment"># 新版命令 (推荐)</span></span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 旧版命令 (也能工作)</span></span><br><span class="line"><span class="comment"># docker-compose up -d</span></span><br></pre></td></tr></table></figure><ul><li><code>up</code>: 告诉 Docker Compose 启动并运行服务。</li><li><code>-d</code>: (<code>--detach</code>) 参数表示在后台运行服务。这是必须的，否则当您关闭 SSH 窗口时，服务也会停止。</li></ul><p>Docker Compose 现在会自动：</p><ol><li>检查 <code>docker-compose.yml</code> 文件。</li><li>从 Docker Hub 上拉取 <code>shadowsocks/shadowsocks-libev</code> 镜像（如果是第一次运行）。</li><li>根据您的配置创建并启动一个名为 <code>shadowsocks</code> 的容器。</li></ol><hr><h3 id="第三步：验证服务与客户端配置">第三步：验证服务与客户端配置</h3><blockquote><p>服务启动后，我们需要确认它是否正常运行，并配置客户端进行连接。</p></blockquote><h4 id="3-1-检查容器运行状态">3.1 检查容器运行状态</h4><p>运行以下命令查看当前正在运行的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>您应该能看到类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID   IMAGE                           COMMAND                  CREATED         STATUS         PORTS                                                 NAMES</span><br><span class="line">a1b2c3d4e5f6   shadowsocks/shadowsocks-libev   &quot;/usr/bin/ss-server …&quot;   30 seconds ago   Up 29 seconds   0.0.0.0:8388-&gt;8388/tcp, 0.0.0.0:8388-&gt;8388/udp   shadowsocks</span><br></pre></td></tr></table></figure><p>请关注以下几点：</p><ul><li><strong><code>IMAGE</code></strong>: 确认是 <code>shadowsocks/shadowsocks-libev</code>。</li><li><strong><code>STATUS</code></strong>: 必须是 <code>Up ...</code>，表示正在健康运行。如果是 <code>Exited</code>，说明启动失败。</li><li><strong><code>PORTS</code></strong>: 确认端口映射正确。</li><li><strong><code>NAMES</code></strong>: 确认是 <code>shadowsocks</code>。</li></ul><h4 id="3-2-查看服务日志">3.2 查看服务日志</h4><p>如果容器启动失败，或者您想确认服务的内部运行情况，查看日志是最佳方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs shadowsocks</span><br></pre></td></tr></table></figure><p>成功的日志会显示服务正在监听端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO: initializing ciphers... chacha20-ietf-poly1305</span><br><span class="line">INFO: listening at 0.0.0.0:8388</span><br></pre></td></tr></table></figure><h4 id="3-3-配置您的客户端">3.3 配置您的客户端</h4><p>现在，您可以在您的电脑或手机上配置 Shadowsocks 客户端了。填入以下信息：</p><ul><li><strong>服务器地址 (Server Address)</strong>: <code>您服务器的公网 IP 地址</code></li><li><strong>服务器端口 (Server Port)</strong>: <code>8388</code> (或者您在 <code>docker-compose.yml</code> 中设置的主机端口)</li><li><strong>密码 (Password)</strong>: <code>您在 docker-compose.yml 中设置的密码</code></li><li><strong>加密方法 (Encryption/Method)</strong>: <code>chacha20-ietf-poly1305</code></li></ul><p>保存配置并连接，现在您应该可以正常使用了！</p><hr><h3 id="第四步：常用管理命令">第四步：常用管理命令</h3><ul><li><strong>停止服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose down</span><br></pre></td></tr></table></figure></li><li><strong>重启服务</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line">docker compose restart</span><br></pre></td></tr></table></figure></li><li><strong>更新服务 (例如更新 Shadowsocks 镜像)</strong>:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 ~/ss 目录下运行</span></span><br><span class="line"><span class="comment"># 1. 拉取最新的镜像</span></span><br><span class="line">docker compose pull</span><br><span class="line"><span class="comment"># 2. 重新创建并启动容器</span></span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure></li></ul><h2 id="客户端">客户端</h2><ul><li>windows</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-windows</span><br></pre></td></tr></table></figure><ul><li>android</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/shadowsocks/shadowsocks-android</span><br></pre></td></tr></table></figure><h2 id="代理模式">代理模式</h2><ul><li><p>禁用 (Disabled)：不使用代理。等同于取消勾选“启用系统代理”。</p></li><li><p>PAC 模式 (PAC)：推荐日常使用。此模式下，客户端会根据一个名为 PAC (Proxy Auto-Config) 的规则列表来判断。</p></li><li><p>全局模式 (Global)：所有网络流量都强制通过代理服务器。</p></li></ul><h2 id="See">See</h2><ul><li><a href="https://github.com/shadowsocks/shadowsocks-rust">https://github.com/shadowsocks/shadowsocks-rust</a></li><li><a href="https://github.com/shadowsocks/shadowsocks-windows">https://github.com/shadowsocks/shadowsocks-windows</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础环境&quot;&gt;基础环境&lt;/h2&gt;
&lt;h4 id=&quot;1-1-更新系统软件包列表&quot;&gt;1.1 更新系统软件包列表&lt;/h4&gt;
&lt;p&gt;首先，连接到您的服务器，然后运行以下命令来更新系统的软件包索引：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>PyAV用于视频剪辑处理</title>
    <link href="https://caozhaoqi.github.io/2025/08/14/pyav-use-video/"/>
    <id>https://caozhaoqi.github.io/2025/08/14/pyav-use-video/</id>
    <published>2025-08-14T10:54:52.000Z</published>
    <updated>2025-11-25T15:05:10.344Z</updated>
    
    <content type="html"><![CDATA[<h1>PyAV用于视频剪辑处理</h1><blockquote><p>PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：</p></blockquote><ul><li><strong>内存操作</strong>：直接在内存中处理视频帧和音频样本，无需创建大量临时文件。</li><li><strong>精细控制</strong>：你可以完全控制容器的解复用、数据包的解码、帧的处理和编码的每一个环节。</li><li><strong>硬件加速</strong>：可以利用GPU（如macOS的VideoToolbox, Linux/Windows的CUDA/NVENC）来极大地加速解码和编码过程。</li><li><strong>高度集成</strong>：可以无缝地将视频帧与NumPy、Pillow等流行的Python库结合使用。</li></ul><h3 id="PyAV的核心概念">PyAV的核心概念</h3><blockquote><p>在深入代码之前，我们先了解几个核心概念，它们直接映射自FFmpeg：</p></blockquote><ol><li><strong>容器 (Container)</strong>: 指的是视频文件本身，比如一个<code>.mp4</code>或<code>.mkv</code>文件。它是一个“容器”，里面装着各种数据流。</li><li><strong>流 (Stream)</strong>: 指的是容器内的数据轨道。一个视频文件通常至少包含一个视频流和一个音频流，有时还会有字幕流。</li><li><strong>数据包 (Packet)</strong>: 从流中读取的一小块<strong>压缩后</strong>的数据。</li><li><strong>帧 (Frame)</strong>: 一个数据包经过<strong>解码后</strong>得到的数据。对于视频流，它是一张图片；对于音频流，它是一段声音样本。</li></ol><blockquote><p>标准的处理流程是：<strong>打开容器 → 找到需要的流 → 从流中解复用(demux)数据包 → 解码(decode)数据包得到帧 → (处理帧) → 编码(encode)处理后的帧变回数据包 → 将数据包混合(mux)到新的输出容器 → 关闭容器</strong>。</p></blockquote><h2 id="简单安装">简单安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install av</span><br><span class="line">conda install av -c conda-forge</span><br></pre></td></tr></table></figure><h3 id="功能">功能</h3><ul><li><p>libavformat: containers, audio/video/subtitle streams, packets;</p></li><li><p>libavdevice (by specifying a format to containers);</p></li><li><p>libavcodec: Codec, CodecContext, BitStreamFilterContext, audio/video frames, data planes, subtitles;</p></li><li><p>libavfilter: Filter, Graph;</p></li><li><p>libswscale: VideoReformatter;</p></li><li><p>libswresample: AudioResampler;</p></li></ul><h3 id="simple-demo">simple demo</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> av</span><br><span class="line"></span><br><span class="line">av.logging.set_level(av.logging.VERBOSE)</span><br><span class="line">container = av.<span class="built_in">open</span>(path_to_video)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, frame <span class="keyword">in</span> <span class="built_in">enumerate</span>(container.decode(video=<span class="number">0</span>)):</span><br><span class="line">    frame.to_image().save(<span class="string">f&quot;frame-<span class="subst">&#123;index:04d&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --- 调度器函数 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params">input_video_path, output_video_path, ...</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查硬件加速是否受支持</span></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速</span></span><br><span class="line">            logger.info(<span class="string">&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(...)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                <span class="comment"># 如果硬件路径明确返回失败，则降级</span></span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(...)</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 如果硬件路径意外崩溃，则降级</span></span><br><span class="line">            logger.error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(...)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(...)</span><br></pre></td></tr></table></figure><p>接下来，我们将深入分析这两种核心实现。</p><h3 id="Part-1-健壮的基石-——-纯软件-CPU-实现">Part 1: 健壮的基石 —— 纯软件 (CPU) 实现</h3><p>这是我们后备方案的核心，也是理解PyAV基础操作的最佳入口。它不依赖任何特殊的硬件，可以在任何平台上运行。</p><h4 id="核心步骤">核心步骤</h4><ol><li><p><strong>参数准备</strong>:<br>最关键的一步是确保输出的分辨率永远是偶数。像 <code>libx264</code> 这样的H.264编码器无法处理宽度或高度为奇数的视频。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final_w = w - (w % <span class="number">2</span>)</span><br><span class="line">final_h = h - (h % <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>打开输入/输出容器</strong>:<br>使用 <code>av.open()</code>，就像Python内置的 <code>open()</code> 一样简单，但它可以同时用于读和写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">    <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p><strong>创建输出流</strong>:<br>最简单的方式是从输入流创建模板。这会自动复制编解码器、码率等大部分参数。然后我们再手动覆盖需要修改的参数，比如新的宽度和高度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找所有输入流</span></span><br><span class="line">in_video_stream = in_container.streams.video[<span class="number">0</span>]</span><br><span class="line">in_audio_stream = in_container.streams.audio[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从模板创建输出流</span></span><br><span class="line">out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">out_audio_stream = out_container.add_stream_from_template(in_audio_stream)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖视频流的尺寸</span></span><br><span class="line">out_video_stream.width = final_w</span><br><span class="line">out_video_stream.height = final_h</span><br></pre></td></tr></table></figure></li><li><p><strong>核心处理循环</strong>:<br>这是最精彩的部分，完美体现了PyAV与Pillow的结合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">            <span class="comment"># a. 解码帧并转换为Pillow Image对象</span></span><br><span class="line">            img = frame.to_image()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># b. 使用Pillow的强大功能进行图像处理</span></span><br><span class="line">            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line">            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># c. 将处理后的Pillow Image转换回PyAV的VideoFrame</span></span><br><span class="line">            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># d. 编码新帧并混合到输出文件</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">        <span class="comment"># 音频直通：不解码，直接复制数据包，效率最高</span></span><br><span class="line">        packet.stream = out_audio_stream</span><br><span class="line">        out_container.mux(packet)</span><br></pre></td></tr></table></figure></li><li><p><strong>冲洗 (Flush) 编码器</strong>:<br>处理完所有帧后，编码器的内部可能还缓存着一些数据。我们通过发送一个 <code>None</code> 来告诉它结束编码，并清空所有缓冲区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">    out_container.mux(out_packet)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Part-2-极致性能-——-Metal硬件加速-GPU-实现">Part 2: 极致性能 —— Metal硬件加速 (GPU) 实现</h3><p>这是脚本的“高性能模式”，专门为macOS设计。它尽可能地将所有操作都留在GPU上，避免了昂贵的CPU&lt;-&gt;GPU数据拷贝。</p><h4 id="核心步骤-2">核心步骤</h4><ol><li><p><strong>创建硬件设备上下文</strong>:<br>这是开启硬件加速的第一步，我们告诉PyAV我们要使用苹果的 <code>videotoolbox</code> 框架。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>配置硬件解码</strong>:<br>这是现代PyAV中配置硬件解码的关键。我们不是手动设置上下文，而是为输入流的 <code>codec_context</code> 提供一个 <code>get_format</code> 回调函数。当解码器准备好时，它会调用这个函数并提供一个它支持的像素格式列表。我们的函数只需从中选择 <code>'videotoolbox'</code> 格式即可。这告诉解码器：“请直接将帧解码到GPU显存中，不要下载到CPU内存。”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">    <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">        <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">            <span class="keyword">return</span> fmt</span><br><span class="line">    <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">&quot;未找到 &#x27;videotoolbox&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">in_stream.codec_context.get_format = get_hw_format</span><br></pre></td></tr></table></figure></li><li><p><strong>构建硬件滤镜图 (Filter Graph)</strong>:<br>裁剪和缩放是通过FFmpeg的滤镜系统完成的。PyAV允许我们用代码构建这个处理链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">buffer_src = graph.add_buffer(template=in_stream) <span class="comment"># 输入源</span></span><br><span class="line">buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>) <span class="comment"># 输出汇</span></span><br><span class="line"></span><br><span class="line">filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;...&#125;</span>,scale=<span class="subst">&#123;...&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：源 -&gt; 滤镜链 -&gt; 汇</span></span><br><span class="line">filters = graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>)</span><br><span class="line">buffer_src.link_to(filters)</span><br><span class="line">filters.link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">graph.configure()</span><br></pre></td></tr></table></figure><p>这里最巧妙的是，即使 <code>crop</code> 和 <code>scale</code> 滤镜是纯CPU操作，FFmpeg也会在后台<strong>自动</strong>处理硬件帧的下载（GPU-&gt;CPU）、应用滤镜、再上传（CPU-&gt;GPU）的过程。</p></li><li><p><strong>配置硬件编码</strong>:<br>我们创建一个使用 <code>h264_videotoolbox</code> 编码器的输出流。它会自动接收来自滤镜图的、已经处理好的帧（这些帧可能在CPU上，也可能在GPU上，编码器会自动处理）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out_stream = out_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">out_stream.width = final_w</span><br><span class="line">out_stream.height = final_h</span><br><span class="line">out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span> <span class="comment"># VideoToolbox 编码器偏好的像素格式</span></span><br></pre></td></tr></table></figure></li><li><p><strong>硬件处理循环</strong>:<br>循环的主体结构类似，但操作对象变成了滤镜图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode(): <span class="comment"># 解码出的 frame 是一个指向GPU显存的硬件帧</span></span><br><span class="line">    graph.push(frame) <span class="comment"># 将硬件帧推入滤镜图处理</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            filtered_frame = buffer_sink.pull() <span class="comment"># 从滤镜图拉取处理好的帧</span></span><br><span class="line">            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                output_container.mux(out_packet)</span><br><span class="line">        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="实际处理">实际处理</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 检查当前 PyAV 环境是否支持硬件加速</span></span><br><span class="line">HW_ACCEL_SUPPORTED = <span class="built_in">hasattr</span>(av, <span class="string">&#x27;hwdevice&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">    <span class="comment"># 进一步检查平台是否为 macOS</span></span><br><span class="line">    <span class="keyword">if</span> platform.system() == <span class="string">&#x27;Darwin&#x27;</span>:</span><br><span class="line">        logger.info(<span class="string">&quot;硬件加速 (VideoToolbox) 可用。将优先使用 Metal 路径。&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        HW_ACCEL_SUPPORTED = <span class="literal">False</span></span><br><span class="line">        logger.warning(<span class="string">&quot;PyAV 支持硬件加速，但当前系统不是 macOS。VideoToolbox 不可用。&quot;</span>)</span><br><span class="line">        logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    logger.warning(<span class="string">&quot;当前 PyAV 环境中未找到硬件加速模块 (&#x27;av.hwdevice&#x27;)。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;所有视频处理将回退到纯软件模式，速度会较慢。&quot;</span>)</span><br><span class="line">    logger.warning(<span class="string">&quot;要解决此问题，请确保您的项目解释器配置正确，并使用了完整编译的 PyAV 库。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 主调度器函数 ---</span></span><br><span class="line"><span class="comment"># 您的外部代码应该只调用这个函数</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crop_video_pyav</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_x: <span class="built_in">float</span>, crop_y: <span class="built_in">float</span>, crop_w: <span class="built_in">float</span>, crop_h: <span class="built_in">float</span>,</span></span><br><span class="line"><span class="params">        log_queue=<span class="literal">None</span>,  <span class="comment"># log_queue 和其他参数保留以兼容您的接口</span></span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        assigned_gpu_id: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs  <span class="comment"># 捕获任何其他未使用的参数</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    根据环境自动选择最佳方式裁剪视频。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果支持硬件加速，则尝试使用Metal路径；否则，或Metal路径失败时，</span></span><br><span class="line"><span class="string">    自动回退到纯软件路径。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    crop_params = &#123;</span><br><span class="line">        <span class="string">&#x27;x&#x27;</span>: crop_x, <span class="string">&#x27;y&#x27;</span>: crop_y, <span class="string">&#x27;w&#x27;</span>: crop_w, <span class="string">&#x27;h&#x27;</span>: crop_h</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> HW_ACCEL_SUPPORTED:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 优先尝试硬件加速路径</span></span><br><span class="line">            logger.info(<span class="string">f&quot;检测到硬件加速支持，尝试 Metal 路径...&quot;</span>)</span><br><span class="line">            success = _crop_video_pyav_metal(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> success:</span><br><span class="line">                logger.warning(<span class="string">&quot;硬件加速路径执行失败，自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">                success = _crop_video_software(</span><br><span class="line">                    input_video_path, output_video_path, crop_params,</span><br><span class="line">                    min_short_side_output_px</span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">return</span> success</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;硬件加速路径执行时发生意外异常: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger.warning(<span class="string">&quot;自动降级到纯软件模式。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">                input_video_path, output_video_path, crop_params,</span><br><span class="line">                min_short_side_output_px</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果一开始就不支持硬件加速，直接走软件路径</span></span><br><span class="line">        logger.info(<span class="string">f&quot;未检测到硬件加速支持，使用纯软件路径。&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> _crop_video_software(</span><br><span class="line">            input_video_path, output_video_path, crop_params,</span><br><span class="line">            min_short_side_output_px</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 硬件加速实现 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_pyav_metal</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用 PyAV 和 VideoToolbox (Metal) 进行硬件加速的视频裁剪。</span></span><br><span class="line"><span class="string">    这是一个内部函数，假设硬件支持已确认。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Metal路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参数准备</span></span><br><span class="line">    crop_w_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_h_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_x_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    crop_y_f = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) - (<span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]) % <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> crop_w_f &lt;= <span class="number">0</span> <span class="keyword">or</span> crop_h_f &lt;= <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    final_w, final_h = crop_w_f, crop_h_f</span><br><span class="line">    needs_scaling = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(crop_w_f, crop_h_f) &lt; min_short_side_output_px:</span><br><span class="line">        needs_scaling = <span class="literal">True</span></span><br><span class="line">        scale_factor = min_short_side_output_px / <span class="built_in">min</span>(crop_w_f, crop_h_f)</span><br><span class="line">        final_w = math.ceil((crop_w_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line">        final_h = math.ceil((crop_h_f * scale_factor) / <span class="number">2</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 硬件设备与容器 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 创建 VideoToolbox 上下文。&quot;</span>)</span><br><span class="line">        hw_device = av.hwdevice.Device(<span class="string">&quot;videotoolbox&quot;</span>)</span><br><span class="line"></span><br><span class="line">        input_container = av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        output_container = av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        in_stream = input_container.streams.video[<span class="number">0</span>]</span><br><span class="line">        in_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件解码 (现代方式) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件解码。&quot;</span>)</span><br><span class="line">        hw_pix_fmt = <span class="string">&#x27;videotoolbox&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_hw_format</span>(<span class="params">formats</span>):</span><br><span class="line">            <span class="keyword">for</span> fmt <span class="keyword">in</span> formats:</span><br><span class="line">                <span class="keyword">if</span> fmt.name == hw_pix_fmt:</span><br><span class="line">                    <span class="keyword">return</span> fmt</span><br><span class="line">            <span class="keyword">raise</span> av.EncoderNotFoundError(<span class="string">f&quot;未找到 &#x27;<span class="subst">&#123;hw_pix_fmt&#125;</span>&#x27; 硬件格式。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        in_stream.codec_context.get_format = get_hw_format</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置滤镜图 ---</span></span><br><span class="line">        <span class="comment"># FFmpeg 会在后台自动插入 hwupload/hwdownload 滤镜</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置滤镜图。&quot;</span>)</span><br><span class="line">        graph = av.<span class="built_in">filter</span>.Graph()</span><br><span class="line">        buffer_src = graph.add_buffer(template=in_stream)</span><br><span class="line"></span><br><span class="line">        filter_chain = <span class="string">f&quot;crop=<span class="subst">&#123;crop_w_f&#125;</span>:<span class="subst">&#123;crop_h_f&#125;</span>:<span class="subst">&#123;crop_x_f&#125;</span>:<span class="subst">&#123;crop_y_f&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> needs_scaling:</span><br><span class="line">            filter_chain += <span class="string">f&quot;,scale=<span class="subst">&#123;final_w&#125;</span>:<span class="subst">&#123;final_h&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 滤镜图的终点是 buffer_sink</span></span><br><span class="line">        buffer_sink = graph.add(<span class="string">&quot;buffersink&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 链接滤镜</span></span><br><span class="line">        buffer_src.link_to(graph.add_filter(filter_chain, <span class="string">&quot;filters&quot;</span>))</span><br><span class="line">        graph.get_filter(<span class="string">&quot;filters&quot;</span>).link_to(buffer_sink)</span><br><span class="line"></span><br><span class="line">        graph.configure()</span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 滤镜图配置成功: &#x27;<span class="subst">&#123;filter_chain&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 配置硬件编码 ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 配置硬件编码。&quot;</span>)</span><br><span class="line">        rate = in_stream.base_rate <span class="keyword">or</span> in_stream.guessed_rate <span class="keyword">or</span> in_stream.average_rate</span><br><span class="line">        out_stream = output_container.add_stream(<span class="string">&quot;h264_videotoolbox&quot;</span>, rate=rate)</span><br><span class="line">        out_stream.width = final_w</span><br><span class="line">        out_stream.height = final_h</span><br><span class="line">        out_stream.pix_fmt = <span class="string">&quot;nv12&quot;</span>  <span class="comment"># VideoToolbox 编码器通常使用 nv12</span></span><br><span class="line">        out_stream.time_base = in_stream.time_base</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 音频流处理 (直通) ---</span></span><br><span class="line">        in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> input_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> in_audio_stream:</span><br><span class="line">            out_audio_stream = output_container.add_stream(<span class="string">&#x27;aac&#x27;</span>, template=in_audio_stream)</span><br><span class="line">            streams_to_demux = (in_stream, in_audio_stream)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            out_audio_stream = <span class="literal">None</span></span><br><span class="line">            streams_to_demux = in_stream</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 核心处理循环 ---</span></span><br><span class="line">        <span class="keyword">for</span> packet <span class="keyword">in</span> input_container.demux(streams_to_demux):</span><br><span class="line">            <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                    graph.push(frame)</span><br><span class="line">                    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            filtered_frame = buffer_sink.pull()</span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                                output_container.mux(out_packet)</span><br><span class="line">                        <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> out_audio_stream <span class="keyword">and</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>:</span><br><span class="line">                packet.stream = out_audio_stream</span><br><span class="line">                output_container.mux(packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 冲洗(Flush) ---</span></span><br><span class="line">        logger.debug(<span class="string">&quot;Metal路径: 冲洗滤镜和编码器。&quot;</span>)</span><br><span class="line">        graph.push(<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                filtered_frame = buffer_sink.pull()</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(filtered_frame):</span><br><span class="line">                    output_container.mux(out_packet)</span><br><span class="line">            <span class="keyword">except</span> (av.error.EOFError, av.error.BlockingIOError):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_stream.encode(<span class="literal">None</span>):</span><br><span class="line">            output_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 正常关闭</span></span><br><span class="line">        output_container.close()</span><br><span class="line">        input_container.close()</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;Metal路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;Metal路径处理时发生致命错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># 清理</span></span><br><span class="line">        <span class="keyword">if</span> output_container:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">            <span class="keyword">except</span> OSError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 纯软件备用方案 (内部函数) ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_crop_video_software</span>(<span class="params"></span></span><br><span class="line"><span class="params">        input_video_path: <span class="built_in">str</span>, output_video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        crop_rect: <span class="type">Dict</span>,</span></span><br><span class="line"><span class="params">        min_short_side_output_px: <span class="type">Optional</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    使用纯软件 (CPU) 进行视频裁剪的备用方法。</span></span><br><span class="line"><span class="string">    这个方法总是可用的，但速度比硬件加速慢。</span></span><br><span class="line"><span class="string">    它确保输出尺寸为偶数，以兼容H.264等编码器。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;软件路径: 开始处理 <span class="subst">&#123;os.path.basename(input_video_path)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    input_container = <span class="literal">None</span></span><br><span class="line">    output_container = <span class="literal">None</span></span><br><span class="line">    success = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 1. 参数准备 (关键修正部分) ---</span></span><br><span class="line">        x, y, w, h = <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;x&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;y&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;w&#x27;</span>]), <span class="built_in">int</span>(crop_rect[<span class="string">&#x27;h&#x27;</span>])</span><br><span class="line">        <span class="keyword">if</span> w &lt;= <span class="number">0</span> <span class="keyword">or</span> h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;裁剪尺寸无效 (w=<span class="subst">&#123;w&#125;</span>, h=<span class="subst">&#123;h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始的最终尺寸就是裁剪后的尺寸</span></span><br><span class="line">        final_w, final_h = w, h</span><br><span class="line">        needs_scaling = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查是否需要缩放</span></span><br><span class="line">        <span class="keyword">if</span> min_short_side_output_px <span class="keyword">and</span> <span class="built_in">min</span>(w, h) &lt; min_short_side_output_px:</span><br><span class="line">            needs_scaling = <span class="literal">True</span></span><br><span class="line">            scale_factor = min_short_side_output_px / <span class="built_in">min</span>(w, h)</span><br><span class="line">            final_w = <span class="built_in">int</span>(w * scale_factor)</span><br><span class="line">            final_h = <span class="built_in">int</span>(h * scale_factor)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># *** 核心修正：确保最终的输出尺寸永远是偶数 ***</span></span><br><span class="line">        <span class="comment"># 这对于 H.264 (libx264) 和许多其他编码器至关重要</span></span><br><span class="line">        final_w = final_w - (final_w % <span class="number">2</span>)</span><br><span class="line">        final_h = final_h - (final_h % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> final_w &lt;= <span class="number">0</span> <span class="keyword">or</span> final_h &lt;= <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;计算后的输出尺寸无效 (<span class="subst">&#123;final_w&#125;</span>x<span class="subst">&#123;final_h&#125;</span>)。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 2. 打开容器并设置流 ---</span></span><br><span class="line">        <span class="keyword">with</span> av.<span class="built_in">open</span>(input_video_path, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_container:</span><br><span class="line">            <span class="keyword">with</span> av.<span class="built_in">open</span>(output_video_path, mode=<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_container:</span><br><span class="line"></span><br><span class="line">                <span class="comment"># a. 查找所有输入流</span></span><br><span class="line">                in_video_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> in_video_stream:</span><br><span class="line">                    logger.error(<span class="string">&quot;输入文件中未找到视频流。&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                in_video_stream.thread_type = <span class="string">&quot;AUTO&quot;</span></span><br><span class="line"></span><br><span class="line">                in_audio_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line">                in_subtitle_stream = <span class="built_in">next</span>((s <span class="keyword">for</span> s <span class="keyword">in</span> in_container.streams <span class="keyword">if</span> s.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span>), <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># b. 为每个输入流创建对应的输出流</span></span><br><span class="line">                out_video_stream = out_container.add_stream_from_template(in_video_stream)</span><br><span class="line">                out_video_stream.width = final_w</span><br><span class="line">                out_video_stream.height = final_h</span><br><span class="line"></span><br><span class="line">                out_audio_stream = out_container.add_stream_from_template(in_audio_stream) <span class="keyword">if</span> in_audio_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                out_subtitle_stream = out_container.add_stream_from_template(</span><br><span class="line">                    in_subtitle_stream) <span class="keyword">if</span> in_subtitle_stream <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">                streams_to_demux = [s <span class="keyword">for</span> s <span class="keyword">in</span> [in_video_stream, in_audio_stream, in_subtitle_stream] <span class="keyword">if</span> s]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 3. 核心处理循环 ---</span></span><br><span class="line">                <span class="keyword">for</span> packet <span class="keyword">in</span> in_container.demux(streams_to_demux):</span><br><span class="line">                    <span class="keyword">if</span> packet.dts <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;video&#x27;</span>:</span><br><span class="line">                        <span class="keyword">for</span> frame <span class="keyword">in</span> packet.decode():</span><br><span class="line">                            img = frame.to_image()</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 裁剪</span></span><br><span class="line">                            cropped_img = img.crop((x, y, x + w, y + h))</span><br><span class="line"></span><br><span class="line">                            <span class="comment"># 如果需要，进行缩放</span></span><br><span class="line">                            <span class="keyword">if</span> needs_scaling:</span><br><span class="line">                                <span class="comment"># Pillow 的 resize 需要一个 (width, height) 元组</span></span><br><span class="line">                                cropped_img = cropped_img.resize((final_w, final_h))</span><br><span class="line"></span><br><span class="line">                            new_frame = av.VideoFrame.from_image(cropped_img)</span><br><span class="line">                            new_frame.pts = frame.pts</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(new_frame):</span><br><span class="line">                                out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;audio&#x27;</span> <span class="keyword">and</span> out_audio_stream:</span><br><span class="line">                        packet.stream = out_audio_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">elif</span> packet.stream.<span class="built_in">type</span> == <span class="string">&#x27;subtitle&#x27;</span> <span class="keyword">and</span> out_subtitle_stream:</span><br><span class="line">                        packet.stream = out_subtitle_stream</span><br><span class="line">                        out_container.mux(packet)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># --- 4. 冲洗(Flush)视频编码器 ---</span></span><br><span class="line">                logger.debug(<span class="string">&quot;软件路径: 冲洗视频编码器。&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> out_packet <span class="keyword">in</span> out_video_stream.encode(<span class="literal">None</span>):</span><br><span class="line">                    out_container.mux(out_packet)</span><br><span class="line"></span><br><span class="line">        success = <span class="literal">True</span></span><br><span class="line">        logger.info(<span class="string">f&quot;软件路径: 视频处理成功 -&gt; <span class="subst">&#123;os.path.basename(output_video_path)&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.opt(exception=<span class="literal">True</span>).error(<span class="string">f&quot;软件路径处理时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> output_container <span class="keyword">and</span> <span class="keyword">not</span> output_container.closed:</span><br><span class="line">            output_container.close()</span><br><span class="line">        <span class="keyword">if</span> input_container <span class="keyword">and</span> <span class="keyword">not</span> input_container.closed:</span><br><span class="line">            input_container.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> success <span class="keyword">and</span> os.path.exists(output_video_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(output_video_path)</span><br><span class="line">                logger.info(<span class="string">f&quot;已清理失败的输出文件: <span class="subst">&#123;output_video_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> err:</span><br><span class="line">                logger.warning(<span class="string">f&quot;清理失败的输出文件时出错: <span class="subst">&#123;err&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="one-more-thing">one more thing</h2><ul><li>gpu acc</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GPU Acceleration Defaults</span></span><br><span class="line">GPU_ACCELERATION_DEFAULT = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;videotoolbox&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_videotoolbox&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GPU_ACCELERATION_DEFAULT_win = &#123;</span><br><span class="line">    <span class="string">&quot;gpu_opencv_decode&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&quot;opencv_cuda_device&quot;</span>: <span class="number">0</span>,  <span class="comment"># Default/primary GPU for OpenCV CUDA operations</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_hwaccel&quot;</span>: <span class="string">&quot;cuda&quot;</span>,     <span class="comment"># e.g., &quot;cuda&quot;, &quot;qsv&quot;, &quot;vaapi&quot;, &quot;videotoolbox&quot;</span></span><br><span class="line">    <span class="string">&quot;ffmpeg_gpu_encoder&quot;</span>: <span class="string">&quot;h264_nvenc&quot;</span>, <span class="comment"># e.g., &quot;h264_nvenc&quot;, &quot;hevc_qsv&quot;, h264_videotoolbox</span></span><br><span class="line">    <span class="string">&quot;gpu_ids_to_use&quot;</span>: <span class="string">&quot;0&quot;</span>      <span class="comment"># New: Comma-separated list of GPU IDs (e.g., &quot;0,1&quot;) for general processing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See">See</h2><ul><li>1.<a href="https://github.com/PyAV-Org/PyAV/tree/main/docs/api">https://github.com/PyAV-Org/PyAV/tree/main/docs/api</a></li><li>2.<a href="https://ffmpeg.org/documentation.html">https://ffmpeg.org/documentation.html</a></li><li>3.<a href="https://pyav.basswood-io.com/docs/stable/">https://pyav.basswood-io.com/docs/stable/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PyAV用于视频剪辑处理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;PyAV是FFmpeg库的Pythonic绑定。它允许你直接在Python代码中，以一种极其精细和高效的方式访问FFmpeg的内部功能。这意味着：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>数字水印系统实现</title>
    <link href="https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/"/>
    <id>https://caozhaoqi.github.io/2025/07/22/watermark-gen-valid/</id>
    <published>2025-07-22T10:25:23.000Z</published>
    <updated>2025-11-25T15:05:10.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现流程框架">实现流程框架</h2><p>无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：</p><ol><li><p><strong>水印嵌入 (Watermark Embedding)</strong>：</p><ul><li><strong>输入</strong>：原始载体（如图片A）、水印信息（如字符串&quot;ID:123&quot;或一个Logo图片B）。</li><li><strong>过程</strong>：通过特定算法，将水印信息B处理后，“叠加”或“融入”到原始载体A中。</li><li><strong>输出</strong>：一个带有水印、但看起来和原始载体几乎没区别的载体A’。</li></ul></li><li><p><strong>水印提取/检测 (Watermark Extraction/Detection)</strong>：</p><ul><li><strong>输入</strong>：可能被修改过的带水印载体A’'，有时还需要原始载体A或原始水印B作为参考。</li><li><strong>过程</strong>：通过与嵌入过程相逆的算法，从载体A’'中解码出隐藏的水印信息。</li><li><strong>输出</strong>：提取出的水印信息B’，或者一个“是/否”的判断（确认是否存在某个特定水印）。</li></ul></li></ol><blockquote><p>现在，我们来看实现这些流程的具体技术。</p></blockquote><hr><h3 id="一、-空域（Spatial-Domain）技术">一、 空域（Spatial Domain）技术</h3><p><strong>核心思想</strong>：直接修改原始图像的像素值（比如RGB值）来嵌入信息。这种方法直观、简单。</p><h4 id="典型技术：LSB-Least-Significant-Bit-算法">典型技术：LSB (Least Significant Bit) 算法</h4><p>这是最经典、最简单的空域水印技术。</p><ul><li><p><strong>原理</strong>：</p><ul><li>计算机中的图像，每个像素的颜色由若干个二进制位（bits）表示。例如，一个8位的灰度图像，每个像素的灰度值范围是0-255，由8个二进制位组成。</li><li><strong>最低有效位 (LSB)</strong> 就是这8个位中最右边的那一位。改变这一位，对像素值的整体影响最小（最多改变1），人眼基本无法察觉。</li><li><strong>嵌入方法</strong>：将要隐藏的水印信息（比如一张黑白Logo图片）转换成二进制流（0和1的序列）。然后，用这个二进制流去替换原始图像中每个（或部分）像素的LSB。<ul><li>如果要嵌入<code>1</code>，就把像素的LSB改成<code>1</code>。</li><li>如果要嵌入<code>0</code>，就把像素的LSB改成<code>0</code>。</li></ul></li></ul></li><li><p><strong>提取方法</strong>：直接读取带水印图像中相应像素的LSB，就能还原出隐藏的二进制流，从而重构水印信息。</p></li><li><p><strong>优点</strong>：</p><ul><li><strong>实现简单</strong>：算法非常直接。</li><li><strong>容量大</strong>：每个像素都能藏1比特信息，可以隐藏大量数据。</li><li><strong>隐蔽性好</strong>：对视觉影响极小。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li><strong>鲁棒性极差（非常脆弱）</strong>：这是它的致命弱点。任何对图像的轻微处理，如 <strong>JPEG压缩、缩放、裁剪、加个滤镜</strong>，都会破坏LSB层的数据，导致水印完全丢失。</li></ul></li><li><p><strong>应用场景</strong>：主要用于<strong>脆弱水印</strong>，即<strong>内容完整性认证</strong>。因为只要图片被改动，水印就会被破坏，从而可以证明“此图已被修改”。</p></li></ul><hr><h3 id="二、-变换域（Transform-Domain）技术">二、 变换域（Transform Domain）技术</h3><p><strong>核心思想</strong>：不直接改像素值，而是先对图像进行数学变换（如傅里叶变换、余弦变换），将其从空域转换到另一个域（如频域）。然后，在变换后的域中修改系数来嵌入水印。这是目前主流的、<strong>鲁棒水印</strong>的实现方式。</p><p><strong>为什么要这么做？</strong><br>因为像JPEG压缩这样的操作，主要丢弃的是图像的<strong>高频信息</strong>（细节），而保留<strong>中低频信息</strong>（轮廓、主要能量）。如果在中低频系数里嵌入水印，那么即使经过压缩，水印信息也能大概率被保留下来。</p><h4 id="1-基于DCT（离散余弦变换）的技术">1. 基于DCT（离散余弦变换）的技术</h4><ul><li><strong>背景</strong>：DCT是 <strong>JPEG 压缩</strong>的核心算法。它将图像分成8x8的小块，然后对每个块进行DCT变换，得到一个频率系数矩阵。这个矩阵中，左上角是低频系数（能量集中），右下角是高频系数。</li><li><strong>嵌入方法</strong>：<ol><li>将原始图像分块（如8x8）。</li><li>对每个块进行DCT变换。</li><li>选择<strong>中频区域</strong>的系数进行修改。为什么是中频？因为低频系数对视觉影响太大，高频系数容易在压缩中丢失，中频是最佳平衡点。</li><li>根据水印信息（0或1）来修改这些中频系数。例如，通过量化或比较两个系数的大小来嵌入1比特信息。</li><li>对修改后的系数矩阵进行<strong>逆DCT变换</strong> (IDCT)，得到带水印的图像块。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>鲁棒性强</strong>：对JPEG压缩、轻微噪声、亮度调整等有很好的抵抗能力。</li><li><strong>隐蔽性好</strong>：利用了人类视觉系统对中频变化不敏感的特性。</li></ul></li><li><strong>应用场景</strong>：<strong>版权保护</strong>、<strong>盗版追踪</strong>等需要强鲁棒性的场合。</li></ul><h4 id="2-基于DWT（离散小波变换）的技术">2. 基于DWT（离散小波变换）的技术</h4><ul><li><strong>背景</strong>：DWT是 <strong>JPEG 2000</strong> 压缩标准的核心。与DCT不同，DWT能对整个图像进行多分辨率分析，得到不同尺度和方向的子带（低频、水平细节、垂直细节、对角线细节）。</li><li><strong>嵌入方法</strong>：<ol><li>对整个图像进行DWT变换。</li><li>水印通常被嵌入到<strong>中、低频子带</strong>的系数中。</li><li>因为DWT提供了图像的空间和频率局部化信息，所以它对裁剪、缩放等几何攻击的抵抗性更好。</li></ol></li><li><strong>优点</strong>：<ul><li><strong>多分辨率特性</strong>：鲁棒性比DCT更全面，尤其在抗几何攻击方面。</li><li><strong>与人类视觉系统（HVS）匹配更好</strong>：可以更精细地控制水印的嵌入强度，达到更好的隐蔽性。</li></ul></li><li><strong>应用场景</strong>：同DCT，用于需要更高鲁棒性的版权保护系统。</li></ul><h4 id="3-基于DFT（离散傅里叶变换）的技术">3. 基于DFT（离散傅里叶变换）的技术</h4><ul><li><strong>背景</strong>：DFT将图像转换成幅度和相位谱。</li><li><strong>特点</strong>：图像的幅度谱对<strong>旋转、缩放和平移（RST攻击）</strong> 具有不变性或特定的变化规律。</li><li><strong>嵌入方法</strong>：通过修改DFT变换后的<strong>幅度谱</strong>来嵌入水印。</li><li><strong>优点</strong>：<ul><li>对旋转、缩放等几何攻击具有天然的鲁棒性。</li></ul></li><li><strong>缺点</strong>：<ul><li>实现复杂，且容易出现图像块效应。</li></ul></li><li><strong>应用场景</strong>：主要用于抵抗几何变换的特定场合。</li></ul><hr><h2 id="实现">实现</h2><h3 id="核心的Python库：">核心的Python库：</h3><ul><li><strong>Pillow (PIL Fork)</strong>: 用于图像的读写和基本的像素操作（实现LSB）。</li><li><strong>NumPy</strong>: 用于高效的数组和矩阵运算，是所有图像处理的基础。</li><li><strong>PyWavelets (pywt)</strong>: 用于实现DWT（离散小波变换）。</li><li><strong>OpenCV-Python (cv2)</strong>: 功能最强大的计算机视觉库，可以方便地实现DCT、DFT以及各种图像处理操作。</li></ul><hr><h3 id="1-空域-Spatial-Domain-LSB-算法">1. 空域 (Spatial Domain) - LSB 算法</h3><p><strong>核心库</strong>: <code>Pillow</code> (PIL), <code>NumPy</code></p><p>这个算法不依赖复杂的数学库，Pillow和NumPy足以胜任。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">image_path, secret_message</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将秘密信息嵌入到图片的LSB层&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    width, height = img.size</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 将秘密信息转换为二进制流</span></span><br><span class="line">    binary_secret = <span class="string">&#x27;&#x27;</span>.join([<span class="built_in">format</span>(<span class="built_in">ord</span>(c), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> secret_message])</span><br><span class="line">    binary_secret += <span class="string">&#x27;1111111111111110&#x27;</span> <span class="comment"># 添加结束标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_secret) &gt; width * height * <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;信息过长，无法嵌入到图片中！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    data_index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 2. 遍历像素并修改LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="comment"># 遍历RGB三个通道</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> data_index &lt; <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                    <span class="comment"># 清除LSB并设置新的位</span></span><br><span class="line">                    pixel[i] = (pixel[i] &amp; <span class="number">0xFE</span>) | <span class="built_in">int</span>(binary_secret[data_index])</span><br><span class="line">                    data_index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> data_index &gt;= <span class="built_in">len</span>(binary_secret):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建并保存新图片</span></span><br><span class="line">    encoded_image = Image.fromarray(img_array)</span><br><span class="line">    encoded_image.save(<span class="string">&quot;encoded_image.png&quot;</span>, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;信息嵌入成功，已保存为 encoded_image.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从图片的LSB层提取秘密信息&quot;&quot;&quot;</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    img_array = np.array(img)</span><br><span class="line">    width, height = img.size</span><br><span class="line"></span><br><span class="line">    binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 遍历像素并提取LSB</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(height):</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(width):</span><br><span class="line">            pixel = img_array[y, x]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">                binary_data += <span class="built_in">str</span>(pixel[i] &amp; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 找到结束标记并转换信息</span></span><br><span class="line">    end_marker = <span class="string">&#x27;1111111111111110&#x27;</span></span><br><span class="line">    end_index = binary_data.find(end_marker)</span><br><span class="line">    <span class="keyword">if</span> end_index != -<span class="number">1</span>:</span><br><span class="line">        secret_binary = binary_data[:end_index]</span><br><span class="line">        secret_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(secret_binary), <span class="number">8</span>):</span><br><span class="line">            byte = secret_binary[i:i+<span class="number">8</span>]</span><br><span class="line">            secret_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> secret_message</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;未找到结束标记或信息。&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备一张名为 &#x27;original.png&#x27; 的图片</span></span><br><span class="line"><span class="comment"># encode_lsb(&#x27;original.png&#x27;, &quot;This is a secret message!&quot;)</span></span><br><span class="line"><span class="comment"># message = decode_lsb(&#x27;encoded_image.png&#x27;)</span></span><br><span class="line"><span class="comment"># print(f&quot;提取到的信息: &#123;message&#125;&quot;)</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-变换域-Transform-Domain-DCT-算法">2. 变换域 (Transform Domain) - DCT 算法</h3><p><strong>核心库</strong>: <code>OpenCV-Python (cv2)</code>, <code>NumPy</code></p><p>OpenCV 提供了非常方便的 <code>cv2.dct()</code> 和 <code>cv2.idct()</code> 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DCT的中频带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确保水印尺寸小于载体</span></span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DCT变换</span></span><br><span class="line">    img_dct = cv2.dct(np.float32(img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 对水印图像进行DCT变换 (也可以直接用二值化水印)</span></span><br><span class="line">    watermark_dct = cv2.dct(np.float32(watermark))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 将水印的DCT系数加到载体的中频DCT系数上</span></span><br><span class="line">    <span class="comment"># 这里简单地将整个水印DCT加到载体DCT上，更复杂的会选择特定区域</span></span><br><span class="line">    <span class="comment"># alpha 是嵌入强度</span></span><br><span class="line">    result_dct = img_dct + alpha * watermark_dct</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 进行逆DCT变换</span></span><br><span class="line">    result_img = cv2.idct(result_dct)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 裁剪值到 0-255 并转换为uint8</span></span><br><span class="line">    result_img = np.clip(result_img, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_embedded_image.png&#x27;</span>, result_img)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dct_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DCT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 这是一个非盲水印提取的例子</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对带水印图像和原始图像分别做DCT</span></span><br><span class="line">    embedded_dct = cv2.dct(np.float32(embedded_img))</span><br><span class="line">    original_dct = cv2.dct(np.float32(original_img))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 相减并除以强度因子，得到水印的DCT系数</span></span><br><span class="line">    extracted_watermark_dct = (embedded_dct - original_dct) / alpha</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 逆DCT变换，恢复水印</span></span><br><span class="line">    extracted_watermark = cv2.idct(extracted_watermark_dct)</span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dct_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DCT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dct_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.1)</span></span><br><span class="line"><span class="comment"># dct_watermark_extract(&#x27;dct_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.1)</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 上述DCT示例是一个<strong>非盲水印</strong>，提取时需要原始图像。实现盲水印（无需原图）会更复杂，通常涉及在中频带选择特定的系数对进行比较，而不是直接叠加。</p><hr><h3 id="3-变换域-Transform-Domain-DWT-算法">3. 变换域 (Transform Domain) - DWT 算法</h3><p><strong>核心库</strong>: <code>PyWavelets (pywt)</code>, <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p><code>pywt</code> 是Python中进行小波变换的标准库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DWT的LL子带嵌入图像水印&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 1. 准备载体和水印</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 对载体图像进行DWT变换</span></span><br><span class="line">    <span class="comment"># &#x27;haar&#x27; 是最简单的小波基</span></span><br><span class="line">    coeffs_img = pywt.dwt2(img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL, (LH, HL, HH) = coeffs_img</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保水印尺寸与LL子带匹配</span></span><br><span class="line">    watermark_resized = cv2.resize(watermark, (LL.shape[<span class="number">1</span>], LL.shape[<span class="number">0</span>]))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 将水印添加到低频子带 (LL)</span></span><br><span class="line">    <span class="comment"># LL子带能量最集中，鲁棒性最强，但对画质影响也最大</span></span><br><span class="line">    LL_watermarked = LL + alpha * watermark_resized</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 重构图像</span></span><br><span class="line">    coeffs_watermarked = (LL_watermarked, (LH, HL, HH))</span><br><span class="line">    img_watermarked = pywt.idwt2(coeffs_watermarked, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    img_watermarked = np.clip(img_watermarked, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_embedded_image.png&#x27;</span>, img_watermarked)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dwt_watermark_extract</span>(<span class="params">embedded_image_path, original_image_path, alpha=<span class="number">0.1</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;提取DWT水印（需要原始图像）&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 同样是非盲水印提取</span></span><br><span class="line">    embedded_img = cv2.imread(embedded_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    original_img = cv2.imread(original_image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 对两张图分别做DWT</span></span><br><span class="line">    coeffs_embedded = pywt.dwt2(embedded_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_embedded, _ = coeffs_embedded</span><br><span class="line">    </span><br><span class="line">    coeffs_original = pywt.dwt2(original_img, <span class="string">&#x27;haar&#x27;</span>)</span><br><span class="line">    LL_original, _ = coeffs_original</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 提取水印</span></span><br><span class="line">    extracted_watermark = (LL_embedded - LL_original) / alpha</span><br><span class="line">    </span><br><span class="line">    extracted_watermark = np.clip(extracted_watermark, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dwt_extracted_watermark.png&#x27;</span>, extracted_watermark)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DWT水印提取成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dwt_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=0.2)</span></span><br><span class="line"><span class="comment"># dwt_watermark_extract(&#x27;dwt_embedded_image.png&#x27;, &#x27;original.png&#x27;, alpha=0.2)</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-变换域-Transform-Domain-DFT-算法">4. 变换域 (Transform Domain) - DFT 算法</h3><p><strong>核心库</strong>: <code>NumPy</code>, <code>OpenCV-Python (cv2)</code></p><p>DFT的实现与DCT类似，但通常用于抵抗几何攻击。这里提供一个基础的嵌入思路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dft_watermark_embed</span>(<span class="params">image_path, watermark_path, alpha=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于DFT幅度谱嵌入水印&quot;&quot;&quot;</span></span><br><span class="line">    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.imread(watermark_path, cv2.IMREAD_GRAYSCALE)</span><br><span class="line">    watermark = cv2.resize(watermark, (img.shape[<span class="number">1</span>], img.shape[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. DFT变换</span></span><br><span class="line">    <span class="comment"># OpenCV的dft需要输入float32，并会输出双通道复数结果</span></span><br><span class="line">    dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 将频谱中心移到图像中央，便于观察和操作</span></span><br><span class="line">    dft_shift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 计算幅度和相位谱</span></span><br><span class="line">    magnitude_spectrum = cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line">    phase_spectrum = cv2.phase(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 在幅度谱上添加水印</span></span><br><span class="line">    magnitude_spectrum_watermarked = magnitude_spectrum + alpha * watermark</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 根据新的幅度和旧的相位，重构DFT结果</span></span><br><span class="line">    real_part = magnitude_spectrum_watermarked * np.cos(phase_spectrum)</span><br><span class="line">    imag_part = magnitude_spectrum_watermarked * np.sin(phase_spectrum)</span><br><span class="line">    dft_shift_watermarked = cv2.merge([real_part, imag_part])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 将频谱中心移回左上角</span></span><br><span class="line">    dft_watermarked = np.fft.ifftshift(dft_shift_watermarked)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 逆DFT变换</span></span><br><span class="line">    img_back = cv2.idft(dft_watermarked)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取实部并恢复图像</span></span><br><span class="line">    img_back = cv2.magnitude(img_back[:,:,<span class="number">0</span>], img_back[:,:,<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    img_back = np.clip(img_back, <span class="number">0</span>, <span class="number">255</span>).astype(np.uint8)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;dft_embedded_image.png&#x27;</span>, img_back)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DFT水印嵌入成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 使用示例 ---</span></span><br><span class="line"><span class="comment"># 请准备 &#x27;original.png&#x27; 和 &#x27;watermark_logo.png&#x27;</span></span><br><span class="line"><span class="comment"># dft_watermark_embed(&#x27;original.png&#x27;, &#x27;watermark_logo.png&#x27;, alpha=100)</span></span><br><span class="line"><span class="comment"># 提取DFT水印通常也需要原始图像，过程与DCT/DWT类似。</span></span><br></pre></td></tr></table></figure><h3 id="安装依赖库">安装依赖库</h3><ul><li>pip安装：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pillow numpy opencv-python pywavelets</span><br></pre></td></tr></table></figure><h2 id="demo">demo</h2><h3 id="水印信息嵌入（LSB）">水印信息嵌入（LSB）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_message_to_binary</span>(<span class="params">message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a string message into its binary representation.&quot;&quot;&quot;</span></span><br><span class="line">    binary_message = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">format</span>(<span class="built_in">ord</span>(char), <span class="string">&#x27;08b&#x27;</span>) <span class="keyword">for</span> char <span class="keyword">in</span> message)</span><br><span class="line">    <span class="keyword">return</span> binary_message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_binary_to_message</span>(<span class="params">binary_message: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Converts a binary string back into a string message.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># Ensure the binary string is a multiple of 8</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(binary_message) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        logger.warning(<span class="string">&quot;Binary string length is not a multiple of 8; data may be incomplete.&quot;</span>)</span><br><span class="line">        binary_message = binary_message[:-(<span class="built_in">len</span>(binary_message) % <span class="number">8</span>)]</span><br><span class="line"></span><br><span class="line">    message = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_message), <span class="number">8</span>):</span><br><span class="line">        byte = binary_message[i:i + <span class="number">8</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte) == <span class="number">8</span>:</span><br><span class="line">            message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> message</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_lsb</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Encodes a secret message into an image using the LSB (Least Significant Bit) technique.</span></span><br><span class="line"><span class="string">    The output image will be saved in a lossless format (PNG) to preserve the watermark.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path (str): The path to the source image.</span></span><br><span class="line"><span class="string">        secret_message (str): The message to hide.</span></span><br><span class="line"><span class="string">        output_image_path (str): The path to save the watermarked image.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB encoding for &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path, <span class="string">&#x27;r&#x27;</span>).convert(<span class="string">&quot;RGBA&quot;</span>) <span class="comment"># Convert to RGBA for consistency</span></span><br><span class="line">        width, height = image.size</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        channels = <span class="number">4</span>  <span class="comment"># We are using RGBA</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add a unique delimiter to know where the message ends</span></span><br><span class="line">        binary_secret_message = _message_to_binary(secret_message + <span class="string">&quot;####&quot;</span>)</span><br><span class="line">        required_pixels = <span class="built_in">len</span>(binary_secret_message)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> required_pixels &gt; width * height * channels:</span><br><span class="line">            logger.error(<span class="string">&quot;Error: Message is too long to be encoded in this image.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Modify the LSB of the pixel data</span></span><br><span class="line">        data_index = <span class="number">0</span></span><br><span class="line">        flat_array = img_array.flatten()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flat_array)):</span><br><span class="line">            <span class="keyword">if</span> data_index &lt; required_pixels:</span><br><span class="line">                <span class="comment"># Change the LSB of the color value</span></span><br><span class="line">                flat_array[i] = <span class="built_in">int</span>(<span class="built_in">bin</span>(flat_array[i])[<span class="number">2</span>:-<span class="number">1</span>] + binary_secret_message[data_index], <span class="number">2</span>)</span><br><span class="line">                data_index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># Stop once the message is encoded</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a new image with the modified pixel data</span></span><br><span class="line">        encoded_image = Image.fromarray(flat_array.reshape(height, width, channels).astype(<span class="string">&#x27;uint8&#x27;</span>), image.mode)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save as PNG to ensure lossless storage of the watermark</span></span><br><span class="line">        encoded_image.save(output_image_path, <span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">f&quot;Successfully encoded message into &#x27;<span class="subst">&#123;output_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Input image not found at &#x27;<span class="subst">&#123;input_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during encoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_lsb</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span> | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Decodes a secret message from an image using the LSB technique.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path (str): The path to the watermarked image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        The decoded secret message, or None if an error occurs or no message is found.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Starting LSB decoding for &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">        img_array = np.array(<span class="built_in">list</span>(image.getdata()))</span><br><span class="line"></span><br><span class="line">        binary_data = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> pixel <span class="keyword">in</span> img_array:</span><br><span class="line">            <span class="keyword">for</span> value <span class="keyword">in</span> pixel:</span><br><span class="line">                binary_data += <span class="built_in">bin</span>(value)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find the delimiter by decoding byte by byte</span></span><br><span class="line">        decoded_message = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_data), <span class="number">8</span>):</span><br><span class="line">            byte = binary_data[i:i+<span class="number">8</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(byte) &lt; <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">break</span> <span class="comment"># End of data</span></span><br><span class="line">            decoded_message += <span class="built_in">chr</span>(<span class="built_in">int</span>(byte, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> decoded_message.endswith(<span class="string">&quot;####&quot;</span>):</span><br><span class="line">                logger.info(<span class="string">&quot;Successfully decoded the message.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message[:-<span class="number">4</span>]  <span class="comment"># Return message without the delimiter</span></span><br><span class="line"></span><br><span class="line">        logger.warning(<span class="string">&quot;Could not find the end-of-message delimiter in the image.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error: Encoded image not found at &#x27;<span class="subst">&#123;encoded_image_path&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;An unexpected error occurred during decoding: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="水印信息验证">水印信息验证</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">valid_img_msg</span>(<span class="params">image_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Command-line tool to decode an invisible watermark from an image file.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    image_path = Path(image_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> image_path.is_file():</span><br><span class="line">        logger.debug(<span class="string">f&quot;Error: File not found at &#x27;<span class="subst">&#123;image_path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    logger.debug(<span class="string">f&quot;Verifying &#x27;<span class="subst">&#123;image_path.name&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line">    decoded_message = decode_lsb(<span class="built_in">str</span>(image_path))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decoded_message:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ✅ Watermark Found! ---&quot;</span>)</span><br><span class="line">        <span class="comment"># Pretty logger.debug the decoded information</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> decoded_message.split(<span class="string">&#x27;|&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;:&#x27;</span> <span class="keyword">in</span> item:</span><br><span class="line">                key, value = item.split(<span class="string">&#x27;:&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;key.strip():&lt;<span class="number">15</span>&#125;</span>: <span class="subst">&#123;value.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.debug(<span class="string">f&quot;  - <span class="subst">&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.debug(<span class="string">&quot;\n--- ❌ No Watermark Found ---&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;No hidden message could be decoded from this image.&quot;</span>)</span><br><span class="line">        logger.debug(<span class="string">&quot;--------------------------\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> decoded_message</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="水印信息嵌入（EXIF）">水印信息嵌入（EXIF）</h3> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> piexif</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 UserComment 的标准前缀，UNDEFINED 表示未定义编码，允许我们使用 UTF-8。</span></span><br><span class="line"><span class="comment"># 这是符合 EXIF 规范的推荐做法。</span></span><br><span class="line">USER_COMMENT_PREFIX = <span class="string">b&#x27;UNDEFINED\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode_exif</span>(<span class="params">input_image_path: <span class="built_in">str</span>, secret_message: <span class="built_in">str</span>, output_image_path: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将秘密信息作为隐形水印编码到图片的EXIF元数据中。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        input_image_path: 输入图片的路径。</span></span><br><span class="line"><span class="string">        secret_message: 要隐藏的信息。</span></span><br><span class="line"><span class="string">        output_image_path: 保存带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        如果编码成功，返回 True，否则返回 False。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在为 &#x27;<span class="subst">&#123;Path(input_image_path).name&#125;</span>&#x27; 添加EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打开图片</span></span><br><span class="line">        image = Image.<span class="built_in">open</span>(input_image_path)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 复制原始图片信息，以便在保存时保留质量、DPI等设置</span></span><br><span class="line">        image_info = image.info.copy()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否已有EXIF数据，如果没有则创建一个空的</span></span><br><span class="line">        exif_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">in</span> image_info <span class="keyword">and</span> image_info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            exif_dict = piexif.load(image_info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 确保 &#x27;Exif&#x27; 子字典存在，防止 KeyError</span></span><br><span class="line">        <span class="keyword">if</span> piexif.ImageIFD.ExifPtr <span class="keyword">not</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">             exif_dict[<span class="string">&#x27;Exif&#x27;</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 将秘密信息编码并添加标准前缀，然后放入 UserComment 字段</span></span><br><span class="line">        <span class="comment"># 这是存储任意用户数据的标准字段</span></span><br><span class="line">        user_comment_payload = USER_COMMENT_PREFIX + secret_message.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        exif_dict[<span class="string">&#x27;Exif&#x27;</span>][piexif.ExifIFD.UserComment] = user_comment_payload</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将更新后的EXIF字典转换为字节流</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># 有时 EXIF 数据可能包含 piexif 不支持的格式</span></span><br><span class="line">            logger.error(<span class="string">f&quot;无法序列化 EXIF 数据: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="comment"># 尝试移除可能导致问题的缩略图数据</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;thumbnail&#x27;</span> <span class="keyword">in</span> exif_dict:</span><br><span class="line">                <span class="keyword">del</span> exif_dict[<span class="string">&#x27;thumbnail&#x27;</span>]</span><br><span class="line">                exif_bytes = piexif.dump(exif_dict)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 保存图片，并附上新的EXIF数据</span></span><br><span class="line">        <span class="comment"># 对于 JPEG，传递原始 info 字典以保留质量等设置</span></span><br><span class="line">        <span class="comment"># 对于 PNG 等其他格式，直接使用 exif 参数</span></span><br><span class="line">        <span class="keyword">if</span> image.<span class="built_in">format</span> == <span class="string">&#x27;JPEG&#x27;</span>:</span><br><span class="line">            image.save(output_image_path, <span class="string">&quot;jpeg&quot;</span>, exif=exif_bytes, **image_info)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            image.save(output_image_path, exif=exif_bytes)</span><br><span class="line"></span><br><span class="line">        logger.success(<span class="string">f&quot;成功将EXIF水印写入 &#x27;<span class="subst">&#123;Path(output_image_path).name&#125;</span>&#x27;.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;输入文件未找到: <span class="subst">&#123;input_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;添加EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_exif</span>(<span class="params">encoded_image_path: <span class="built_in">str</span></span>) -&gt; <span class="type">Optional</span>[<span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    从图片的EXIF元数据中解码出隐藏的秘密信息。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        encoded_image_path: 带水印图片的路径。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        解码后的信息字符串，如果未找到或发生错误则返回 None。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;正在从 &#x27;<span class="subst">&#123;Path(encoded_image_path).name&#125;</span>&#x27; 解码EXIF水印...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        image = Image.<span class="built_in">open</span>(encoded_image_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 检查图片是否有EXIF数据</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;exif&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> image.info <span class="keyword">or</span> <span class="keyword">not</span> image.info[<span class="string">&#x27;exif&#x27;</span>]:</span><br><span class="line">            logger.warning(<span class="string">&quot;图片中未找到EXIF数据。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载EXIF数据</span></span><br><span class="line">        exif_dict = piexif.load(image.info[<span class="string">&quot;exif&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># [FIXED] 安全地从 UserComment 字段读取信息，防止 KeyError</span></span><br><span class="line">        exif_ifd = exif_dict.get(<span class="string">&#x27;Exif&#x27;</span>, &#123;&#125;)</span><br><span class="line">        user_comment_bytes = exif_ifd.get(piexif.ExifIFD.UserComment)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> user_comment_bytes:</span><br><span class="line">            <span class="comment"># [FIXED] 检查是否存在我们定义的前缀，并剥离它</span></span><br><span class="line">            <span class="keyword">if</span> user_comment_bytes.startswith(USER_COMMENT_PREFIX):</span><br><span class="line">                message_bytes = user_comment_bytes[<span class="built_in">len</span>(USER_COMMENT_PREFIX):]</span><br><span class="line">                <span class="comment"># 将字节解码回字符串</span></span><br><span class="line">                decoded_message = message_bytes.decode(<span class="string">&#x27;utf-8&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                logger.success(<span class="string">&quot;成功解码EXIF水印。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> decoded_message</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.warning(<span class="string">&quot;在&#x27;UserComment&#x27;字段中找到数据，但不包含预期的水印前缀。&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.warning(<span class="string">&quot;在EXIF中未找到&#x27;UserComment&#x27;水印字段。&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        logger.error(<span class="string">f&quot;文件未找到: <span class="subst">&#123;encoded_image_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.exception(<span class="string">f&quot;解码EXIF水印时发生错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="技术总结对比">技术总结对比</h3><table><thead><tr><th style="text-align:left">技术类别</th><th style="text-align:left">核心算法</th><th style="text-align:left">主要优点</th><th style="text-align:left">主要缺点</th><th style="text-align:left">典型应用</th></tr></thead><tbody><tr><td style="text-align:left"><strong>空域 (Spatial Domain)</strong></td><td style="text-align:left"><strong>LSB</strong></td><td style="text-align:left">实现简单、容量大</td><td style="text-align:left"><strong>鲁棒性极差</strong>，一碰就坏</td><td style="text-align:left"><strong>完整性认证 (脆弱水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DCT</strong></td><td style="text-align:left"><strong>对压缩鲁棒</strong>、隐蔽性好</td><td style="text-align:left">对几何攻击抵抗力一般</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DWT</strong></td><td style="text-align:left"><strong>综合鲁棒性强</strong>，尤其对裁剪等</td><td style="text-align:left">算法比DCT复杂</td><td style="text-align:left"><strong>版权保护 (鲁棒水印)</strong></td></tr><tr><td style="text-align:left"><strong>变换域 (Transform Domain)</strong></td><td style="text-align:left"><strong>DFT</strong></td><td style="text-align:left"><strong>对旋转/缩放鲁棒</strong></td><td style="text-align:left">实现复杂，可能影响画质</td><td style="text-align:left"><strong>抵抗几何攻击的特殊应用</strong></td></tr></tbody></table><p>简单来说：</p><ul><li>想做<strong>防伪标签</strong>，一改就失效，用 <strong>LSB</strong>。</li><li>想做<strong>版权印章</strong>，不怕压缩和基本处理，用 <strong>DCT</strong> 或 <strong>DWT</strong>。它们是目前最实用和最主流的鲁棒水印技术。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现流程框架&quot;&gt;实现流程框架&lt;/h2&gt;
&lt;p&gt;无论使用哪种技术，一个完整的数字水印系统通常都包括两个基本过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;水印嵌入 (Watermark Embedding)&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署 Tailscale</title>
    <link href="https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/17/tailscale-docker-build/</id>
    <published>2025-07-17T12:10:39.000Z</published>
    <updated>2025-11-25T15:05:10.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><h3 id="一、Tailscale-到底是什么？">一、Tailscale 到底是什么？</h3><p>你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。</p><ul><li><strong>传统的VPN</strong>：像是在你家（局域网）和公司（另一个局域网）之间挖了一条秘密隧道。</li><li><strong>Tailscale</strong>：更像是给你的每一台设备（NAS、电脑、手机、平板）都穿上了一件“隐身衣”，并给它们一个秘密的联络暗号。无论这些设备身处世界何地，只要它们都穿着这件“隐身衣”（安装了 Tailscale 客户端并用同一账号登录），它们就能互相看见、互相通信，仿佛就在同一个房间里。</li></ul><p>这个“虚拟局域网”是建立在互联网之上的，但它又是完全隔离和加密的，外界无法窥探。</p><h3 id="二、它如何解决你的-NAS-外链问题？">二、它如何解决你的 NAS 外链问题？</h3><p>Tailscale 通过以下几个核心功能来解决你的问题：</p><ol><li><strong>稳定的虚拟 IP 地址</strong>：一旦你的 NAS 加入了 Tailscale 网络，它会被分配一个 <code>100.x.x.x</code> 开头的、独一无二且固定的 IP 地址。你再也不用关心家里宽带的公网 IP 是不是变了。</li><li><strong>零配置穿透 (Zero-config NAT traversal)</strong>：你不需要在路由器上做任何端口转发。Tailscale 会自动想办法在你的设备之间“打洞”，建立点对点（P2P）的加密连接。这意味着数据传输速度很快，因为大部分时间数据是直连的，不经过第三方服务器中转。</li><li><strong>极高的安全性</strong>：它基于目前最先进的 VPN 协议 <strong>WireGuard®</strong> 构建，所有通信都是端到端加密的。因为你没有在路由器上开放任何端口，所以你的 NAS 不会暴露在公网上，大大降低了被黑客扫描和攻击的风险。</li><li><strong>设备间的无缝访问</strong>：只要你的电脑或手机也安装并登录了 Tailscale，你就可以在任何地方，直接通过 NAS 的那个 <code>100.x.x.x</code> 虚拟 IP 来访问它的管理页面、File Station 等所有服务，体验和在家里一模一样。</li></ol><h2 id="部署">部署</h2><h3 id="部署方式一：使用-docker-run-命令（单次部署）">部署方式一：使用 <code>docker run</code> 命令（单次部署）</h3><p>这是最直接的方式，适合快速启动。</p><h4 id="步骤-1：准备持久化目录">步骤 1：准备持久化目录</h4><p>为了让 Tailscale 的状态（主要是它的身份密钥）在容器重启后不丢失，我们需要在主机上创建一个目录来持久化存储它。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH 登录到你的 NAS 或服务器</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /path/to/your/appdata/tailscale</span><br><span class="line"><span class="comment"># 注意：请将 /path/to/your/appdata 替换为你自己存放应用数据的实际路径</span></span><br><span class="line"><span class="comment"># 例如，在群晖上可能是 /volume1/docker/tailscale</span></span><br></pre></td></tr></table></figure><h4 id="步骤-2：运行-Docker-容器">步骤 2：运行 Docker 容器</h4><p>复制并执行以下命令。这条命令已经包含了运行 Tailscale 所需的所有关键配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=tailscaled \</span><br><span class="line">  -v /path/to/your/appdata/tailscale:/var/lib/tailscale \</span><br><span class="line">  -v /dev/net/tun:/dev/net/tun \</span><br><span class="line">  --network=host \</span><br><span class="line">  --cap-add=NET_ADMIN \</span><br><span class="line">  --cap-add=NET_RAW \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  tailscale/tailscale</span><br></pre></td></tr></table></figure><p><strong>命令参数详解：</strong></p><ul><li><code>docker run -d</code>: 在后台（detached mode）运行容器。</li><li><code>--name=tailscaled</code>: 给容器起一个好记的名字，方便管理。</li><li><code>-v /path/to/your/appdata/tailscale:/var/lib/tailscale</code>: <strong>【核心】</strong> 将主机上的目录挂载到容器内，用于保存 Tailscale 的状态。<strong>务必替换为你自己的路径</strong>。</li><li><code>-v /dev/net/tun:/dev/net/tun</code>: 将主机的 TUN 设备挂载到容器内，这是 Tailscale 创建虚拟网卡所必需的。</li><li><code>--network=host</code>: <strong>【核心】</strong> 让容器直接使用主机的网络，这是最简单且功能最全的模式。容器可以轻松访问主机的所有端口，也方便将主机作为子网路由（Subnet Router）。</li><li><code>--cap-add=NET_ADMIN --cap-add=NET_RAW</code>: 授予容器操作网络接口所需的 Linux Capabilities 权限。</li><li><code>--restart unless-stopped</code>: 设置容器的重启策略，除非手动停止，否则 Docker 重启时会自动启动该容器。</li><li><code>tailscale/tailscale</code>: 指定要使用的官方 Docker 镜像。</li></ul><h4 id="步骤-3：将-NAS-加入你的-Tailscale-网络">步骤 3：将 NAS 加入你的 Tailscale 网络</h4><p>容器已经在运行了，但它还不知道自己是谁。我们需要执行一条命令来让它登录。</p><ol><li><p>执行以下命令，启动 Tailscale 并获取登录链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure></li><li><p>命令执行后，终端会输出一个登录 URL，看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To authenticate, visit:</span><br><span class="line"></span><br><span class="line">    https://login.tailscale.com/a/123456789ABC</span><br></pre></td></tr></table></figure></li><li><p>复制这个 URL，在你的电脑浏览器中打开，用你的 Tailscale 账户登录并授权这台新设备。</p></li><li><p>授权成功后，回到你的 <a href="https://login.tailscale.com/admin/machines">Tailscale Admin Console</a> 后台，你就能看到这台新设备已经加入了你的网络。</p></li></ol><p><strong>至此，你的 NAS 已经成功通过 Docker 加入了 Tailscale 网络！</strong> 你可以在任何其他已登录 Tailscale 的设备上，通过分配的 <code>100.x.x.x</code> IP 地址来访问你的 NAS。</p><hr><h3 id="部署方式二：使用-docker-compose（推荐，便于管理）">部署方式二：使用 <code>docker-compose</code>（推荐，便于管理）</h3><p>如果你需要管理多个容器，或者希望将配置以文件形式保存下来，<code>docker-compose</code> 是更好的选择。</p><h4 id="步骤-1：创建-docker-compose-yml-文件">步骤 1：创建 <code>docker-compose.yml</code> 文件</h4><p>在你喜欢的位置（例如 <code>/volume1/docker/tailscale</code>）创建一个名为 <code>docker-compose.yml</code> 的文件，并将以下内容粘贴进去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.7&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">tailscaled:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">tailscale/tailscale</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">tailscaled</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">my-nas</span> <span class="comment"># 在 Tailscale 管理后台显示的设备名</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/tailscale</span> <span class="comment"># 将状态保存在当前目录下的 data 文件夹</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/dev/net/tun:/dev/net/tun</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">host</span></span><br><span class="line">    <span class="attr">cap_add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NET_RAW</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>hostname</code>: 你可以自定义一个名字，这样在 Tailscale 后台一眼就能认出是哪台设备。</li><li><code>volumes</code>: <code>- ./data:/var/lib/tailscale</code> 这种相对路径的写法表示将状态文件保存在 <code>docker-compose.yml</code> 文件同级的 <code>data</code> 文件夹内，非常方便。</li></ul><h4 id="步骤-2：启动服务">步骤 2：启动服务</h4><p>在 <code>docker-compose.yml</code> 文件所在的目录中，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="步骤-3：登录和授权">步骤 3：登录和授权</h4><p>这一步和 <code>docker run</code> 方式完全一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose <span class="built_in">exec</span> tailscaled tailscale up</span><br></pre></td></tr></table></figure><p>然后复制输出的 URL 到浏览器完成授权。</p><hr><h3 id="高级功能：如何生成外链和访问内网？">高级功能：如何生成外链和访问内网？</h3><p>部署成功后，你可以利用 Tailscale 的高级功能来实现最初的目标。</p><h4 id="1-将-NAS-作为子网路由-Subnet-Router">1. 将 NAS 作为子网路由 (Subnet Router)</h4><p><strong>场景</strong>：你想通过手机（已连接 Tailscale）访问你家里的其他设备，比如打印机 (<code>192.168.1.100</code>)。</p><ol><li><p>修改启动命令，使其“宣告”它可以路由的内网网段。在执行 <code>tailscale up</code> 时加入 <code>--advertise-routes</code> 参数。</p><ul><li>你需要先 <code>down</code> 再 <code>up</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale down</span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.1.0/24</span><br><span class="line"><span class="comment"># !!! 将 192.168.1.0/24 替换为你自己的局域网网段 !!!</span></span><br><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale up --advertise-routes=192.168.10.0/24 -accept-dns=<span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在 Tailscale Admin Console 后台，找到你的 NAS 设备，点击右侧的 “…”，选择 “Edit route settings…”。</p></li><li><p>勾选并启用你刚刚宣告的子网路由。</p></li></ol><p>现在，你任何连接了 Tailscale 的设备，都可以直接访问 <code>192.168.1.x</code> 网段的所有设备了，就像在家一样。</p><h4 id="2-使用-Tailscale-Funnel-生成外链">2. 使用 Tailscale Funnel 生成外链</h4><p><strong>场景</strong>：你想临时分享 NAS 上的一个文件给没有安装 Tailscale 的朋友。</p><ol><li><p>确保你的 Docker 容器已经通过 <code>tailscale up</code> 成功连接。</p></li><li><p>假设你想分享的服务在主机的 <code>8080</code> 端口上（比如一个临时的文件服务器）。</p><ul><li>由于我们使用了 <code>--network=host</code>，容器可以直接访问到主机的 <code>8080</code> 端口。</li></ul></li><li><p>执行 Funnel 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> tailscaled tailscale funnel 8080</span><br></pre></td></tr></table></figure></li><li><p>命令会输出一个公网可访问的 HTTPS 链接，形如 <code>https://your-nas-hostname.ts.net</code>。将这个链接发给你的朋友即可。</p></li><li><p>分享完毕后，按 <code>Ctrl+C</code> 停止 Funnel，外链即刻失效，非常安全。如果想在后台运行，可以加上 <code>--bg</code> 参数。</p></li></ol><h3 id="总结：如何使用部署后的服务">总结：如何使用部署后的服务</h3><table><thead><tr><th style="text-align:left">你的需求</th><th style="text-align:left">使用的功能</th><th style="text-align:left">具体操作</th></tr></thead><tbody><tr><td style="text-align:left"><strong>在外面用</strong></td><td style="text-align:left"><strong>Tailscale 核心连接 + MagicDNS</strong></td><td style="text-align:left">在你的电脑/手机上安装并登录 Tailscale，然后像在家里一样，用 <code>http://设备名:端口</code> 的方式访问 NAS 的各项服务。</td></tr><tr><td style="text-align:left"><strong>映射为电脑硬盘</strong></td><td style="text-align:left"><strong>SMB/AFP over Tailscale</strong></td><td style="text-align:left">在电脑的“映射网络驱动器”或“连接服务器”功能中，使用 <code>\\设备名</code> 或 <code>smb://设备名</code> 作为地址。</td></tr><tr><td style="text-align:left"><strong>分享文件给别人</strong></td><td style="text-align:left"><strong>Tailscale Funnel</strong></td><td style="text-align:left">在 NAS 上用 Python 或其他方式启动一个临时 Web 服务器，然后用 <code>tailscale funnel &lt;端口号&gt;</code> 命令生成一个临时的公网下载链接。</td></tr><tr><td style="text-align:left"><strong>访问家里其他设备</strong></td><td style="text-align:left"><strong>子网路由 (Subnet Router)</strong></td><td style="text-align:left">在部署 Tailscale 时宣告内网网段，并在管理后台启用。之后就能直接通过内网 IP 访问家里所有设备。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;h3 id=&quot;一、Tailscale-到底是什么？&quot;&gt;一、Tailscale 到底是什么？&lt;/h3&gt;
&lt;p&gt;你可以把它理解成一个**“为你所有设备打造的、私人的、加密的虚拟局域网”**。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统的V</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>NAS 文件借助 MinIO 转换OSS</title>
    <link href="https://caozhaoqi.github.io/2025/07/16/minio-nas-build/"/>
    <id>https://caozhaoqi.github.io/2025/07/16/minio-nas-build/</id>
    <published>2025-07-16T08:58:11.000Z</published>
    <updated>2025-11-25T15:05:10.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体架构">整体架构</h3><p>这个架构的核心思想是：<strong>MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。</strong> 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理路径下。</p><h3 id="方案优点">方案优点</h3><ol><li><strong>协议现代化</strong>：将传统的、基于文件系统的访问（如 NFS, SMB）升级为现代的、基于 HTTP 的 S3 API 访问。</li><li><strong>无需数据迁移</strong>：数据仍然存放在 NAS 上，你不需要花费大量时间去拷贝或迁移 TB 级的海量数据。MinIO 直接在 NAS 的文件系统之上运行。</li><li><strong>统一访问入口</strong>：无论你有多少个 NAS 卷或目录，都可以通过 MinIO 的 Bucket（存储桶）来组织和访问，形成一个统一的视图。</li><li><strong>生态兼容性</strong>：几乎所有现代云原生应用、大数据框架、备份工具都原生支持 S3 协议，可以无缝对接。</li><li><strong>高性能</strong>：MinIO 本身是为高性能而设计的，可以直接利用 NAS 的硬件性能。</li></ol><hr><h3 id="第一步：准备工作">第一步：准备工作</h3><ol><li><strong>一台服务器/虚拟机</strong>：你需要一台 Linux 服务器来运行 MinIO。这台服务器<strong>必须能够高速挂载（mount）你的 NAS 目录</strong>。这台服务器的 CPU 和内存资源会影响 MinIO 的性能，但对于一般的文件服务，配置要求不高（例如 2核4G 内存即可起步）。我们称这台服务器为 “MinIO Server”。</li><li><strong>网络连接</strong>：确保 MinIO Server 和 NAS 之间有高速、低延迟的网络连接（例如，千兆或万兆以太网）。</li><li><strong>NAS 目录</strong>：确定你要提供为对象存储的 NAS 上的一个或多个目录。例如，<code>/volume1/data</code>。</li></ol><h3 id="第二步：在-MinIO-Server-上挂载-NAS-目录">第二步：在 MinIO Server 上挂载 NAS 目录</h3><p>这是最关键的一步。你必须将 NAS 的共享目录挂载到 MinIO Server 的本地文件系统上。</p><p>假设你的 NAS IP 是 <code>192.168.1.100</code>，共享的目录是 <code>shared_data</code>，你希望将它挂载到 MinIO Server 的 <code>/mnt/nas_data</code> 目录。</p><h4 id="使用-NFS-挂载（推荐）">使用 NFS 挂载（推荐）</h4><ol><li><p><strong>在 NAS 上</strong>：确保 NFS 服务已开启，并且 <code>shared_data</code> 目录已经通过 NFS 共享出去，同时授权 MinIO Server 的 IP (<code>192.168.1.50</code> 假设) 有读写权限。</p></li><li><p><strong>在 MinIO Server 上</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 NFS 客户端</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y nfs-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建本地挂载点</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 手动挂载进行测试</span></span><br><span class="line"><span class="comment"># -o nfsvers=4 指定版本，可根据你的NAS调整</span></span><br><span class="line"><span class="built_in">sudo</span> mount -t nfs 192.168.1.100:/shared_data /mnt/nas_data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 验证挂载是否成功</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"><span class="comment"># 你应该能看到类似下面的一行</span></span><br><span class="line"><span class="comment"># 192.168.1.100:/shared_data   50T   10T   40T   20% /mnt/nas_data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. (重要) 设置开机自动挂载，防止服务器重启后服务失效</span></span><br><span class="line"><span class="comment"># 编辑 /etc/fstab 文件</span></span><br><span class="line"><span class="built_in">sudo</span> nano /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在文件末尾添加一行 (使用 nofail 选项防止NAS故障导致服务器无法启动)</span></span><br><span class="line">192.168.1.100:/shared_data /mnt/nas_data nfs defaults,nofail 0 0</span><br></pre></td></tr></table></figure></li></ol><h3 id="第三步：使用-Docker-Compose-部署-MinIO">第三步：使用 Docker Compose 部署 MinIO</h3><p>使用 Docker Compose 是部署和管理 MinIO 最简单、最可靠的方式。</p><ol><li><p><strong>在 MinIO Server 上安装 Docker 和 Docker Compose。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker</span></span><br><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line"><span class="built_in">sudo</span> sh get-docker.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker Compose</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install -y docker-compose</span><br></pre></td></tr></table></figure></li><li><p><strong>创建一个工作目录并编写 <code>docker-compose.yml</code> 文件。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> minio-deployment</span><br><span class="line"><span class="built_in">cd</span> minio-deployment</span><br><span class="line">nano docker-compose.yml</span><br></pre></td></tr></table></figure></li><li><p><strong>将以下内容粘贴到 <code>docker-compose.yml</code> 文件中：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="comment"># 使用官方 MinIO 镜像</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">minio/minio:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">local-oss-server</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义环境变量 (请务必修改密码)</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Access Key (用户名)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_USER:</span> <span class="string">minioadmin</span></span><br><span class="line">      <span class="comment"># MinIO 的登录 Secret Key (密码, 至少8位)</span></span><br><span class="line">      <span class="attr">MINIO_ROOT_PASSWORD:</span> <span class="string">VERY_SECRET_PASSWORD_CHANGE_ME</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># volumes 卷挂载是核心</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 将我们刚刚挂载的 NAS 目录，映射到 MinIO 容器内部的 /data 目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas_data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/mnt/nas:/data2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ports 端口映射</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="comment"># 9000 端口是 S3 API 的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">      <span class="comment"># 9001 端口是 MinIO Web 控制台的访问端口</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9001:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># command 命令</span></span><br><span class="line">    <span class="comment"># 告诉 MinIO 启动一个服务器，并使用容器内的 /data 目录作为存储根目录</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">server</span> <span class="string">/data</span> <span class="string">/data2</span> <span class="string">--console-address</span> <span class="string">&quot;:9001&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 健康检查，确保服务正常运行</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:9000/minio/health/live&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">30s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">20s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动 MinIO 服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><h3 id="第四步：验证和使用">第四步：验证和使用</h3><p>现在，你的本地 OSS 服务已经搭建完成并开始运行了！</p><ol><li><p><strong>访问 Web 控制台</strong>：</p><ul><li>在浏览器中打开 <code>http://&lt;MinIO_Server_IP&gt;:9001</code>。</li><li>使用你在 <code>docker-compose.yml</code> 中设置的 <code>MINIO_ROOT_USER</code> (minioadmin) 和 <code>MINIO_ROOT_PASSWORD</code> 登录。</li></ul></li><li><p><strong>查看数据</strong>：</p><ul><li>登录后，你会看到 MinIO 的界面。点击 “Buckets”（存储桶）。</li><li><strong>你会惊喜地发现，你在 NAS 目录 <code>/mnt/nas_data</code> 下的所有一级子目录，都已经自动变成了 MinIO 的 Buckets！</strong></li><li>例如，如果你的 NAS 目录结构是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/mnt/nas_data/</span><br><span class="line">├── images/</span><br><span class="line">│   ├── cat.jpg</span><br><span class="line">│   └── dog.png</span><br><span class="line">└── videos/</span><br><span class="line">    └── movie.mp4</span><br></pre></td></tr></table></figure></li><li>那么在 MinIO 控制台里，你就会看到两个 bucket：<code>images</code> 和 <code>videos</code>。你可以直接点击进入并管理里面的文件。</li></ul></li><li><p><strong>使用 S3 API 访问</strong>：</p><ul><li><strong>Endpoint (服务地址)</strong>: <code>http://&lt;MinIO_Server_IP&gt;:9000</code></li><li><strong>Access Key</strong>: <code>minioadmin</code></li><li><strong>Secret Key</strong>: <code>VERY_SECRET_PASSWORD_CHANGE_ME</code></li><li>你可以使用任何支持 S3 的客户端工具（如 <code>s3cmd</code>, <code>mc</code>, AWS SDK）来连接和操作你的数据。</li></ul><p><strong>使用 MinIO Client (mc) 的示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 下载 mc</span></span><br><span class="line">wget https://dl.min.io/client/mc/release/linux-amd64/mc</span><br><span class="line"><span class="built_in">chmod</span> +x mc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> mc /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 配置一个别名，指向你的本地 OSS</span></span><br><span class="line">mc <span class="built_in">alias</span> <span class="built_in">set</span> local-oss http://&lt;MinIO_Server_IP&gt;:9000 minioadmin VERY_SECRET_PASSWORD_CHANGE_ME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 列出所有的 bucket (即 NAS 上的一级目录)</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 列出 images bucket 里的所有文件</span></span><br><span class="line">mc <span class="built_in">ls</span> local-oss/images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 上传一个新文件到 videos bucket</span></span><br><span class="line">mc <span class="built_in">cp</span> my_new_video.mp4 local-oss/videos</span><br><span class="line"><span class="comment"># 执行后，你会在 NAS 的 /mnt/nas_data/videos/ 目录下看到 my_new_video.mp4 文件</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="问题">问题</h3><ul><li>重启后残留文件清理</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf .minio.sys</span><br><span class="line">docker-compose down &amp;&amp; docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过 <strong>NAS 挂载 + MinIO Docker 部署</strong> 这个简单的两步组合，你成功地将传统的 NAS 文件存储“包装”成了一个功能强大、接口标准、易于扩展的本地对象存储服务。这个方案兼具了 NAS 的大容量存储成本优势和 OSS 的现代化接口优势，是盘活存量数据资产的绝佳实践。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;整体架构&quot;&gt;整体架构&lt;/h3&gt;
&lt;p&gt;这个架构的核心思想是：&lt;strong&gt;MinIO 作为对象存储的“前端”，而你的 NAS 仍然是数据的“后端”物理存储。&lt;/strong&gt; 用户和应用程序只与 MinIO 交互，完全不需要关心文件具体存放在 NAS 的哪个物理</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基于 FFmpeg 的视频场景（镜头边界）检测</title>
    <link href="https://caozhaoqi.github.io/2025/07/02/ffmpeg-detect-scene/"/>
    <id>https://caozhaoqi.github.io/2025/07/02/ffmpeg-detect-scene/</id>
    <published>2025-07-02T10:44:48.000Z</published>
    <updated>2025-11-25T15:05:10.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在视频处理领域，场景检测（Scene Detection）或称镜头分割（Shot Boundary Detection）是一项基础且关键的任务，广泛应用于视频索引、自动剪辑、内容摘要等场景。</p></blockquote><h2 id="1-技术可行性分析-Feasibility-Analysis"><strong>1. 技术可行性分析 (Feasibility Analysis)</strong></h2><p>将 FFmpeg 用于场景检测不仅可行，而且是一种非常成熟和高效的方案。其可行性主要基于以下几点：</p><ul><li><strong>内置的专业滤镜</strong>: FFmpeg 内置了专门为媒体分析设计的强大滤镜（filters），如 <code>scdet</code> 和 <code>select</code>，它们可以直接访问视频帧的底层数据，并进行快速的数学运算。</li><li><strong>像素级差异计算</strong>: 场景检测的核心原理是计算连续视频帧之间的视觉差异。当差异超过某个阈值时，即认为发生了场景切换。FFmpeg 的滤镜能够高效地执行这种像素级的直方图或帧差计算，并将结果量化为一个“场景变化分数”（scene score）。</li><li><strong>跨平台与标准化</strong>: FFmpeg 是一个跨平台的命令行工具，在 Windows, macOS, Linux 上表现一致，无需依赖复杂的图形界面或特定操作系统API。这使其成为自动化、服务器端处理流程的理想选择。</li><li><strong>轻量级与零依赖</strong>: 与需要安装庞大依赖库的专业软件或Python库相比，FFmpeg 只有一个可执行文件，部署简单，资源占用极低。</li></ul><p><strong>结论</strong>: FFmpeg 提供了实现场景检测所需的核心功能，其性能和标准化特性使其成为一个高度可行的技术选型。</p><h2 id="2-实现方法-Implementation"><strong>2. 实现方法 (Implementation)</strong></h2><p>实现 FFmpeg 场景检测的最佳实践是结合 <code>select</code> 和 <code>showinfo</code> 两个滤镜。这种方法比单独使用老旧的 <code>scdet</code> 滤镜输出更干净、更可靠。</p><p><strong>核心命令</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="string">&quot;input.mp4&quot;</span> -vf <span class="string">&quot;select=&#x27;gt(scene,THRESHOLD)&#x27;,showinfo&quot;</span> -f null -</span><br></pre></td></tr></table></figure><p><strong>命令解析</strong>:</p><ol><li><code>ffmpeg -i &quot;input.mp4&quot;</code>: 指定输入视频文件。</li><li><code>-vf &quot;...&quot;</code>: <code>-vf</code> 是 <code>-filter:v</code> 的缩写，用于指定视频滤镜链。</li><li><code>select='gt(scene,THRESHOLD)'</code>: 这是核心的<strong>选择滤镜</strong>。<ul><li><code>scene</code>: FFmpeg 内置的一个变量，代表当前帧与前一帧的场景变化分数（范围 0.0 到 1.0）。</li><li><code>gt(a, b)</code>: “Greater Than” 函数，当 <code>a &gt; b</code> 时返回真。</li><li><code>THRESHOLD</code>: 这是一个<strong>可调阈值</strong>（例如 <code>0.4</code>）。值越低，检测越灵敏。该滤镜会筛选出所有场景变化分数大于阈值的视频帧。</li></ul></li><li><code>,showinfo</code>: 这是<strong>信息打印滤镜</strong>。它会接收由 <code>select</code> 滤镜筛选出的帧，并在标准错误流（stderr）中打印出这些帧的详细信息，格式高度统一。</li><li><code>-f null -</code>: 指示 FFmpeg 不生成任何输出文件，仅执行滤镜分析，并将结果输出到标准输出/错误流。</li></ol><p><strong>Python 脚本实现</strong>:</p><p>在实际应用中，我们通常使用 Python 的 <code>subprocess</code> 模块来调用此命令并解析其输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_scenes_with_ffmpeg</span>(<span class="params">video_path, threshold=<span class="number">0.4</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用 FFmpeg 检测视频场景切换点。&quot;&quot;&quot;</span></span><br><span class="line">    command = [</span><br><span class="line">        <span class="string">&quot;ffmpeg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">        <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;gt(scene,<span class="subst">&#123;threshold&#125;</span>)&#x27;,showinfo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;null&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    process = subprocess.Popen(command, stderr=subprocess.PIPE, text=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    timestamps = []</span><br><span class="line">    <span class="comment"># 正则表达式专门匹配 showinfo 输出的 pts_time</span></span><br><span class="line">    regex = <span class="string">r&quot;\[Parsed_showinfo.*\] .* pts_time:([0-9]+\.?[0-9]*)&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> process.stderr:</span><br><span class="line">        <span class="keyword">match</span> = re.search(regex, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            timestamps.append(<span class="built_in">float</span>(<span class="keyword">match</span>.group(<span class="number">1</span>)))</span><br><span class="line">            </span><br><span class="line">    process.wait()</span><br><span class="line">    <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;FFmpeg command failed.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> timestamps</span><br></pre></td></tr></table></figure><h2 id="3-测试与验证方法-Testing-Validation"><strong>3. 测试与验证方法 (Testing &amp; Validation)</strong></h2><p>要验证 FFmpeg 场景检测的准确性，需要系统性的测试方法。</p><ol><li><p><strong>构建测试集 (Test Dataset Construction)</strong>:</p><ul><li><strong>正样本</strong>: 包含多种类型场景切换的视频。<ul><li><strong>硬切 (Hard Cuts)</strong>: 瞬间切换，FFmpeg 检测效果最好。</li><li><strong>淡入淡出 (Fades)</strong>: 逐渐变黑或从黑屏出现。</li><li><strong>叠化 (Dissolves)</strong>: 两个场景平滑过渡。</li><li><strong>快速运动/闪光</strong>: 容易产生误报的场景，如爆炸、相机快速摇晃、闪光灯。</li></ul></li><li><strong>负样本</strong>: 长镜头、无明显切换的视频，用于测试是否会产生误报。</li></ul></li><li><p><strong>人工标注 (Ground Truth Annotation)</strong>:</p><ul><li>使用视频编辑软件（如 Adobe Premiere, Final Cut Pro）手动记录测试集中所有场景切换的精确时间戳，作为“黄金标准”或“基准真相”（Ground Truth）。</li></ul></li><li><p><strong>量化评估指标 (Quantitative Metrics)</strong>:</p><ul><li>将 FFmpeg 检测出的时间戳与人工标注的时间戳进行比对（允许一个小的容忍窗口，如 ±0.5秒）。</li><li>计算以下指标：<ul><li><strong>精确率 (Precision)</strong>: <code>TP / (TP + FP)</code>，检测出的转场中有多少是正确的。</li><li><strong>召回率 (Recall)</strong>: <code>TP / (TP + FN)</code>，所有真实转场中，有多少被成功检测出来了。</li><li><strong>F1-Score</strong>: <code>2 * (Precision * Recall) / (Precision + Recall)</code>，精确率和召回率的调和平均值，是综合评估性能的常用指标。</li><li><code>TP</code> (True Positives): 正确检测到的转场。</li><li><code>FP</code> (False Positives): 误报的转场。</li><li><code>FN</code> (False Negatives): 漏掉的转场。</li></ul></li></ul></li><li><p><strong>阈值调优</strong>:</p><ul><li>通过在测试集上运行不同阈值（例如从 0.2 到 0.7），绘制 Precision-Recall 曲线，找到在特定应用场景下 F1-Score 最高的最佳阈值。</li></ul></li></ol><h2 id="4-优缺点分析-Pros-and-Cons"><strong>4. 优缺点分析 (Pros and Cons)</strong></h2><p><strong>优点 (Pros)</strong>:</p><ul><li><strong>性能卓越</strong>: 作为C语言编写的高度优化的程序，FFmpeg 的处理速度极快，远超许多高级语言实现的库。</li><li><strong>资源占用低</strong>: 内存和CPU占用都很小，非常适合在资源受限的环境或大规模服务器集群上运行。</li><li><strong>部署简单</strong>: 无需复杂的依赖安装，一个可执行文件即可搞定。</li><li><strong>高度可定制与集成</strong>: 可以通过调整阈值来控制灵敏度，并且能与 FFmpeg 其他上百种滤镜和功能（如切片、转码、截图）在同一个命令中无缝集成，形成强大的处理流水线。</li><li><strong>免费与开源</strong>: 无任何商业成本，社区活跃，文档丰富。</li></ul><p><strong>缺点 (Cons)</strong>:</p><ul><li><strong>仅基于像素，不理解内容</strong>: 这是其核心局限。FFmpeg 无法理解视频的语义。<ul><li><strong>对渐变转场不敏感</strong>: 对于淡入淡出、叠化等缓慢变化的转场，由于连续帧差异小，很容易被漏检 (False Negatives)。</li><li><strong>对剧烈运动敏感</strong>: 快速的镜头移动、爆炸、闪光灯等非场景切换的剧烈视觉变化，很容易被误报 (False Positives)。</li><li><strong>无法识别转场类型</strong>: 它只能告诉你“这里发生了变化”，但无法区分是硬切还是其他特效。</li></ul></li><li><strong>阈值依赖性强</strong>: 效果好坏严重依赖于阈值的设定，而“最佳阈值”对于不同类型（如动画、电影、Vlog）的视频可能完全不同，需要经验或实验来确定。</li><li><strong>需要外部调用与解析</strong>: 它不是一个原生库，在 Python 等语言中使用时，必须通过子进程调用，并编写正则表达式等代码来解析其文本输出，增加了集成的复杂性。</li></ul><h2 id="5-效率评估-Efficiency-Evaluation"><strong>5. 效率评估 (Efficiency Evaluation)</strong></h2><p>FFmpeg 的效率是其最显著的优势之一。</p><ul><li><strong>处理速度</strong>: 在现代多核 CPU 上，处理一个 1080p 的视频文件，其速度通常可以达到实时速度的数倍甚至数十倍（例如，处理1小时的视频可能只需要几分钟）。由于其主要进行数学计算，性能瓶颈通常在于磁盘 I/O 或 CPU 单核性能。</li><li><strong>与 PySceneDetect 的对比</strong>:<ul><li><code>PySceneDetect</code> (使用 OpenCV 后端) 同样高效，但通常会比 FFmpeg 稍慢，因为它有 Python 层的开销。</li><li>当 <code>PySceneDetect</code> 使用更复杂的检测器（如 <code>ThresholdDetector</code>，检测黑场/白场）时，其开销会进一步增加。</li><li>FFmpeg 的优势在于其纯 C 实现和极简的计算逻辑，使其在原始速度上通常保持领先。</li></ul></li><li><strong>内存使用</strong>: FFmpeg 采用流式处理（streaming），一次只在内存中保留少量帧进行计算，因此内存占用非常稳定且低下，即便是处理数小时的长视频也不会耗尽内存。</li></ul><p><strong>优化建议</strong>: 虽然 FFmpeg 已经很快，但对于超高分辨率视频（如 4K, 8K），可以通过在滤镜链中加入 <code>scale</code> 滤镜进行<strong>降采样</strong>来进一步提速，例如 <code>scale=640:-1</code>，这通常不会影响硬切检测的准确性。</p><h2 id="6-案例">6. 案例</h2><ul><li>code</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Any</span>, <span class="type">Tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. Setup Logging ---</span></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_logging</span>(<span class="params">log_file: <span class="built_in">str</span> = <span class="string">&quot;analysis.log&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Configures logging to file and console.&quot;&quot;&quot;</span></span><br><span class="line">    logging.basicConfig(</span><br><span class="line">        level=logging.INFO,</span><br><span class="line">        <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s [%(levelname)s] - %(message)s&quot;</span>,</span><br><span class="line">        handlers=[</span><br><span class="line">            logging.FileHandler(log_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">            logging.StreamHandler()  <span class="comment"># Also print to console</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">analyze_video_transitions</span>(<span class="params"></span></span><br><span class="line"><span class="params">        video_path: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">        ffmpeg_path: <span class="built_in">str</span> = <span class="string">&quot;ffmpeg&quot;</span>,</span></span><br><span class="line"><span class="params">        threshold: <span class="built_in">float</span> = <span class="number">0.4</span></span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[<span class="type">List</span>[<span class="built_in">float</span>], <span class="built_in">str</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Analyzes a video file for scene transitions using ffmpeg.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function uses the &#x27;select&#x27; and &#x27;showinfo&#x27; filters in ffmpeg, which is a</span></span><br><span class="line"><span class="string">    more robust method than parsing the output of &#x27;scdet&#x27; alone. It identifies</span></span><br><span class="line"><span class="string">    frames where the scene change score exceeds a given threshold.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        video_path: The absolute or relative path to the video file.</span></span><br><span class="line"><span class="string">        ffmpeg_path: The path to the ffmpeg executable. Defaults to &#x27;ffmpeg&#x27;.</span></span><br><span class="line"><span class="string">        threshold: The sensitivity for scene detection, from 0.0 to 1.0.</span></span><br><span class="line"><span class="string">                   Lower values detect more transitions. A common default is 0.4.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A tuple containing:</span></span><br><span class="line"><span class="string">        - A sorted list of timestamps (in seconds) where transitions were detected.</span></span><br><span class="line"><span class="string">        - The complete, raw stderr output from the ffmpeg command for debugging.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        FileNotFoundError: If the ffmpeg executable is not found at ffmpeg_path.</span></span><br><span class="line"><span class="string">        FFmpegError: If ffmpeg returns a non-zero exit code, indicating an error</span></span><br><span class="line"><span class="string">                     (e.g., invalid video file, incorrect parameters).</span></span><br><span class="line"><span class="string">        ValueError: If the provided video_path does not exist.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># It&#x27;s good practice to check for file existence early</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(video_path):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Video file not found at: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This command is more robust:</span></span><br><span class="line">    <span class="comment"># - `select=&#x27;gt(scene,&#123;threshold&#125;)&#x27;`: Selects frames where the scene change</span></span><br><span class="line">    <span class="comment">#   score is greater than the threshold.</span></span><br><span class="line">    <span class="comment"># - `showinfo`: Prints information about the selected frames to stderr.</span></span><br><span class="line">    <span class="comment"># The output is structured and easy to parse.</span></span><br><span class="line">    command = [</span><br><span class="line">        ffmpeg_path,</span><br><span class="line">        <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">        <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;gt(scene,<span class="subst">&#123;threshold&#125;</span>)&#x27;,showinfo&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;null&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        process = subprocess.Popen(</span><br><span class="line">            command,</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">            stderr=subprocess.PIPE,</span><br><span class="line">            text=<span class="literal">True</span>,</span><br><span class="line">            encoding=<span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">            errors=<span class="string">&#x27;replace&#x27;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(</span><br><span class="line">            <span class="string">f&quot;ffmpeg executable not found at &#x27;<span class="subst">&#123;ffmpeg_path&#125;</span>&#x27;. &quot;</span></span><br><span class="line">            <span class="string">&quot;Please install ffmpeg or provide the correct path.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Process stderr line-by-line for memory efficiency</span></span><br><span class="line">    timestamps = []</span><br><span class="line">    <span class="comment"># The regex now specifically looks for &#x27;pts_time&#x27; from the showinfo filter</span></span><br><span class="line">    regex = <span class="string">r&quot;\[Parsed_showinfo.*\] .* pts_time:([0-9]+\.?[0-9]*)&quot;</span></span><br><span class="line"></span><br><span class="line">    stderr_lines = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> process.stderr:</span><br><span class="line">        stderr_lines.append(line)</span><br><span class="line">        <span class="keyword">match</span> = re.search(regex, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            time_str = <span class="keyword">match</span>.group(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> time_str:</span><br><span class="line">                timestamps.append(<span class="built_in">float</span>(time_str))</span><br><span class="line"></span><br><span class="line">    process.wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Check for ffmpeg errors after processing is complete</span></span><br><span class="line">    <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">        full_stderr = <span class="string">&quot;&quot;</span>.join(stderr_lines)</span><br><span class="line">        <span class="comment"># raise FFmpegError(</span></span><br><span class="line">        <span class="comment">#     f&quot;ffmpeg failed with exit code &#123;process.returncode&#125;.\n&quot;</span></span><br><span class="line">        <span class="comment">#     f&quot;Command: &#123;&#x27; &#x27;.join(command)&#125;\n&quot;</span></span><br><span class="line">        <span class="comment">#     f&quot;Stderr:\n&#123;full_stderr&#125;&quot;</span></span><br><span class="line">        <span class="comment"># )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Timestamps from showinfo should already be in order, but sorting is safe</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(timestamps), <span class="string">&quot;&quot;</span>.join(stderr_lines)</span><br><span class="line"></span><br><span class="line"><span class="meta">@logger.catch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Main function to run the analysis script.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Configuration ---</span></span><br><span class="line">    <span class="comment"># 1. Setup logging first</span></span><br><span class="line">    log_file = <span class="string">&quot;./logs/transition_analysis.log&quot;</span></span><br><span class="line">    os.makedirs(log_file, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    setup_logging(log_file)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. Get user input for video directory</span></span><br><span class="line">    video_directory = <span class="string">&quot;/Volumes/share/新建文件夹/7，1数据&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. Output JSON file path</span></span><br><span class="line">    output_json_path = <span class="string">&quot;./data/transition_analysis_results.json&quot;</span></span><br><span class="line"></span><br><span class="line">    os.makedirs(<span class="string">&quot;./data&quot;</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. (Optional) FFmpeg executable path</span></span><br><span class="line">    ffmpeg_executable = <span class="string">&quot;ffmpeg&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. Supported video file extensions</span></span><br><span class="line">    supported_extensions = &#123;<span class="string">&quot;.mp4&quot;</span>, <span class="string">&quot;.mkv&quot;</span>, <span class="string">&quot;.mov&quot;</span>, <span class="string">&quot;.avi&quot;</span>, <span class="string">&quot;.webm&quot;</span>, <span class="string">&quot;.flv&quot;</span>&#125;</span><br><span class="line">    <span class="comment"># --- End of Configuration ---</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(video_directory):</span><br><span class="line">        logging.error(<span class="string">f&quot;Directory not found at &#x27;<span class="subst">&#123;video_directory&#125;</span>&#x27;. Aborting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    all_results: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">&quot;Starting video transition analysis...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 2. Find all video files first to set up the progress bar ---</span></span><br><span class="line">    video_files_to_process = []</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(video_directory):</span><br><span class="line">        file_path = os.path.join(video_directory, filename)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path) <span class="keyword">and</span> Path(filename).suffix.lower() <span class="keyword">in</span> supported_extensions:</span><br><span class="line">            video_files_to_process.append(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files_to_process:</span><br><span class="line">        logging.warning(<span class="string">&quot;No video files found in the specified directory.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 3. Process files with a tqdm progress bar ---</span></span><br><span class="line">    <span class="keyword">with</span> tqdm(total=<span class="built_in">len</span>(video_files_to_process), desc=<span class="string">&quot;Analyzing Videos&quot;</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">        <span class="keyword">for</span> video_path <span class="keyword">in</span> video_files_to_process:</span><br><span class="line">            filename = os.path.basename(video_path)</span><br><span class="line">            pbar.set_description(<span class="string">f&quot;Processing <span class="subst">&#123;filename[:<span class="number">20</span>]&#125;</span>...&quot;</span>)  <span class="comment"># Update progress bar description</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                transition_times, ffmpeg_log = analyze_video_transitions(video_path, ffmpeg_executable)</span><br><span class="line"></span><br><span class="line">                logging.info(<span class="string">f&quot;Successfully analyzed &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;. Found <span class="subst">&#123;<span class="built_in">len</span>(transition_times)&#125;</span> transitions.&quot;</span>)</span><br><span class="line">                all_results[filename] = &#123;</span><br><span class="line">                    <span class="string">&quot;file_path&quot;</span>: video_path,</span><br><span class="line">                    <span class="string">&quot;transitions&quot;</span>: transition_times,</span><br><span class="line">                    <span class="string">&quot;transition_count&quot;</span>: <span class="built_in">len</span>(transition_times)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(<span class="string">f&quot;Failed to analyze &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">                <span class="comment"># Also log the full ffmpeg output for debugging</span></span><br><span class="line">                logging.debug(<span class="string">f&quot;FFmpeg stderr for failed file &#x27;<span class="subst">&#123;filename&#125;</span>&#x27;:\n<span class="subst">&#123;ffmpeg_log&#125;</span>&quot;</span>)</span><br><span class="line">                all_results[filename] = &#123;</span><br><span class="line">                    <span class="string">&quot;error&quot;</span>: <span class="built_in">str</span>(e)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            pbar.update(<span class="number">1</span>)  <span class="comment"># Move progress bar forward by one step</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save the results to a JSON file</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(output_json_path, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(all_results, f, indent=<span class="number">4</span>, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">        logging.info(<span class="string">f&quot;Analysis complete. Results saved to &#x27;<span class="subst">&#123;output_json_path&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;Error saving results to JSON file: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><ul><li>output</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">    <span class="attr">&quot;6月27日 (1)-71.mp4&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;file_path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Volumes/share/新建文件夹/7，1数据/6月27日 (1)-71.mp4&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;transitions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="number">4.0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">7.666667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">11.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">16.566667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">22.866667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">27.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">29.266667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">34.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">36.966667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">49.566667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">57.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">61.766667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">63.5</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">69.866667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">74.8</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">79.466667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">81.266667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">84.066667</span><span class="punctuation">,</span></span><br><span class="line">            <span class="number">88.266667</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;transition_count&quot;</span><span class="punctuation">:</span> <span class="number">19</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>log</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2025-07-02 17:50:43,359 [INFO] - Successfully analyzed &#x27;._6月27日 (1)-36.mp4&#x27;. Found 0 transitions.</span><br><span class="line">2025-07-02 17:50:55,619 [INFO] - Successfully analyzed &#x27;6月27日 (1)-71.mp4&#x27;. Found 19 transitions.</span><br><span class="line">2025-07-02 17:50:55,620 [INFO] - Analysis complete. Results saved to &#x27;transition_analysis_results.json&#x27;</span><br></pre></td></tr></table></figure><h2 id="结论"><strong>结论</strong></h2><h3 id="检出效果对比">检出效果对比</h3><table><thead><tr><th style="text-align:left">对比项</th><th style="text-align:left"><strong>方法一: PySceneDetect (pyscenedetect_analysis.py)</strong></th><th style="text-align:left"><strong>方法二: FFmpeg (transition_analysis.py)</strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>核心技术</strong></td><td style="text-align:left">使用专业的Python场景检测库 <code>scenedetect</code>。通过 <code>ContentDetector</code> 算法，比较连续帧在亮度（luma）和色度（chroma）上的变化来识别场景切换。</td><td style="text-align:left">调用外部命令行工具 FFmpeg，并使用其内置的 <code>select</code> 和 <code>showinfo</code> 滤镜组合。该方法基于一个简单的“场景变化分数”（scene score）进行阈值判断。</td></tr><tr><td style="text-align:left"><strong>检测灵敏度与准确性</strong></td><td style="text-align:left"><strong>高</strong>。此方法非常灵敏，能稳定地识别出大量的有效场景切换点。其算法对硬切（Hard Cuts）的识别准确率很高。</td><td style="text-align:left"><strong>依赖阈值，默认较低</strong>。在 <code>threshold=0.4</code> 的设置下，灵敏度可能不足，导致大量明显的镜头切换被漏检。需要针对视频内容进行细致的阈值调优才能达到理想效果。</td></tr><tr><td style="text-align:left"><strong>结果对比 (示例)</strong></td><td style="text-align:left"><code>6月27日 (1)-47.mp4</code>: 检出 <strong>46</strong> 个<br><code>6月27日 (1)-49.mp4</code>: 检出 <strong>43</strong> 个<br><code>6.27(1)-64.mp4</code>: 检出 <strong>17</strong> 个</td><td style="text-align:left"><code>6月27日 (1)-47.mp4</code>: 检出 <strong>0</strong> 个<br><code>6月27日 (1)-49.mp4</code>: 检出 <strong>33</strong> 个<br><code>6.27(1)-64.mp4</code>: 检出 <strong>4</strong> 个</td></tr><tr><td style="text-align:left"><strong>文件处理健壮性</strong></td><td style="text-align:left"><strong>高</strong>。脚本中加入了明确的逻辑，能自动识别并跳过 macOS 系统产生的无效元数据文件（如 <code>._filename.mp4</code>），避免了因处理无效文件而导致的程序崩溃或错误。</td><td style="text-align:left"><strong>中等</strong>。脚本会尝试处理 <code>._</code> 开头的无效文件。虽然 FFmpeg 本身通常不会因此崩溃（会报告错误并退出），但这浪费了处理时间，并在日志和结果文件中留下了无效条目。</td></tr><tr><td style="text-align:left"><strong>性能与效率</strong></td><td style="text-align:left"><strong>中等</strong>。单个文件处理速度相对较慢，因其在Python层有一定开销。但通过自动降采样（downscaling）高分辨率视频，性能已得到显著优化，最终以可接受的速度换取高质量的检测结果。</td><td style="text-align:left"><strong>非常高</strong>。作为C语言编写的底层工具，单个文件处理速度极快。但这种速度优势建立在算法相对简单的基础上，牺牲了部分准确性和对复杂转场的识别能力。</td></tr><tr><td style="text-align:left"><strong>易用性与集成</strong></td><td style="text-align:left"><strong>高</strong>。作为原生Python库，集成方便，无需处理外部进程和解析文本输出。API友好，返回直接可用的Python数据结构（如列表）。</td><td style="text-align:left"><strong>中等</strong>。需要通过 <code>subprocess</code> 模块调用，并编写正则表达式来解析 <code>stderr</code> 输出，集成相对复杂，且容易因FFmpeg版本更新导致解析逻辑失效。</td></tr><tr><td style="text-align:left"><strong>依赖与部署</strong></td><td style="text-align:left"><strong>中等</strong>。需要通过 <code>pip</code> 安装 <code>scenedetect</code> 及其依赖（如 <code>opencv-python</code>），环境配置相对复杂。</td><td style="text-align:left"><strong>简单</strong>。仅依赖于一个单一的 FFmpeg 可执行文件，部署和分发非常方便。</td></tr><tr><td style="text-align:left"><strong>推荐场景</strong></td><td style="text-align:left">适用于对<strong>检测准确性要求高</strong>、需要稳定可靠结果的应用。是构建专业视频分析工具和服务的首选。</td><td style="text-align:left">适用于对<strong>处理速度要求极高</strong>、资源受限，且主要任务是检测硬切（Hard Cuts）的批量自动化流程。</td></tr></tbody></table><h3 id="检出数目对比">检出数目对比</h3><table><thead><tr><th style="text-align:left">检测方法</th><th style="text-align:left">分析的视频总数</th><th style="text-align:left">成功检出转场的视频数</th><th style="text-align:left">检出率</th></tr></thead><tbody><tr><td style="text-align:left">方法一: PySceneDetect</td><td style="text-align:left">48</td><td style="text-align:left">37</td><td style="text-align:left">77.1%</td></tr><tr><td style="text-align:left">方法二: FFmpeg</td><td style="text-align:left">48</td><td style="text-align:left">19</td><td style="text-align:left">39.6%</td></tr></tbody></table><h3 id="总结">总结</h3><ul><li><p>PySceneDetect 效果远胜 FFmpeg：PySceneDetect 成功在 37 个视频中找到了转场，而 FFmpeg 只在其中的 19 个视频中找到了转场。PySceneDetect 的“命中率”几乎是 FFmpeg 的两倍。</p></li><li><p>FFmpeg 漏检严重：从数据可以看出，FFmpeg 的方法漏掉了大量有转场的视频。例如，在 PySceneDetect 检出 80 个转场的 6月27日 (1)-7.mp4 视频中，FFmpeg 的结果为 0。这种巨大的差异表明 FFmpeg 的 scdet 滤镜在当前参数下过于迟钝，不适合用于精确的场景切分。</p></li></ul><blockquote><p>FFmpeg 是一种用于视频场景检测的“快、准（对硬切而言）、狠”的工具**。它非常适合于需要<strong>大规模、自动化、快速处理</strong>视频，且主要目标是检测<strong>硬切</strong>的场景。它的高性能、低资源占用和强大的集成能力使其在后端服务和数据预处理流程中具有不可替代的价值。</p></blockquote><h2 id="See">See</h2><ul><li><a href="https://ffmpeg.org/ffmpeg-bitstream-filters.html">https://ffmpeg.org/ffmpeg-bitstream-filters.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在视频处理领域，场景检测（Scene Detection）或称镜头分割（Shot Boundary Detection）是一项基础且关键的任务，广泛应用于视频索引、自动剪辑、内容摘要等场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>TransNetV2模型用于视频复杂转场检测</title>
    <link href="https://caozhaoqi.github.io/2025/06/09/TransNetV2-model-use/"/>
    <id>https://caozhaoqi.github.io/2025/06/09/TransNetV2-model-use/</id>
    <published>2025-06-09T02:39:48.000Z</published>
    <updated>2025-11-25T15:05:10.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TransNet-V2-模型介绍">TransNet V2 模型介绍</h2><ol><li>目标：<br>TransNet V2 的目标是创建一个快速且准确的镜头边界检测（Shot Boundary Detection, SBD）模型。它能够识别视频中的两种主要类型的镜头切换：<ul><li>硬切 (Hard Cuts): 两个镜头之间的突变。</li><li>渐变转场 (Gradual Transitions): 如溶解 (dissolves)、淡入淡出 (fades)、划像 (wipes) 等，这些转场会持续数帧。</li></ul></li></ol><ul><li>模型架构</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/transnetv2_struct.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/transnetv2_struct.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ol start="2"><li><p>核心思想：<br>TransNet V2 是一个深度神经网络。它直接处理一系列连续的、低分辨率的 RGB 视频帧，来预测每一帧发生镜头转换的概率，并能区分转场类型。</p></li><li><p>关键架构特点：</p><ul><li>输入 (Input)：<ul><li>模型接收 <code>N</code> 个连续的、低分辨率 RGB 视频帧作为输入（例如，论文中常使用 <code>N=100</code> 帧，每帧分辨率缩小到 <code>48x27</code> 像素）。</li><li>直接使用原始的、降采样后的 RGB 帧（而不是预先计算的特征，如帧差或光流）使得网络可以端到端地学习最优的视觉特征。</li></ul></li><li>帧编码 (Frame Encoding)：<ul><li>输入的每一帧首先会经过两个 2D 卷积层和最大池化层，用于提取空间特征。</li><li>这些特征图随后被展平 (flatten) 并按时间顺序堆叠起来，形成一个特征序列。</li></ul></li><li>时间建模 (Temporal Modeling) - 核心部分：<ul><li>TransNet V2 的核心是一堆一维扩张卷积 (1D Dilated Convolutions) 块，它们作用于帧特征序列。</li><li>一维卷积： 非常适合处理序列数据，计算效率高。</li><li>扩张卷积 (Dilated Convolutions)： 允许网络在不显著增加参数数量或计算成本（通过避免过多的池化层）的情况下，拥有非常大的感受野（即能看到很长的时间上下文）。这对于检测跨越多帧的渐变转场至关重要。每个扩张卷积块通常包含一个扩张一维卷积层、批量归一化 (Batch Normalization)、ReLU 激活函数和 Dropout。</li></ul></li><li>双预测头 (Dual Prediction Heads)：<br>网络从最后一个扩张卷积层的输出特征中引出两个分支（预测头）：<ol><li>转场概率预测 (Transition Probability Prediction)： 一个核大小为 1 的一维卷积层，后接 Sigmoid 激活函数。对输入序列中的每一帧输出一个概率值（0 到 1），表示该帧是镜头边界（硬切或渐变转场的中心）的可能性。使用二元交叉熵 (BCE) 损失进行训练。</li><li>转场类型预测 (Transition Type Prediction - One-Hot)： 另一个核大小为 1 的一维卷积层，有 3 个输出通道，每个通道后接 Sigmoid。它们分别预测每一帧属于以下类别的概率：<ul><li>无镜头转场</li><li>硬切</li><li>渐变转场的中心<br>这被视为三个独立的二分类问题，同样使用 BCE 损失训练。这个辅助任务有助于网络学习更丰富的特征。</li></ul></li></ol></li><li>组合损失 (Combined Loss)：<br>总损失是两个预测头 BCE 损失的加权和。</li></ul></li><li><p>模型优势：</p><ul><li>高准确性： 在多个标准 SBD 数据集（如 ClipShots, TRECVID IACC.3, RAI, BBC Planet Earth）上取得了业界领先 (SOTA) 的结果。</li><li>高速度： 为效率而设计，在现代 GPU 上能够实现远超实时的处理速度（例如，在 NVIDIA V100 上网络推理部分约 150 FPS，不包括视频解码）。</li><li>鲁棒性强： 能够有效处理硬切和各种复杂的渐变转场。</li><li>端到端学习： 直接从低分辨率 RGB 帧中学习特征，无需复杂的手动特征工程。</li></ul></li></ol><h2 id="TransNet-V2-使用方法-推理与后处理">TransNet V2 使用方法 (推理与后处理)</h2><ol><li><p>输入视频处理：</p><ul><li>将视频解码成单独的帧。</li><li>将每一帧的大小调整到网络所需的输入分辨率（例如 <code>48x27</code> 像素）。</li></ul></li><li><p>滑动窗口推理：</p><ul><li>视频以 <code>N</code> 帧（如 100 帧）的重叠窗口进行处理。</li><li>对于每个窗口，网络从主要的转场概率预测头输出 <code>N</code> 个概率值（对应窗口中的每一帧）。</li><li>由于窗口是重叠的，视频中的同一帧可能会获得多个预测。通常会对这些预测进行平均，以获得该帧更稳定的概率。</li></ul></li><li><p>预测结果后处理：</p><ul><li>阈值化 (Thresholding)：<ul><li>将（平均后的）逐帧概率与一个预定义的阈值 <code>P_thresh</code> 进行比较。概率超过此阈值的帧被认为是候选的镜头边界。</li><li>论文建议 <code>P_thresh = 0.5</code> 是一个不错的默认值，但可以根据实际情况调整。</li></ul></li><li>最小镜头长度 (Minimum Shot Length - <code>L_min</code>)：<ul><li>为了避免产生许多非常短的、可能是误报的镜头，会施加一个约束：任何会导致镜头长度小于 <code>L_min</code> 帧的检测边界都会被丢弃。</li><li>这通常通过遍历候选边界并确保其与前一个已接受边界的距离至少为 <code>L_min</code> 来实现。</li><li>论文中提到根据数据集或期望的粒度使用 <code>L_min</code> 值，如 10 帧或 25 帧。</li></ul></li></ul></li><li><p>输出：</p><ul><li>最终输出是一个列表，包含检测到的镜头边界所在的帧索引号。</li><li>可选地，可以使用转场类型预测头的输出来对检测到的边界进行分类，但通常主要关注的是边界的检测本<br>身。</li></ul></li></ol><ul><li>模型检测结果</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/detect_result.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/detect_result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="使用">使用</h2><h3 id="模型推理">模型推理</h3><ul><li>推理脚本如下：</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys  <span class="comment"># 引入 sys 以便使用 sys.stderr</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransNetV2</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model_dir=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> model_dir <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            model_dir = os.path.join(os.path.dirname(__file__), <span class="string">&quot;transnetv2-weights/&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(model_dir):</span><br><span class="line">                <span class="keyword">raise</span> FileNotFoundError(<span class="string">f&quot;[TransNetV2] ERROR: <span class="subst">&#123;model_dir&#125;</span> is not a directory.&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] Using weights from <span class="subst">&#123;model_dir&#125;</span>.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>._input_size = (<span class="number">27</span>, <span class="number">48</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>._model = tf.saved_model.load(model_dir)</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">raise</span> IOError(<span class="string">f&quot;[TransNetV2] It seems that files in <span class="subst">&#123;model_dir&#125;</span> are corrupted or missing. &quot;</span></span><br><span class="line">                          <span class="string">f&quot;Re-download them manually and retry. For more info, see: &quot;</span></span><br><span class="line">                          <span class="string">f&quot;https://github.com/soCzech/TransNetV2/issues/1#issuecomment-647357796&quot;</span>) <span class="keyword">from</span> exc</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_raw</span>(<span class="params">self, frames: np.ndarray</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(frames.shape) == <span class="number">5</span> <span class="keyword">and</span> frames.shape[<span class="number">2</span>:] == <span class="variable language_">self</span>._input_size, \</span><br><span class="line">            <span class="string">&quot;[TransNetV2] Input shape must be [batch, frames, height, width, 3].&quot;</span></span><br><span class="line">        frames = tf.cast(frames, tf.float32)</span><br><span class="line"></span><br><span class="line">        logits, dict_ = <span class="variable language_">self</span>._model(frames)</span><br><span class="line">        single_frame_pred = tf.sigmoid(logits)</span><br><span class="line">        all_frames_pred = tf.sigmoid(dict_[<span class="string">&quot;many_hot&quot;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> single_frame_pred, all_frames_pred</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_frames</span>(<span class="params">self, frames: np.ndarray</span>):</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(frames.shape) == <span class="number">4</span> <span class="keyword">and</span> frames.shape[<span class="number">1</span>:] == <span class="variable language_">self</span>._input_size, \</span><br><span class="line">            <span class="string">&quot;[TransNetV2] Input shape must be [frames, height, width, 3].&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">input_iterator</span>():</span><br><span class="line">            <span class="comment"># return windows of size 100 where the first/last 25 frames are from the previous/next batch</span></span><br><span class="line">            <span class="comment"># the first and last window must be padded by copies of the first and last frame of the video</span></span><br><span class="line">            no_padded_frames_start = <span class="number">25</span></span><br><span class="line">            no_padded_frames_end = <span class="number">25</span> + <span class="number">50</span> - (<span class="built_in">len</span>(frames) % <span class="number">50</span> <span class="keyword">if</span> <span class="built_in">len</span>(frames) % <span class="number">50</span> != <span class="number">0</span> <span class="keyword">else</span> <span class="number">50</span>)  <span class="comment"># 25 - 74</span></span><br><span class="line"></span><br><span class="line">            start_frame = np.expand_dims(frames[<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">            end_frame = np.expand_dims(frames[-<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">            padded_inputs = np.concatenate(</span><br><span class="line">                ([start_frame] * no_padded_frames_start) + [frames] + ([end_frame] * no_padded_frames_end), <span class="number">0</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            ptr = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> ptr + <span class="number">100</span> &lt;= <span class="built_in">len</span>(padded_inputs):</span><br><span class="line">                out = padded_inputs[ptr:ptr + <span class="number">100</span>]</span><br><span class="line">                ptr += <span class="number">50</span></span><br><span class="line">                <span class="keyword">yield</span> out[np.newaxis]</span><br><span class="line"></span><br><span class="line">        predictions = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在循环外部初始化处理帧数的计数器</span></span><br><span class="line">        processed_frames_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> inp <span class="keyword">in</span> input_iterator():</span><br><span class="line">            single_frame_pred, all_frames_pred = <span class="variable language_">self</span>.predict_raw(inp)</span><br><span class="line">            predictions.append((single_frame_pred.numpy()[<span class="number">0</span>, <span class="number">25</span>:<span class="number">75</span>, <span class="number">0</span>],</span><br><span class="line">                                all_frames_pred.numpy()[<span class="number">0</span>, <span class="number">25</span>:<span class="number">75</span>, <span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">            processed_frames_count = <span class="built_in">min</span>(<span class="built_in">len</span>(predictions) * <span class="number">50</span>, <span class="built_in">len</span>(frames))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\r[TransNetV2] Processing video frames &#123;&#125;/&#123;&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                processed_frames_count, <span class="built_in">len</span>(frames)</span><br><span class="line">            ), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 确保即使视频帧数少于一个批次，也会打印最终的换行符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(frames) &gt; <span class="number">0</span>:  <span class="comment"># 只有在有帧的情况下才打印换行，避免空视频也打印</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">        single_frame_pred_list = [single_ <span class="keyword">for</span> single_, all_ <span class="keyword">in</span> predictions]</span><br><span class="line">        all_frames_pred_list = [all_ <span class="keyword">for</span> single_, all_ <span class="keyword">in</span> predictions]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> single_frame_pred_list:  <span class="comment"># 如果 predictions 为空 (例如，视频帧数非常少)</span></span><br><span class="line">            <span class="comment"># 根据 frames 的长度创建一个全零的预测数组</span></span><br><span class="line">            <span class="comment"># 这确保了即使没有通过迭代器处理任何内容，也会返回正确形状的数组</span></span><br><span class="line">            <span class="comment"># （尽管对于非常短的视频，这可能仍然不是理想的，但至少避免了 concatenate 空列表的错误）</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 WARNING] No predictions generated from input_iterator for a video of length <span class="subst">&#123;<span class="built_in">len</span>(frames)&#125;</span>. Returning zeros.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            empty_preds_shape = (<span class="built_in">len</span>(frames),)  <span class="comment"># 或者 (0,) 如果 len(frames) 是 0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(frames) == <span class="number">0</span>:  <span class="comment"># 处理0帧视频的极端情况</span></span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([])</span><br><span class="line">            <span class="keyword">return</span> np.zeros(empty_preds_shape, dtype=np.float32), np.zeros(empty_preds_shape, dtype=np.float32)</span><br><span class="line"></span><br><span class="line">        single_frame_pred_concatenated = np.concatenate(single_frame_pred_list)</span><br><span class="line">        all_frames_pred_concatenated = np.concatenate(all_frames_pred_list)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> single_frame_pred_concatenated[:<span class="built_in">len</span>(frames)], all_frames_pred_concatenated[</span><br><span class="line">                                                             :<span class="built_in">len</span>(frames)]  <span class="comment"># remove extra padded frames</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict_video</span>(<span class="params">self, video_fn: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">import</span> ffmpeg</span><br><span class="line">        <span class="keyword">except</span> ModuleNotFoundError:</span><br><span class="line">            <span class="keyword">raise</span> ModuleNotFoundError(<span class="string">&quot;For `predict_video` function `ffmpeg` needs to be installed in order to extract &quot;</span></span><br><span class="line">                                      <span class="string">&quot;individual frames from video file. Install `ffmpeg` command line tool and then &quot;</span></span><br><span class="line">                                      <span class="string">&quot;install python wrapper by `pip install ffmpeg-python`.&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2] Extracting frames from &#123;&#125;&quot;</span>.<span class="built_in">format</span>(video_fn))</span><br><span class="line">        video_stream, err = <span class="literal">None</span>, <span class="literal">None</span>  <span class="comment"># Initialize</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            process = (</span><br><span class="line">                ffmpeg</span><br><span class="line">                .<span class="built_in">input</span>(video_fn)</span><br><span class="line">                .output(<span class="string">&quot;pipe:&quot;</span>, <span class="built_in">format</span>=<span class="string">&quot;rawvideo&quot;</span>, pix_fmt=<span class="string">&quot;rgb24&quot;</span>, s=<span class="string">&quot;48x27&quot;</span>)</span><br><span class="line">                .run_async(pipe_stdout=<span class="literal">True</span>, pipe_stderr=<span class="literal">True</span>)</span><br><span class="line">            )</span><br><span class="line">            video_stream, err = process.communicate()  <span class="comment"># Get output after process finishes</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] ffmpeg process failed for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> with exit code <span class="subst">&#123;process.returncode&#125;</span>.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> err:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] ffmpeg stderr:\n<span class="subst">&#123;err.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty arrays indicating failure</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> err:  <span class="comment"># Even if return code is 0, check stderr</span></span><br><span class="line">                <span class="comment"># Not all messages on stderr are errors, but log them as warnings</span></span><br><span class="line">                <span class="comment"># Filter out common non-error messages if necessary, or log all for debugging</span></span><br><span class="line">                decoded_err = err.decode(errors=<span class="string">&#x27;ignore&#x27;</span>).strip()</span><br><span class="line">                <span class="keyword">if</span> decoded_err:  <span class="comment"># Only print if there&#x27;s actual content</span></span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 WARNING] ffmpeg stderr for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> (exit code <span class="subst">&#123;process.returncode&#125;</span>):\n<span class="subst">&#123;decoded_err&#125;</span>&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> video_stream:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] ffmpeg produced no video stream for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>. Cannot proceed.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> ffmpeg.Error <span class="keyword">as</span> e_ffmpeg:  <span class="comment"># Catch ffmpeg&#x27;s own errors</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] ffmpeg.Error during frame extraction for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>:&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(e_ffmpeg, <span class="string">&#x27;stderr&#x27;</span>) <span class="keyword">and</span> e_ffmpeg.stderr:</span><br><span class="line">                <span class="built_in">print</span>(e_ffmpeg.stderr.decode(errors=<span class="string">&#x27;ignore&#x27;</span>), file=sys.stderr)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(e_ffmpeg), file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_generic_ffmpeg:  <span class="comment"># Catch other potential errors during ffmpeg processing</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Generic exception during ffmpeg processing for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>: <span class="subst">&#123;e_generic_ffmpeg&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> video_stream <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># Should have been caught above, but as a safeguard</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] video_stream is None after ffmpeg processing for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            video = np.frombuffer(video_stream, np.uint8).reshape([-<span class="number">1</span>, <span class="number">27</span>, <span class="number">48</span>, <span class="number">3</span>])</span><br><span class="line">        <span class="keyword">except</span> ValueError <span class="keyword">as</span> e_reshape:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Failed to reshape video_stream for <span class="subst">&#123;os.path.basename(video_fn)&#125;</span>. Stream length: <span class="subst">&#123;<span class="built_in">len</span>(video_stream)&#125;</span>. Error: <span class="subst">&#123;e_reshape&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> video.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 ERROR] Extracted 0 frames from <span class="subst">&#123;os.path.basename(video_fn)&#125;</span> after ffmpeg. Cannot proceed.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([]), np.array([]), np.array([])  <span class="comment"># Return empty</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (video, *<span class="variable language_">self</span>.predict_frames(video))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predictions_to_scenes</span>(<span class="params">predictions: np.ndarray, threshold: <span class="built_in">float</span> = <span class="number">0.5</span></span>):</span><br><span class="line">        <span class="keyword">if</span> predictions <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> predictions.size == <span class="number">0</span>:  <span class="comment"># Handle empty or None predictions</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 DEBUG] predictions_to_scenes received empty or None predictions. Returning empty scenes.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([], dtype=np.int32)  <span class="comment"># Return empty array of correct type</span></span><br><span class="line"></span><br><span class="line">        predictions = (predictions &gt; threshold).astype(np.uint8)</span><br><span class="line"></span><br><span class="line">        scenes = []</span><br><span class="line">        t, t_prev, start = -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, t_current_frame_pred <span class="keyword">in</span> <span class="built_in">enumerate</span>(predictions):  <span class="comment"># Renamed &#x27;t&#x27; to avoid conflict</span></span><br><span class="line">            <span class="keyword">if</span> t_prev == <span class="number">1</span> <span class="keyword">and</span> t_current_frame_pred == <span class="number">0</span>:</span><br><span class="line">                start = i</span><br><span class="line">            <span class="keyword">if</span> t_prev == <span class="number">0</span> <span class="keyword">and</span> t_current_frame_pred == <span class="number">1</span> <span class="keyword">and</span> i != <span class="number">0</span>:</span><br><span class="line">                scenes.append([start, i])</span><br><span class="line">            t_prev = t_current_frame_pred</span><br><span class="line"></span><br><span class="line">        <span class="comment"># After loop, check if the video ends in a shot (t_prev will be 0 if it ended with a transition, or 1 if it ended mid-shot)</span></span><br><span class="line">        <span class="comment"># The original logic for &#x27;if t == 0:&#x27; was based on the last prediction value.</span></span><br><span class="line">        <span class="comment"># If the last prediction was 0 (meaning it&#x27;s part of a shot that started earlier)</span></span><br><span class="line">        <span class="keyword">if</span> t_prev == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(predictions) &gt; <span class="number">0</span>:  <span class="comment"># Ensure there was at least one prediction</span></span><br><span class="line">            <span class="comment"># If start is not the beginning of the video and a shot has started</span></span><br><span class="line">            <span class="keyword">if</span> start &lt; <span class="built_in">len</span>(predictions):  <span class="comment"># Make sure start is a valid index</span></span><br><span class="line">                scenes.append([start, <span class="built_in">len</span>(predictions) - <span class="number">1</span>])  <span class="comment"># Shot goes to the end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># just fix if all predictions are 1 (no transitions found, so one scene from start to end)</span></span><br><span class="line">        <span class="comment"># or if all predictions are 0 (also one scene from start to end, after fixing start to 0)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scenes <span class="keyword">and</span> <span class="built_in">len</span>(predictions) &gt; <span class="number">0</span>:  <span class="comment"># If no scenes were appended and there are predictions</span></span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 DEBUG] No scenes detected by transition logic, assuming single scene for the entire video.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([[<span class="number">0</span>, <span class="built_in">len</span>(predictions) - <span class="number">1</span>]], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> scenes <span class="keyword">and</span> <span class="built_in">len</span>(predictions) == <span class="number">0</span>:  <span class="comment"># If no predictions at all</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 DEBUG] No predictions, returning empty scenes array.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> np.array([], dtype=np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.array(scenes, dtype=np.int32)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">visualize_predictions</span>(<span class="params">frames: np.ndarray, predictions</span>):</span><br><span class="line">        <span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> frames.size == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 WARNING] visualize_predictions received no frames. Skipping visualization.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Or a placeholder image</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(predictions, np.ndarray):</span><br><span class="line">            predictions = [predictions]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Filter out None or empty prediction arrays</span></span><br><span class="line">        valid_predictions = []</span><br><span class="line">        <span class="keyword">for</span> p_arr <span class="keyword">in</span> predictions:</span><br><span class="line">            <span class="keyword">if</span> p_arr <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> p_arr.size &gt; <span class="number">0</span>:</span><br><span class="line">                valid_predictions.append(p_arr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> valid_predictions:</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">&quot;[TransNetV2 WARNING] visualize_predictions received no valid prediction arrays. Skipping visualization.&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># Or a placeholder image</span></span><br><span class="line">        predictions = valid_predictions</span><br><span class="line"></span><br><span class="line">        ih, iw, ic = frames.shape[<span class="number">1</span>:]</span><br><span class="line">        width = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pad frames so that length of the video is divisible by width</span></span><br><span class="line">        <span class="comment"># pad frames also by len(predictions) pixels in width in order to show predictions</span></span><br><span class="line">        pad_with = width - <span class="built_in">len</span>(frames) % width <span class="keyword">if</span> <span class="built_in">len</span>(frames) % width != <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># Ensure pad_with is not negative if len(frames) is 0</span></span><br><span class="line">        pad_with = <span class="built_in">max</span>(<span class="number">0</span>, pad_with)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pad frames, ensuring frames is not empty</span></span><br><span class="line">        <span class="keyword">if</span> frames.size &gt; <span class="number">0</span>:</span><br><span class="line">            frames = np.pad(frames, [(<span class="number">0</span>, pad_with), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="built_in">len</span>(predictions)), (<span class="number">0</span>, <span class="number">0</span>)])</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># Should not happen if caught earlier, but as a safeguard</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        predictions = [np.pad(x, (<span class="number">0</span>, pad_with)) <span class="keyword">for</span> x <span class="keyword">in</span> predictions]</span><br><span class="line">        height = <span class="built_in">len</span>(frames) // width</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> height == <span class="number">0</span> <span class="keyword">or</span> width == <span class="number">0</span>:  <span class="comment"># Avoid division by zero or empty reshape</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 WARNING] Cannot create visualization due to zero height or width after padding.&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        img = frames.reshape([height, width, ih + <span class="number">1</span>, iw + <span class="built_in">len</span>(predictions), ic])</span><br><span class="line">        img = np.concatenate(np.split(</span><br><span class="line">            np.concatenate(np.split(img, height, axis=<span class="number">0</span>), axis=<span class="number">2</span>)[<span class="number">0</span>], width, axis=<span class="number">1</span>  <span class="comment"># Corrected axis for split</span></span><br><span class="line">        ), axis=<span class="number">2</span>)[<span class="number">0</span>, :-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        img = Image.fromarray(img)</span><br><span class="line">        draw = ImageDraw.Draw(img)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># iterate over all frames</span></span><br><span class="line">        <span class="keyword">for</span> i, pred_tuple <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(*predictions)):  <span class="comment"># pred_tuple contains predictions for frame i</span></span><br><span class="line">            x_base, y_base = i % width, i // width  <span class="comment"># Top-left corner of the frame in the grid</span></span><br><span class="line">            x_offset, y_offset = x_base * (iw + <span class="built_in">len</span>(predictions)) + iw, y_base * (</span><br><span class="line">                    ih + <span class="number">1</span>) + ih - <span class="number">1</span>  <span class="comment"># Bottom-right of frame content, before prediction lines</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># we can visualize multiple predictions per single frame</span></span><br><span class="line">            <span class="keyword">for</span> j, p_value <span class="keyword">in</span> <span class="built_in">enumerate</span>(pred_tuple):  <span class="comment"># j is prediction type index, p_value is its value</span></span><br><span class="line">                color = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">                <span class="comment"># Cycle through R, G, B for different prediction types</span></span><br><span class="line">                color[j % <span class="number">3</span>] = <span class="number">255</span>  <span class="comment"># Use j for color to distinguish prediction types</span></span><br><span class="line"></span><br><span class="line">                value_scaled = <span class="built_in">round</span>(p_value * (ih - <span class="number">1</span>))  <span class="comment"># Scale prediction to frame height</span></span><br><span class="line">                <span class="keyword">if</span> value_scaled != <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># Draw line upwards from the bottom edge of the frame visualization area</span></span><br><span class="line">                    draw.line((x_offset + j, y_offset, x_offset + j, y_offset - value_scaled), fill=<span class="built_in">tuple</span>(color),</span><br><span class="line">                              width=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">import</span> argparse  <span class="comment"># Already imported sys</span></span><br><span class="line"></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">&quot;files&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, nargs=<span class="string">&quot;+&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;path to video files to process&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--weights&quot;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="literal">None</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;path to TransNet V2 weights, tries to infer the location if not specified&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--visualize&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;save a png file with prediction visualization for each extracted video&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        model = TransNetV2(args.weights)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e_model_load:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 CRITICAL] Failed to load TransNetV2 model: <span class="subst">&#123;e_model_load&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">        sys.exit(<span class="number">1</span>)  <span class="comment"># Exit if model fails to load</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> args.files:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 INFO] Processing file: <span class="subst">&#123;file&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">        <span class="comment"># This pre-check is fine, but the calling script test_and_cut_video.py now also does pre-cleanup</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(file + <span class="string">&quot;.predictions.txt&quot;</span>) <span class="keyword">or</span> os.path.exists(file + <span class="string">&quot;.scenes.txt&quot;</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] <span class="subst">&#123;file&#125;</span>.predictions.txt or <span class="subst">&#123;file&#125;</span>.scenes.txt already exists. &quot;</span></span><br><span class="line">                  <span class="string">f&quot;Skipping video <span class="subst">&#123;file&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            video_frames, single_frame_predictions, all_frame_predictions = \</span><br><span class="line">                model.predict_video(file)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># --- Debugging: Check outputs of predict_video ---</span></span><br><span class="line">            <span class="keyword">if</span> video_frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> video_frames.size == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] predict_video returned no frames for <span class="subst">&#123;os.path.basename(file)&#125;</span>. Cannot save outputs.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file</span></span><br><span class="line">            <span class="keyword">if</span> single_frame_predictions <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> single_frame_predictions.size == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(</span><br><span class="line">                    <span class="string">f&quot;[TransNetV2 ERROR] predict_video returned no single_frame_predictions for <span class="subst">&#123;os.path.basename(file)&#125;</span>. Cannot save outputs.&quot;</span>,</span><br><span class="line">                    file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file</span></span><br><span class="line">            <span class="comment"># all_frame_predictions can sometimes be legitimately empty if single_frame_predictions is also empty.</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Returned from predict_video for <span class="subst">&#123;os.path.basename(file)&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   video_frames shape: <span class="subst">&#123;video_frames.shape&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   single_frame_predictions shape: <span class="subst">&#123;single_frame_predictions.shape&#125;</span>&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG]   all_frame_predictions shape: <span class="subst">&#123;all_frame_predictions.shape&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="comment"># --- End Debugging ---</span></span><br><span class="line"></span><br><span class="line">            predictions = np.stack([single_frame_predictions, all_frame_predictions], <span class="number">1</span>)</span><br><span class="line">            predictions_filepath = file + <span class="string">&quot;.predictions.txt&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                np.savetxt(predictions_filepath, predictions, fmt=<span class="string">&quot;%.6f&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempted to save predictions to <span class="subst">&#123;predictions_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(predictions_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 CRITICAL DEBUG] Saved predictions but file <span class="subst">&#123;predictions_filepath&#125;</span> does NOT exist!&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] File <span class="subst">&#123;predictions_filepath&#125;</span> successfully created.&quot;</span>, file=sys.stderr)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_pred_save:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception saving predictions file <span class="subst">&#123;predictions_filepath&#125;</span>: <span class="subst">&#123;e_pred_save&#125;</span>&quot;</span>,</span><br><span class="line">                      file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file if saving predictions fails</span></span><br><span class="line"></span><br><span class="line">            scenes = model.predictions_to_scenes(single_frame_predictions)</span><br><span class="line">            <span class="built_in">print</span>(</span><br><span class="line">                <span class="string">f&quot;[TransNetV2 DEBUG] Scenes array for <span class="subst">&#123;os.path.basename(file)&#125;</span> (shape: <span class="subst">&#123;scenes.shape <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="string">&#x27;None&#x27;</span>&#125;</span>):\n<span class="subst">&#123;scenes&#125;</span>&quot;</span>,</span><br><span class="line">                file=sys.stderr)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> scenes.size == <span class="number">0</span>:  <span class="comment"># Check if scenes array is empty</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 WARNING] Scenes array is empty or None for <span class="subst">&#123;os.path.basename(file)&#125;</span>. &quot;</span></span><br><span class="line">                      <span class="string">f&quot;No .scenes.txt will be saved, or it might be empty.&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="comment"># Depending on desired behavior, you might &#x27;continue&#x27; here or let np.savetxt handle an empty array.</span></span><br><span class="line">                <span class="comment"># np.savetxt with an empty array will create an empty file.</span></span><br><span class="line">                <span class="comment"># If an empty scenes file is problematic for the parent script, handle it here.</span></span><br><span class="line">                <span class="comment"># For now, let it try to save, which will result in an empty file if scenes is empty.</span></span><br><span class="line"></span><br><span class="line">            scenes_filepath = file + <span class="string">&quot;.scenes.txt&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                np.savetxt(scenes_filepath, scenes, fmt=<span class="string">&quot;%d&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempted to save scenes to <span class="subst">&#123;scenes_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                <span class="keyword">if</span> os.path.exists(scenes_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] File <span class="subst">&#123;scenes_filepath&#125;</span> successfully created.&quot;</span>, file=sys.stderr)</span><br><span class="line">                    <span class="comment"># Optionally, check file size or content for empty scenes</span></span><br><span class="line">                    <span class="keyword">if</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> scenes.size == <span class="number">0</span> <span class="keyword">and</span> os.path.getsize(scenes_filepath) == <span class="number">0</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] <span class="subst">&#123;scenes_filepath&#125;</span> is empty as expected for empty scenes array.&quot;</span>,</span><br><span class="line">                              file=sys.stderr)</span><br><span class="line">                    <span class="keyword">elif</span> scenes <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> scenes.size &gt; <span class="number">0</span> <span class="keyword">and</span> os.path.getsize(scenes_filepath) == <span class="number">0</span>:</span><br><span class="line">                        <span class="built_in">print</span>(</span><br><span class="line">                            <span class="string">f&quot;[TransNetV2 WARNING] <span class="subst">&#123;scenes_filepath&#125;</span> is unexpectedly empty despite non-empty scenes array.&quot;</span>,</span><br><span class="line">                            file=sys.stderr)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(</span><br><span class="line">                        <span class="string">f&quot;[TransNetV2 CRITICAL DEBUG] Saved scenes but file <span class="subst">&#123;scenes_filepath&#125;</span> does NOT exist afterwards!&quot;</span>,</span><br><span class="line">                        file=sys.stderr)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_save:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception during np.savetxt for .scenes.txt (<span class="subst">&#123;scenes_filepath&#125;</span>): <span class="subst">&#123;e_save&#125;</span>&quot;</span>,</span><br><span class="line">                      file=sys.stderr)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to next file if saving scenes fails</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> args.visualize:</span><br><span class="line">                vis_filepath = file + <span class="string">&quot;.vis.png&quot;</span></span><br><span class="line">                <span class="keyword">if</span> os.path.exists(vis_filepath):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2] <span class="subst">&#123;vis_filepath&#125;</span> already exists. &quot;</span></span><br><span class="line">                          <span class="string">f&quot;Skipping visualization of video <span class="subst">&#123;file&#125;</span>.&quot;</span>, file=sys.stderr)</span><br><span class="line">                    <span class="comment"># continue # This continue was inside the loop for &#x27;file in args.files&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Attempting to visualize predictions for <span class="subst">&#123;os.path.basename(file)&#125;</span>&quot;</span>,</span><br><span class="line">                          file=sys.stderr)</span><br><span class="line">                    pil_image = model.visualize_predictions(</span><br><span class="line">                        video_frames, predictions=(single_frame_predictions, all_frame_predictions))</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> pil_image:</span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            pil_image.save(vis_filepath)</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 DEBUG] Saved visualization to <span class="subst">&#123;vis_filepath&#125;</span>&quot;</span>, file=sys.stderr)</span><br><span class="line">                        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_vis_save:</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Exception saving visualization <span class="subst">&#123;vis_filepath&#125;</span>: <span class="subst">&#123;e_vis_save&#125;</span>&quot;</span>,</span><br><span class="line">                                  file=sys.stderr)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 WARNING] Visualization not generated for <span class="subst">&#123;os.path.basename(file)&#125;</span>.&quot;</span>,</span><br><span class="line">                              file=sys.stderr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e_video_processing:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;[TransNetV2 ERROR] Unhandled exception during processing of video <span class="subst">&#123;file&#125;</span>: <span class="subst">&#123;e_video_processing&#125;</span>&quot;</span>,</span><br><span class="line">                  file=sys.stderr)</span><br><span class="line">            <span class="comment"># Optionally, re-raise or sys.exit(1) if this should halt the script</span></span><br><span class="line">            <span class="comment"># For now, it will just print the error and attempt the next file.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[TransNetV2 INFO] Finished processing all files.&quot;</span>, file=sys.stderr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用推理脚本处理视频">调用推理脚本处理视频</h3><ul><li>benchmark</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/model-benchmark.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/model-benchmark.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>处理输入视频为单一场景 检测视频转场并分割</li></ul><blockquote><p>自动跳过切割后视频前后500ms 去除转场动画</p></blockquote> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Time:     2025/6/7 19:00  # 修改为实际时间</span></span><br><span class="line"><span class="string">Author:   ZhaoQi Cao(Clara)</span></span><br><span class="line"><span class="string">Version:  V 1.4 # 版本更新: 修正 parse_scenes_file 函数以正确解析场景文件格式</span></span><br><span class="line"><span class="string">File:     test_and_cut_video.py</span></span><br><span class="line"><span class="string">date:     2025/6/7 # 修改为实际日期</span></span><br><span class="line"><span class="string">Describe: Write during the python at Tianjin</span></span><br><span class="line"><span class="string">GitHub link: https://github.com/caozhaoqi</span></span><br><span class="line"><span class="string">Blog link: https://caozhaoqi.github.io</span></span><br><span class="line"><span class="string">WeChat Official Account: 码间拾遗（Code Snippets）</span></span><br><span class="line"><span class="string">Power by macOS on Mac mini m4(2024)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> cv2  <span class="comment"># For getting total frames</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path  <span class="comment"># 用于更方便地处理路径</span></span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm  <span class="comment"># 用于进度条</span></span><br><span class="line"><span class="keyword">import</span> shutil  <span class="comment"># 用于移动文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置日志 ---</span></span><br><span class="line">logging.basicConfig(level=logging.INFO,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s&#x27;</span>,</span><br><span class="line">                    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">logger = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持的视频文件扩展名</span></span><br><span class="line">SUPPORTED_VIDEO_EXTENSIONS = [<span class="string">&#x27;.mp4&#x27;</span>, <span class="string">&#x27;.avi&#x27;</span>, <span class="string">&#x27;.mov&#x27;</span>, <span class="string">&#x27;.mkv&#x27;</span>, <span class="string">&#x27;.flv&#x27;</span>, <span class="string">&#x27;.wmv&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_video_files</span>(<span class="params">input_dir, output_dir_to_skip=<span class="literal">None</span></span>):  <span class="comment"># 增加一个可选参数</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Recursively finds all video files in the given directory,</span></span><br><span class="line"><span class="string">    optionally skipping a specified output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    video_files = []</span><br><span class="line">    logger.info(<span class="string">f&quot;Searching for video files in: <span class="subst">&#123;input_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 规范化 output_dir_to_skip 以进行可靠的路径比较</span></span><br><span class="line">    normalized_output_skip_path = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> output_dir_to_skip:</span><br><span class="line">        normalized_output_skip_path = os.path.normpath(os.path.abspath(output_dir_to_skip))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(input_dir):</span><br><span class="line">        current_root_abs = os.path.normpath(os.path.abspath(root))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前遍历的目录是输出目录或其子目录，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> normalized_output_skip_path <span class="keyword">and</span> current_root_abs.startswith(normalized_output_skip_path):</span><br><span class="line">            logger.info(<span class="string">f&quot;Skipping scan of output directory: <span class="subst">&#123;root&#125;</span>&quot;</span>)</span><br><span class="line">            dirs[:] = []  <span class="comment"># 清空 dirs 列表，阻止 os.walk 进入此目录的子目录</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="comment"># 过滤掉 macOS 的 ._* 文件和其他以点开头的隐藏文件</span></span><br><span class="line">            <span class="keyword">if</span> file.startswith(<span class="string">&#x27;.&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">any</span>(file.lower().endswith(ext) <span class="keyword">for</span> ext <span class="keyword">in</span> SUPPORTED_VIDEO_EXTENSIONS):</span><br><span class="line">                video_files.append(os.path.join(root, file))</span><br><span class="line">    logger.info(<span class="string">f&quot;Found <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> video file(s).&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> video_files</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_transnet_inference</span>(<span class="params">video_path, transnet_script_path, model_dir, working_directory=<span class="string">&quot;.&quot;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Runs TransNetV2 inference to get shot boundaries.</span></span><br><span class="line"><span class="string">    Returns the path to the &#x27;.scenes.txt&#x27; file located in the working_directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Running TransNetV2 inference on: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">    video_filename = os.path.basename(video_path)  <span class="comment"># e.g., &quot;myvideo.mp4&quot;</span></span><br><span class="line">    base_name = os.path.splitext(video_filename)[<span class="number">0</span>]  <span class="comment"># e.g., &quot;myvideo&quot; (for target filename in working_dir)</span></span><br><span class="line">    original_video_dir = os.path.dirname(video_path)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- Pre-cleanup: 尝试删除原始视频目录中与该视频相关的旧输出文件 ---</span></span><br><span class="line">    <span class="comment"># This should target the names transnetv2.py actually creates</span></span><br><span class="line">    files_to_pre_cleanup = [</span><br><span class="line">        video_path + <span class="string">&quot;.scenes.txt&quot;</span>,</span><br><span class="line">        video_path + <span class="string">&quot;.predictions.txt&quot;</span>,</span><br><span class="line">        video_path + <span class="string">&quot;.vis.png&quot;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> old_file_path <span class="keyword">in</span> files_to_pre_cleanup:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(old_file_path):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.remove(old_file_path)</span><br><span class="line">                logger.info(<span class="string">f&quot;Pre-emptively removed old file: <span class="subst">&#123;old_file_path&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                logger.warning(<span class="string">f&quot;Could not pre-emptively remove old file <span class="subst">&#123;old_file_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># --- 预清理结束 ---</span></span><br><span class="line"></span><br><span class="line">    command = [</span><br><span class="line">        <span class="string">&quot;python&quot;</span>, transnet_script_path,</span><br><span class="line">        video_path,</span><br><span class="line">        <span class="string">&quot;--weights&quot;</span>, model_dir</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=working_directory)</span><br><span class="line">        stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">3600</span>)</span><br><span class="line"></span><br><span class="line">        process_stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">        process_stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">            logger.error(<span class="string">f&quot;TransNetV2 inference failed for <span class="subst">&#123;video_filename&#125;</span>:&quot;</span>)</span><br><span class="line">            logger.error(<span class="string">f&quot;STDOUT: <span class="subst">&#123;process_stdout&#125;</span>&quot;</span>)</span><br><span class="line">            logger.error(<span class="string">f&quot;STDERR: <span class="subst">&#123;process_stderr&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">f&quot;TransNetV2 inference successful for <span class="subst">&#123;video_filename&#125;</span> (exit code 0).&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process_stdout.strip():</span><br><span class="line">            logger.info(<span class="string">f&quot;TransNetV2 STDOUT for <span class="subst">&#123;video_filename&#125;</span>:\n<span class="subst">&#123;process_stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process_stderr.strip():</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;TransNetV2 STDERR for <span class="subst">&#123;video_filename&#125;</span> (though exit code was 0):\n<span class="subst">&#123;process_stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">        logger.error(<span class="string">f&quot;TransNetV2 inference timed out for <span class="subst">&#123;video_filename&#125;</span>.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> process:</span><br><span class="line">            process.kill()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">5</span>)</span><br><span class="line">                process_stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                process_stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> process_stdout.strip():</span><br><span class="line">                    logger.error(<span class="string">f&quot;STDOUT (on timeout): <span class="subst">&#123;process_stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> process_stderr.strip():</span><br><span class="line">                    logger.error(<span class="string">f&quot;STDERR (on timeout): <span class="subst">&#123;process_stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e_comm:</span><br><span class="line">                logger.error(<span class="string">f&quot;Error getting output after timeout kill: <span class="subst">&#123;e_comm&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Exception during TransNetV2 inference for <span class="subst">&#123;video_filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 文件查找和移动逻辑 ---</span></span><br><span class="line">    target_scenes_file_in_working_dir = os.path.join(working_directory, <span class="string">f&quot;<span class="subst">&#123;base_name&#125;</span>.scenes.txt&quot;</span>)</span><br><span class="line">    target_predictions_file_in_working_dir = os.path.join(working_directory, <span class="string">f&quot;<span class="subst">&#123;base_name&#125;</span>.predictions.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    expected_scenes_file_in_original_dir = video_path + <span class="string">&quot;.scenes.txt&quot;</span></span><br><span class="line">    expected_predictions_file_in_original_dir = video_path + <span class="string">&quot;.predictions.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    scenes_file_found_path = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(target_scenes_file_in_working_dir):</span><br><span class="line">        logger.info(<span class="string">f&quot;Found scenes file directly in working directory: <span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">        scenes_file_found_path = target_scenes_file_in_working_dir</span><br><span class="line">    <span class="keyword">elif</span> os.path.exists(expected_scenes_file_in_original_dir):</span><br><span class="line">        logger.info(<span class="string">f&quot;Found scenes file in original video directory: <span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            shutil.move(expected_scenes_file_in_original_dir, target_scenes_file_in_working_dir)</span><br><span class="line">            logger.info(<span class="string">f&quot;Moved scenes file to: <span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">            scenes_file_found_path = target_scenes_file_in_working_dir</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> os.path.exists(expected_predictions_file_in_original_dir):</span><br><span class="line">                shutil.move(expected_predictions_file_in_original_dir, target_predictions_file_in_working_dir)</span><br><span class="line">                logger.info(<span class="string">f&quot;Moved predictions file to: <span class="subst">&#123;target_predictions_file_in_working_dir&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(</span><br><span class="line">                <span class="string">f&quot;Failed to move scenes/predictions file from &#x27;<span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>&#x27; to &#x27;<span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>&#x27;: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Scenes file not found in working directory (<span class="subst">&#123;target_scenes_file_in_working_dir&#125;</span>) &quot;</span></span><br><span class="line">                     <span class="string">f&quot;nor in original video directory (<span class="subst">&#123;expected_scenes_file_in_original_dir&#125;</span>).&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scenes_file_found_path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_total_frames</span>(<span class="params">video_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Gets the total number of frames in a video.&quot;&quot;&quot;</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        <span class="comment"># Log OpenCV error if available (requires newer OpenCV versions for good messages)</span></span><br><span class="line">        <span class="comment"># For older versions, this might not give much info.</span></span><br><span class="line">        <span class="comment"># cv_error = cv2.getErrorMsg() if hasattr(cv2, &#x27;getErrorMsg&#x27;) else &quot;OpenCV error&quot;</span></span><br><span class="line">        <span class="comment"># logger.error(f&quot;Could not open video: &#123;video_path&#125;. OpenCV: &#123;cv_error&#125;&quot;)</span></span><br><span class="line">        logger.error(<span class="string">f&quot;Could not open video: <span class="subst">&#123;video_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    total_frames = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    cap.release()</span><br><span class="line">    <span class="keyword">return</span> total_frames</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_scenes_file</span>(<span class="params">scenes_file_path, total_frames</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Parses the .scenes.txt file which contains start and end frames for each shot,</span></span><br><span class="line"><span class="string">    one shot per line, space-separated.</span></span><br><span class="line"><span class="string">    Returns a list of (start_frame, end_frame) tuples for each shot.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(scenes_file_path):</span><br><span class="line">        logger.error(<span class="string">f&quot;Scenes file not found for parsing: <span class="subst">&#123;scenes_file_path&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    shots = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(scenes_file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line_number, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f, <span class="number">1</span>):</span><br><span class="line">                stripped_line = line.strip()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stripped_line:  <span class="comment"># Skip empty lines</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                parts = stripped_line.split()</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(parts) == <span class="number">2</span> <span class="keyword">and</span> parts[<span class="number">0</span>].isdigit() <span class="keyword">and</span> parts[<span class="number">1</span>].isdigit():</span><br><span class="line">                    start_frame = <span class="built_in">int</span>(parts[<span class="number">0</span>])</span><br><span class="line">                    end_frame = <span class="built_in">int</span>(parts[<span class="number">1</span>])  <span class="comment"># This is the end frame of the shot (inclusive)</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># Validate frames against total_frames</span></span><br><span class="line">                    <span class="keyword">if</span> start_frame &lt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid start_frame <span class="subst">&#123;start_frame&#125;</span> &lt; 0 in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Clamping to 0.&quot;</span>)</span><br><span class="line">                        start_frame = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># end_frame from TransNetV2 is inclusive and 0-indexed.</span></span><br><span class="line">                    <span class="comment"># If total_frames is N, valid frames are 0 to N-1.</span></span><br><span class="line">                    <span class="keyword">if</span> end_frame &gt;= total_frames <span class="keyword">and</span> total_frames &gt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;End_frame <span class="subst">&#123;end_frame&#125;</span> from scenes file is &gt;= total_frames <span class="subst">&#123;total_frames&#125;</span> in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Clamping to <span class="subst">&#123;total_frames - <span class="number">1</span>&#125;</span>.&quot;</span>)</span><br><span class="line">                        end_frame = total_frames - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total_frames == <span class="number">0</span> <span class="keyword">and</span> end_frame &gt; <span class="number">0</span>:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid end_frame <span class="subst">&#123;end_frame&#125;</span> for video with 0 total_frames in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Skipping shot.&quot;</span>)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> total_frames == <span class="number">0</span> <span class="keyword">and</span> end_frame == <span class="number">0</span> <span class="keyword">and</span> start_frame == <span class="number">0</span>:  <span class="comment"># Special case for 0-frame video if it somehow yields a (0,0) shot</span></span><br><span class="line">                        <span class="keyword">pass</span>  <span class="comment"># Allow (0,0) for a 0-frame video if that&#x27;s a possible output</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> start_frame &gt; end_frame:</span><br><span class="line">                        logger.warning(</span><br><span class="line">                            <span class="string">f&quot;Invalid shot (start_frame <span class="subst">&#123;start_frame&#125;</span> &gt; end_frame <span class="subst">&#123;end_frame&#125;</span>) in <span class="subst">&#123;scenes_file_path&#125;</span> line <span class="subst">&#123;line_number&#125;</span>. Skipping shot.&quot;</span>)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                    shots.append((start_frame, end_frame))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># This warning will catch lines that are not two integers.</span></span><br><span class="line">                    logger.warning(</span><br><span class="line">                        <span class="string">f&quot;Malformed line in scenes file &#x27;<span class="subst">&#123;scenes_file_path&#125;</span>&#x27; line <span class="subst">&#123;line_number&#125;</span>: &#x27;<span class="subst">&#123;stripped_line&#125;</span>&#x27;. Expected two integers separated by space.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;Error reading or parsing scenes file <span class="subst">&#123;scenes_file_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> shots:</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;No valid shots derived from scenes file: <span class="subst">&#123;scenes_file_path&#125;</span>. Assuming single shot for the entire video.&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> total_frames &gt; <span class="number">0</span>:</span><br><span class="line">            shots.append((<span class="number">0</span>, total_frames - <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># If total_frames is 0, shots will remain empty, which is correct.</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Sort shots by start frame, just in case they are not ordered in the file</span></span><br><span class="line">        shots.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        logger.info(</span><br><span class="line">            <span class="string">f&quot;Detected <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for <span class="subst">&#123;os.path.basename(scenes_file_path)&#125;</span> (start_frame, end_frame_inclusive): <span class="subst">&#123;shots&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cut_video_into_shots</span>(<span class="params">video_path, shots, video_output_dir, padding_ms=<span class="number">500</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Cuts the video into shots using ffmpeg based on frame numbers.</span></span><br><span class="line"><span class="string">    The start and end of each shot are REDUCED by padding_ms.</span></span><br><span class="line"><span class="string">    (Note: The &#x27;padding_ms&#x27; parameter is used here as a reduction amount).</span></span><br><span class="line"><span class="string">    Saves shots into the video_specific output directory.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    video_basename = Path(video_path).stem</span><br><span class="line">    logger.info(<span class="string">f&quot;Starting to cut <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for video: <span class="subst">&#123;video_basename&#125;</span>, REDUCING each end by <span class="subst">&#123;padding_ms&#125;</span>ms.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Get video properties (FPS and total frames) once</span></span><br><span class="line">    cap = cv2.VideoCapture(video_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">        logger.error(<span class="string">f&quot;Could not open video <span class="subst">&#123;video_path&#125;</span> for properties. Skipping cutting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fps = cap.get(cv2.CAP_PROP_FPS)</span><br><span class="line">    video_total_frames = <span class="built_in">int</span>(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><br><span class="line">    cap.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> fps &gt; <span class="number">0</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Could not determine FPS for <span class="subst">&#123;video_path&#125;</span>. Skipping reduction cut.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> video_total_frames == <span class="number">0</span>:</span><br><span class="line">        logger.error(<span class="string">f&quot;Video <span class="subst">&#123;video_path&#125;</span> has 0 frames. Skipping cutting.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Convert the reduction amount from milliseconds to frames</span></span><br><span class="line">    reduction_frames = <span class="built_in">round</span>(padding_ms / <span class="number">1000</span> * fps)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, (start_frame, end_frame) <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm(shots, desc=<span class="string">f&quot;Cutting shots for <span class="subst">&#123;video_basename&#125;</span>&quot;</span>, unit=<span class="string">&quot;shot&quot;</span>)):</span><br><span class="line">        start_frame = <span class="built_in">int</span>(start_frame)</span><br><span class="line">        end_frame = <span class="built_in">int</span>(end_frame)  <span class="comment"># Inclusive end frame from parse_scenes_file</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Calculate new target start and end frames after reduction</span></span><br><span class="line">        target_start_frame = start_frame + reduction_frames</span><br><span class="line">        target_end_frame = end_frame - reduction_frames  <span class="comment"># This will also be an inclusive frame index</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Check if the shot is too short for the reduction, making it invalid</span></span><br><span class="line">        <span class="keyword">if</span> target_end_frame &lt; target_start_frame:</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;Shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (original: <span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>) is too short to apply <span class="subst">&#123;padding_ms&#125;</span>ms reduction &quot;</span></span><br><span class="line">                <span class="string">f&quot;from both ends (would result in invalid segment: <span class="subst">&#123;target_start_frame&#125;</span>-<span class="subst">&#123;target_end_frame&#125;</span>). &quot;</span></span><br><span class="line">                <span class="string">f&quot;Original duration: <span class="subst">&#123;(end_frame - start_frame + <span class="number">1</span>) / fps:<span class="number">.2</span>f&#125;</span>s. Skipping this shot.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Clamp the target frames to the video&#x27;s actual boundaries</span></span><br><span class="line">        <span class="comment"># (0 to video_total_frames - 1)</span></span><br><span class="line">        final_start_frame = <span class="built_in">max</span>(<span class="number">0</span>, target_start_frame)</span><br><span class="line">        final_start_frame = <span class="built_in">min</span>(final_start_frame, video_total_frames - <span class="number">1</span>)  <span class="comment"># Ensure start isn&#x27;t past video end</span></span><br><span class="line"></span><br><span class="line">        final_end_frame = <span class="built_in">min</span>(video_total_frames - <span class="number">1</span>, target_end_frame)</span><br><span class="line">        final_end_frame = <span class="built_in">max</span>(<span class="number">0</span>, final_end_frame)  <span class="comment"># Ensure end isn&#x27;t before video start</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Re-check validity after clamping.</span></span><br><span class="line">        <span class="comment"># This handles cases where clamping itself might make the segment invalid.</span></span><br><span class="line">        <span class="keyword">if</span> final_end_frame &lt; final_start_frame:</span><br><span class="line">            logger.warning(</span><br><span class="line">                <span class="string">f&quot;Shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (original: <span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>) became invalid after reduction and clamping to video boundaries: &quot;</span></span><br><span class="line">                <span class="string">f&quot;intended reduced (<span class="subst">&#123;target_start_frame&#125;</span>-<span class="subst">&#123;target_end_frame&#125;</span>), &quot;</span></span><br><span class="line">                <span class="string">f&quot;clamped to (<span class="subst">&#123;final_start_frame&#125;</span>-<span class="subst">&#123;final_end_frame&#125;</span>). Skipping this shot.&quot;</span></span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        output_shot_filename = <span class="string">f&quot;<span class="subst">&#123;video_basename&#125;</span>_shot_<span class="subst">&#123;i + <span class="number">1</span>:03d&#125;</span>.mp4&quot;</span></span><br><span class="line">        output_shot_path = os.path.join(video_output_dir, output_shot_filename)</span><br><span class="line"></span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">f&quot;Preparing to cut shot <span class="subst">&#123;i + <span class="number">1</span>&#125;</span>: original (<span class="subst">&#123;start_frame&#125;</span>-<span class="subst">&#123;end_frame&#125;</span>), &quot;</span></span><br><span class="line">            <span class="string">f&quot;target reduced frames (<span class="subst">&#123;final_start_frame&#125;</span>-<span class="subst">&#123;final_end_frame&#125;</span>) -&gt; <span class="subst">&#123;output_shot_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        ffmpeg_command = [</span><br><span class="line">            <span class="string">&quot;ffmpeg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-loglevel&quot;</span>, <span class="string">&quot;error&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-i&quot;</span>, video_path,</span><br><span class="line">            <span class="string">&quot;-vf&quot;</span>, <span class="string">f&quot;select=&#x27;between(n,<span class="subst">&#123;final_start_frame&#125;</span>,<span class="subst">&#123;final_end_frame&#125;</span>)&#x27;,setpts=PTS-STARTPTS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-af&quot;</span>, <span class="string">f&quot;aselect=&#x27;between(n,<span class="subst">&#123;final_start_frame&#125;</span>,<span class="subst">&#123;final_end_frame&#125;</span>)&#x27;,asetpts=PTS-STARTPTS&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-c:v&quot;</span>, <span class="string">&quot;libx264&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-preset&quot;</span>, <span class="string">&quot;ultrafast&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-crf&quot;</span>, <span class="string">&quot;23&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-c:a&quot;</span>, <span class="string">&quot;aac&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-y&quot;</span>,  <span class="comment"># Overwrite output files without asking</span></span><br><span class="line">            output_shot_path</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            process = subprocess.Popen(ffmpeg_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">            stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">            stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">            stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> process.returncode != <span class="number">0</span>:</span><br><span class="line">                logger.error(<span class="string">f&quot;ffmpeg failed for shot <span class="subst">&#123;output_shot_filename&#125;</span>:&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> stderr.strip(): logger.error(<span class="string">f&quot;FFMPEG STDERR: <span class="subst">&#123;stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> stdout.strip(): logger.error(<span class="string">f&quot;FFMPEG STDOUT: <span class="subst">&#123;stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.info(<span class="string">f&quot;Successfully created <span class="subst">&#123;output_shot_filename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">            logger.error(<span class="string">f&quot;ffmpeg timed out for shot <span class="subst">&#123;output_shot_filename&#125;</span>.&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> process:</span><br><span class="line">                process.kill()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    stdout_bytes, stderr_bytes = process.communicate(timeout=<span class="number">5</span>)</span><br><span class="line">                    stdout = stdout_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                    stderr = stderr_bytes.decode(errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">                    <span class="keyword">if</span> stderr.strip(): logger.error(<span class="string">f&quot;FFMPEG STDERR (on timeout kill): <span class="subst">&#123;stderr.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">if</span> stdout.strip(): logger.error(<span class="string">f&quot;FFMPEG STDOUT (on timeout kill): <span class="subst">&#123;stdout.strip()&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e_comm_kill:</span><br><span class="line">                    logger.error(<span class="string">f&quot;Error getting output after ffmpeg timeout kill: <span class="subst">&#123;e_comm_kill&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;Exception during ffmpeg processing for shot <span class="subst">&#123;output_shot_filename&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Finished cutting <span class="subst">&#123;<span class="built_in">len</span>(shots)&#125;</span> shots for video: <span class="subst">&#123;video_basename&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&quot;Process videos using TransNetV2 to detect shot boundaries and cut the videos into shots.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;input_source&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;Path to a directory containing video files to process.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--transnet_script&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;inference/transnetv2.py&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the transnetv2.py script.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--model_dir&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;inference/transnetv2-weights&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the TransNetV2 model directory.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--output_dir&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;./r&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Base directory to output processed videos.  A subdirectory will be created for each video.&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--log_file&quot;</span>, required=<span class="literal">False</span>, default=<span class="string">&quot;my_processing_log.txt&quot;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;Path to the log file.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 日志文件设置 ---</span></span><br><span class="line">    log_file_path = args.log_file</span><br><span class="line">    log_dir = os.path.dirname(log_file_path)  <span class="comment"># 获取日志文件所在目录</span></span><br><span class="line">    <span class="keyword">if</span> log_dir <span class="keyword">and</span> <span class="keyword">not</span> os.path.exists(log_dir):</span><br><span class="line">        os.makedirs(log_dir)  <span class="comment"># 如果日志目录不存在，则创建它</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个file handler，将日志写入文件</span></span><br><span class="line">    file_handler = logging.FileHandler(log_file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    file_handler.setLevel(logging.INFO)  <span class="comment"># 设置日志级别为INFO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个formatter并将其添加到handler</span></span><br><span class="line">    formatter = logging.Formatter(<span class="string">&#x27;%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s&#x27;</span>,</span><br><span class="line">                                  datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line">    file_handler.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将handler添加到logger</span></span><br><span class="line">    logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;Script started.&quot;</span>)</span><br><span class="line">    logger.info(<span class="string">f&quot;Arguments: <span class="subst">&#123;args&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    input_source = args.input_source</span><br><span class="line">    transnet_script = args.transnet_script</span><br><span class="line">    model_dir = args.model_dir</span><br><span class="line">    output_dir = args.output_dir</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确保输出目录存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_dir):</span><br><span class="line">        os.makedirs(output_dir)</span><br><span class="line">        logger.info(<span class="string">f&quot;Created base output directory: <span class="subst">&#123;output_dir&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;Base output directory already exists: <span class="subst">&#123;output_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    video_files = find_video_files(input_source, output_dir_to_skip=output_dir)  <span class="comment"># 排除 output_dir</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> video_files:</span><br><span class="line">        logger.warning(<span class="string">&quot;No video files found to process.&quot;</span>)</span><br><span class="line">        logger.info(<span class="string">&quot;All processing complete.&quot;</span>)</span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">f&quot;Processing <span class="subst">&#123;<span class="built_in">len</span>(video_files)&#125;</span> video(s)...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> video_path <span class="keyword">in</span> video_files:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># --- 视频特定处理开始 ---</span></span><br><span class="line">            video_basename = Path(video_path).stem</span><br><span class="line">            logger.info(<span class="string">f&quot;--- Starting processing for video: <span class="subst">&#123;video_path&#125;</span> ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 为当前视频创建处理目录和输出目录</span></span><br><span class="line">            video_output_dir = os.path.join(output_dir, video_basename)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(video_output_dir):</span><br><span class="line">                os.makedirs(video_output_dir)</span><br><span class="line">                logger.info(<span class="string">f&quot;Created processing/output directory for this video: <span class="subst">&#123;video_output_dir&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger.info(<span class="string">f&quot;Processing/output directory already exists: <span class="subst">&#123;video_output_dir&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            total_frames = get_total_frames(video_path)</span><br><span class="line">            <span class="keyword">if</span> total_frames <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> total_frames == <span class="number">0</span>:</span><br><span class="line">                logger.error(</span><br><span class="line">                    <span class="string">f&quot;Cannot process video <span class="subst">&#123;video_path&#125;</span> as it has no frames or could not be read. Skipping.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to the next video</span></span><br><span class="line">            logger.info(<span class="string">f&quot;Total frames in <span class="subst">&#123;os.path.basename(video_path)&#125;</span>: <span class="subst">&#123;total_frames&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 运行 TransNetV2 推理</span></span><br><span class="line">            scenes_file = run_transnet_inference(video_path, transnet_script, model_dir,</span><br><span class="line">                                                 working_directory=video_output_dir)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> scenes_file <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                logger.error(<span class="string">f&quot;Failed to get scenes file for <span class="subst">&#123;video_path&#125;</span>. Skipping this video.&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># Skip to the next video</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 解析场景文件</span></span><br><span class="line">            shots = parse_scenes_file(scenes_file, total_frames)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将视频剪切成镜头</span></span><br><span class="line">            cut_video_into_shots(video_path, shots, video_output_dir, padding_ms=<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;An unexpected error occurred while processing <span class="subst">&#123;video_path&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">&quot;All processing complete.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>检测输出结果</li></ul><p><img src="/2025/06/09/TransNetV2-model-use/test-result.png" class="lazyload placeholder" data-srcset="/2025/06/09/TransNetV2-model-use/test-result.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h2 id="See">See</h2><ul><li>1.<a href="https://arxiv.org/pdf/2008.04838">https://arxiv.org/pdf/2008.04838</a></li><li>2.<a href="https://github.com/soCzech/TransNetV2/tree/master">https://github.com/soCzech/TransNetV2/tree/master</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TransNet-V2-模型介绍&quot;&gt;TransNet V2 模型介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;目标：&lt;br&gt;
TransNet V2 的目标是创建一个快速且准确的镜头边界检测（Shot Boundary Detection, SBD）模型。它能够识别视频中的两</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>场景检测性能优化方向与测试方法</title>
    <link href="https://caozhaoqi.github.io/2025/05/30/scene-detect-benchmark/"/>
    <id>https://caozhaoqi.github.io/2025/05/30/scene-detect-benchmark/</id>
    <published>2025-05-30T08:44:00.000Z</published>
    <updated>2025-11-25T15:05:10.347Z</updated>
    
    <content type="html"><![CDATA[<h1>场景检测性能优化方向与测试方法</h1><h2 id="1-引言">1. 引言</h2><p>本指南旨在提供一套系统化的方法，用于验证和分析视频处理项目的效率，特别是针对场景检测模块的性能。通过收集关键性能指标 (KPIs)<br>和剖析代码执行，我们可以识别性能瓶颈，并为后续的代码优化提供数据支持。</p><h2 id="2-准备工作">2. 准备工作</h2><h3 id="2-1-定义关键性能指标-KPIs">2.1. 定义关键性能指标 (KPIs)</h3><p>在开始测试前，明确需要衡量的性能指标：</p><ul><li>总处理时间 (End-to-End Time)*衡量单个视频从场景检测开始到结束的总耗时。</li><li>场景检测函数耗时<code>detect_scenes</code> 函数的精确执行时间。</li><li>CPU 使用率场景检测过程中的平均和峰值 CPU 使用率。</li><li>内存使用量 场景检测过程中的峰值和平均内存消耗。</li><li>GPU 使用率 (若启用)：GPU 计算单元和显存的使用率。</li><li>检测到的场景数作为检测结果的一个基本衡量。</li><li>检测时使用的帧率记录 <code>detect_scenes</code> 内部实际使用的视频帧率。</li></ul><h3 id="2-2-选择测试数据集">2.2. 选择测试数据集</h3><ul><li>多样性 准备一组包含不同特征的视频文件：<ul><li>不同分辨率 (例如：720p, 1080p, 4K)。</li><li>不同编码格式 (例如：H.264, HEVC)。</li><li>不同时长 (例如：短视频 &lt; 1分钟，中等视频 5-10分钟，长视频 &gt; 30分钟)。</li><li>不同场景复杂度 (例如：场景切换频繁的预告片，场景切换较少的讲座视频)。</li></ul></li><li>代表性 测试视频应能代表项目实际应用中常见的视频类型。</li><li>可重复性 使用固定的视频集进行所有测试，以便比较不同优化版本的效果。</li></ul><h3 id="2-3-搭建测试环境">2.3. 搭建测试环境</h3><ul><li>硬件一致性 所有基准测试应在同一台机器上进行，以消除硬件差异。记录测试机器的 CPU、内存、GPU型号、磁盘类型等规格。</li><li>软件环境一致性 确保 Python 版本、操作系统以及所有相关依赖库 (如 PySceneDetect, OpenCV, FFmpeg) 的版本在测试期间保持不变。可以从<br><code>requirements.txt</code> 文件中获取依赖列表。</li><li>环境隔离 测试时，尽量关闭其他不必要的应用程序，以减少对测试结果的干扰。</li></ul><h3 id="2-4-配置测试参数">2.4. 配置测试参数</h3><ul><li><code>config.ini</code> 基准测试脚本会加载此文件。确保其中的路径配置 (如 <code>ffmpeg_path</code>, <code>ffprobe_path</code>) 和默认的检测器参数是你想要测试的基础配置。</li><li>测试脚本内配置 <code>benchmark_scene_detector.py</code> 脚本允许定义多种测试配置 ( <code>configurations_to_test</code> 列表)，例如：<ul><li>CPU vs GPU 解码。</li><li>使用不同的检测器组合 (例如，仅 <code>ContentDetector</code> vs <code>MultiDetector</code> 全启用)。</li><li>不同的检测器参数 (例如，不同的 <code>threshold</code> 或 <code>min_scene_len_frames</code>)。</li></ul></li></ul><h2 id="3-测试执行">3. 测试执行</h2><h3 id="3-1-测试脚本：benchmark-scene-detector-py">3.1. 测试脚本：<code>benchmark_scene_detector.py</code></h3><ul><li>基础库安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install memory-profiler psutil snakeviz # snakeviz 用于可视化 cProfile 结果</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li>基准测试脚本运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python src/video/benchmark_scene_detector.py</span><br></pre></td></tr></table></figure><ul><li>性能分析</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pstats profiling_results/profile_your_test_video1_Config_Default_CPU.prof</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snakeviz profiling_results/profile_your_test_video1_Config_Default_CPU.prof</span><br></pre></td></tr></table></figure><h3 id="3-2-性能剖析-Profiling">3.2. 性能剖析 (Profiling)</h3><ul><li>当测试配置中 <code>&quot;profile&quot;: True</code> 时，脚本会为该次运行生成一个 <code>.prof</code> 文件，保存在 <code>profiling_results</code> 目录下。</li><li>这些文件包含了函数调用次数、每次调用的耗时、累计耗时等详细信息。</li></ul><h3 id="3-3-资源监控">3.3. 资源监控</h3><ul><li>手动监控 在测试脚本运行时，使用操作系统自带的工具（如 Windows 的任务管理器，Linux 的 <code>top</code>/<code>htop</code>，macOS 的活动监视器）观察<br>CPU 和内存的实时使用情况。</li><li>GPU 监控 如果测试 GPU 加速，使用特定于 GPU 厂商的工具（如 NVIDIA 的 <code>nvidia-smi</code>）监控 GPU 利用率和显存使用。</li><li>脚本内监控 (可选) 可以修改 <code>benchmark_scene_detector.py</code>，使用 <code>psutil</code> 库在调用 <code>detect_scenes</code> 前后记录进程的 CPU<br>和内存快照，以获得更精确的数据。</li></ul><h3 id="3-4-比较耗时：">3.4 比较耗时：</h3><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从示例输出来看，对于“建筑家园-02.mp4”，使用 GPU (<br>Config_Default_GPU) 将处理时间从约 15.1 秒降低到了约 8.6 秒，有显著提升。</li><li>对比不同检测器组合或参数下的耗时。例如，Config_ContentDetectorOnly_CPU (仅使用 ContentDetector) 的耗时约为 5.4 秒，远快于使用<br>MultiDetector 的 Config_Default_CPU (15.1 秒)，但检测到的场景数也从 12 个减少到了 9 个。这需要在速度和检测全面性之间进行权衡。</li><li>观察不同特性视频（如时长、分辨率）对处理时间的影响（需要更多测试视频样本来分析此项）。4.2. 分析性能剖析 (.prof) 文件使用<br>Python 的 pstats 模块或 snakeviz 工具来分析 .prof 文件。使用 pstats (命令行)：</li></ul><h2 id="4-结果分析">4. 结果分析</h2><h3 id="4-1-分析基准测试日志">4.1. 分析基准测试日志</h3><blockquote><p>脚本执行完毕后，会打印一个总结报告，显示每个视频在不同配置下的处理时长和检测到的场景数。</p></blockquote><h4 id="在-pstats-交互式-shell-中，常用命令：">在 pstats 交互式 shell 中，常用命令：</h4><ul><li>sort cumulative: 按累计耗时排序。</li><li>stats 20: 显示耗时最多的前 20 个函数。</li><li>callers function_name: 查看哪些函数调用了 function_name。</li><li>callees function_name: 查看 function_name 调用了哪些函数。</li></ul><h4 id="使用-snakeviz-Web-界面，推荐-：">使用 snakeviz (Web 界面，推荐)：</h4><ul><li><p>比较耗时</p><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从示例输出来看，对于“建筑家园-02.mp4”，使用 GPU (<br><code>Config_Default_GPU</code>) 将处理时间从约 15.1 秒降低到了约 8.6 秒，有显著提升。</li><li>对比不同检测器组合或参数下的耗时。例如，<code>Config_ContentDetectorOnly_CPU</code> (仅使用 ContentDetector) 的耗时约为 5.4<br>秒，远快于使用 <code>MultiDetector</code> 的 <code>Config_Default_CPU</code> (15.1 秒)，但检测到的场景数也从 12 个减少到了 9<br>个。这需要在速度和检测全面性之间进行权衡。</li><li>观察不同特性视频（如时长、分辨率）对处理时间的影响（需要更多测试视频样本来分析此项）。</li></ul></li><li><p>比较耗时 (Updated Interpretation based on new logs)</p><ul><li>对比 CPU 和 GPU 配置下的耗时，评估 GPU 加速的实际效果。从最新的示例输出来看，对于“建筑家园-02.mp4” (一个60fps的视频):<ul><li><code>Config_Default_CPU</code> (MultiDetector, CPU decode): 433.73 秒</li><li><code>Config_Default_GPU</code> (MultiDetector, GPU decode requested): 411.56 秒</li><li>观察: 在这个特定的测试中 (macOS, <code>VideoStreamCv2</code> 被用作回退)，请求 GPU 解码相比纯 CPU 解码略有性能提升 (约<br>22 秒，或 5% 的提升)。这表明在 macOS 上，即使 PySceneDetect 回退到 <code>VideoStreamCv2</code>，底层的 OpenCV 和<br>AVFoundation/VideoToolbox 可能仍然利用了一些硬件加速。然而，这与之前日志中在非 macOS 环境下使用<br><code>VideoStreamCv2Cuda</code> 可能带来的更显著提升有所不同。文档中应指出，GPU 加速的效果高度依赖于操作系统、OpenCV<br>的编译选项、PySceneDetect 的后端选择以及具体的 GPU 硬件。</li></ul></li><li>对比不同检测器组合或参数下的耗时。例如:<ul><li><code>Config_ContentDetectorOnly_CPU</code> (仅使用 ContentDetector, CPU decode): 400.30 秒</li><li>观察: 仅使用 <code>ContentDetector</code> 仍然是最快的配置，比使用 <code>MultiDetector</code> 的 CPU 配置快了约 33 秒。但检测到的场景数从<br>214 个减少到了 164 个。这再次强调了在速度和检测全面性/准确性之间的权衡。</li></ul></li><li>重要提示:<ul><li>日志中出现 <code>Backend None not available. Trying another backend: opencv</code>，并且在请求 GPU 解码时，最终仍然是<br><code>opened with VideoStreamCv2</code>。这表明在当前的 macOS 测试环境下，<code>VideoStreamCv2Cuda</code> (如果期望使用的话)<br>并未被成功加载或使用，PySceneDetect 回退到了标准的 OpenCV 后端 (<code>VideoStreamCv2</code>)。文档应该提及这一点，并建议用户检查其<br>PySceneDetect 和 OpenCV (包括 CUDA 支持) 的安装，尤其是在非 macOS 环境下期望使用 NVIDIA GPU 加速时。</li><li>日志中出现 <code>min_delta_hsv is deprecated, use min_content_val instead.</code> 这是来自 <code>AdaptiveDetector</code><br>的一个警告。虽然不影响基准测试的耗时记录，但在文档中或代码注释中提及，并建议更新 <code>config.ini</code> 或<br><code>AdaptiveDetector</code> 的参数以使用新的 <code>min_content_val</code> 是一个好做法，以保持与库更新的兼容性。</li></ul></li></ul></li></ul><p>macOS性能测试结果解释:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">/Users/zg/PycharmProjects/scene_detect_split/.venv/bin/python /Users/zg/PycharmProjects/scene_detect_split/src/tests/benchmark_scene_detector.py </span><br><span class="line">2025-05-30 10:46:40.555 | INFO     | config.config:initialize_settings:147 - Configuration successfully loaded from: /Users/zg/PycharmProjects/scene_detect_split/src/run/config.ini</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:118 - Configuration loaded from: /Users/zg/PycharmProjects/scene_detect_split/src/run/config.ini</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:210 - </span><br><span class="line">===== Processing Video: /Volumes/shared/样例/CG渲染样例/建筑家园/建筑家园-02.mp4 =====</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_CPU ---</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: MultiDetector</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 10:46:40.556 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 10:46:40.720 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 10:46:40.720 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: MultiDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:46:40.721 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">min_delta_hsv is deprecated, use min_content_val instead.</span><br><span class="line">2025-05-30 10:53:54.141 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 214 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:53:54.143 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 214 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 10:53:54.296 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results/profile_建筑家园_02_Config_Default_CPU.prof</span><br><span class="line">2025-05-30 10:53:54.297 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 10:53:54.297 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 214</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 433.7327 seconds</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_GPU ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: MultiDetector</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: True</span><br><span class="line">2025-05-30 10:53:54.298 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">2025-05-30 10:53:54.299 | INFO     | video.scene_detector:detect_scenes:95 - [MainThread] GPU decode (AVFoundation/VideoToolbox likely) on macOS for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: MultiDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 10:53:54.381 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">min_delta_hsv is deprecated, use min_content_val instead.</span><br><span class="line">2025-05-30 11:00:45.457 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 214 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:00:45.458 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 214 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results/profile_建筑家园_02_Config_Default_GPU.prof</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 214</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 411.5587 seconds</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_ContentDetectorOnly_CPU ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 11:00:45.865 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:00:45.939 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:07:26.007 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 164 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 11:07:26.011 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 164 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 164</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 400.2969 seconds</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:236 - </span><br><span class="line"></span><br><span class="line">===== Benchmark Summary =====</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:238 - </span><br><span class="line">Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_CPU             | Duration: 433.7327s | Scenes: 214</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_GPU             | Duration: 411.5587s | Scenes: 214</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_ContentDetectorOnly_CPU | Duration: 400.2969s | Scenes: 164</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:242 - </span><br><span class="line">To analyze .prof files, use a tool like &#x27;snakeviz&#x27; or Python&#x27;s pstats module.</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:243 - Example: python -m pstats profiling_results/your_profile_file.prof</span><br><span class="line">2025-05-30 11:07:26.170 | INFO     | __main__:&lt;module&gt;:244 - Then in pstats shell: sort cumulative, stats 20</span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>macOS 上的 GPU 解码:<ul><li>在 “GPU 监控” 或 “比较耗时” 部分，可以特别说明在 macOS 上，即使没有明确的 <code>VideoStreamCv2Cuda</code>，PySceneDetect 通过<br><code>VideoStreamCv2</code> 也可能间接利用 VideoToolbox/AVFoundation 进行硬件加速解码，但效果可能与专用 CUDA 后端不同。</li></ul></li><li>PySceneDetect 后端回退:<ul><li>在 “结果分析” 或 “故障排查” (如果添加此章节) 部分，解释<br><code>Backend None not available. Trying another backend: opencv</code> 日志的含义，即 PySceneDetect<br>尝试了默认后端（可能是用户指定的或库的优选）但失败，然后回退到 OpenCV。这对于理解实际使用的解码路径很重要。</li></ul></li><li>依赖库版本的重要性:<ul><li>再次强调在 “软件环境一致性” 部分，PySceneDetect、OpenCV (及其 CUDA/OpenCL 支持的编译方式)、FFmpeg<br>的版本都会显著影响性能和功能，包括硬件加速的可用性。</li></ul></li><li><code>min_delta_hsv</code> 废弃警告:<ul><li>在 “配置测试参数” 或 “结果分析” 部分，提示用户注意 PySceneDetect 的废弃警告，并及时更新其配置文件或代码以使用推荐的新参数。</li></ul></li></ul><p>通过这些补充，<code>benchmark_test.md</code> 文档将更准确地反映实际的测试情况，并为用户提供更有价值的性能分析指导。</p><h3 id="4-2-分析性能剖析-prof-文件">4.2. 分析性能剖析 (<code>.prof</code>) 文件</h3><p>使用 Python 的 <code>pstats</code> 模块或 <code>snakeviz</code> 工具来分析 <code>.prof</code> 文件。</p><ul><li>使用 <code>pstats</code> (命令行)</li><li>snakeviz 会在浏览器中打开一个交互式的火焰图或旭日图，直观地展示函数调用栈和各部分耗时。</li><li>关注点：</li><li>耗时最多的函数：这些是首要的优化目标。通常会是 PySceneDetect 库中与视频解码、帧处理以及各检测器核心算法相关的函数。</li><li>PySceneDetect 内部函数：如果瓶颈在 PySceneDetect 库内部（如特定检测器的 process_frame<br>方法，视频解码函数），优化方向可能包括调整检测器参数、选择更快的检测器、或优化视频解码方式（如验证 GPU 解码效果，尝试帧降采样）。</li><li>自定义逻辑：如果 detect_scenes 函数中自定义的逻辑部分（例如，在 scene_detector.py 中添加检测器、调整场景列表的循环）耗时较长，需要针对性优化。</li></ul><h3 id="4-3-分析资源监控数据">4.3. 分析资源监控数据</h3><h4 id="CPU-瓶颈：">CPU 瓶颈：</h4><ul><li>如果 CPU 单核或多核长时间处于高负载状态，表明计算是瓶颈。</li><li>检查是否存在某个核心远高于其他核心的情况（可能表示并行度不足或某些操作无法有效并行，尽管 detect_scenes 本身是单线程的，但其调用的<br>OpenCV 或 FFmpeg 后端可能利用多核）。</li></ul><h4 id="内存瓶颈：">内存瓶颈：</h4><ul><li>如果内存使用持续增长或达到系统上限，可能存在内存泄漏或处理大数据时内存管理不当。</li><li>PySceneDetect 通常是流式处理，但某些配置或长视频仍可能消耗较多内存。确保 video_api_obj.reset() 被正确调用。</li></ul><h4 id="GPU-瓶颈：">GPU 瓶颈：</h4><ul><li>如果启用了 GPU 加速，但 GPU 利用率低，检查驱动、CUDA/OpenCV 配置，以及数据传输到 GPU 的开销。示例输出显示 GPU 配置 (<br>Config_Default_GPU) 速度更快，表明 GPU 在此场景下可能得到了有效利用。</li><li>如果 GPU 利用率高，但性能提升不明显，可能瓶颈在其他部分（如 Python 代码本身、磁盘 I/O）。</li></ul><h2 id="5-根据分析结果改进代码-优化方向示例">5.根据分析结果改进代码 (优化方向示例)</h2><blockquote><p>基于上述分析，可以针对性地对 scene_detector.py 及相关模块进行优化：</p></blockquote><h4 id="场景检测策略优化：">场景检测策略优化：</h4><ul><li>调整检测器：根据性能和准确度需求，在 config.ini 中启用或禁用特定的检测器，或调整其参数（如 threshold,<br>min_scene_len_frames）。从示例输出看，仅使用 ContentDetector 速度最快，但场景数略少。需要根据业务需求决定是否值得牺牲一些检测场景换取速度。</li><li>帧降采样：对于长视频，在 scene_detector.py 中为 SceneManager 设置 frame_skip 或通过<br>video_api_obj.set_downscale_factor() 来减少处理的帧数/分辨率，以大幅提升速度。将其作为可配置项。视频解码优化：</li><li>基于测试结果，确定 CPU 解码或 GPU 解码 (VideoStreamCv2Cuda) 在何种情况下更优，并相应调整配置。示例中 GPU 解码效果明显。</li></ul><h4 id="代码逻辑优化：">代码逻辑优化：</h4><ul><li>检查 detect_scenes 内部是否有可优化的循环或数据处理。确保资源（如 video_api_obj）得到正确和及时的释放。</li></ul><h4 id="长视频特定优化：">长视频特定优化：</h4><ul><li>考虑更细粒度的检查点机制（如果 detect_scenes 本身耗时过长）。</li><li>探索分块处理长视频的策略。</li></ul><h2 id="6-迭代与验证">6. 迭代与验证</h2><blockquote><p>性能优化是一个迭代过程。每次应用优化后，都应重新运行基准测试，以验证优化的效果，并确保没有引入新的性能问题或功能性缺陷。</p></blockquote><blockquote><p>通过遵循本指南，您可以系统地评估和提升视频处理项目的性能，特别是在处理计算密集的场景检测任务时。</p></blockquote><h2 id="总结">总结</h2><h3 id="macOS-场景检测性能测试总结">macOS 场景检测性能测试总结</h3><p>测试视频: <code>建筑家园-02.mp4</code> (60fps)<br>测试日期: 2025-05-30</p><h4 id="关键测试数据">关键测试数据</h4><table><thead><tr><th style="text-align:left">测试配置</th><th style="text-align:left">解码方式</th><th style="text-align:left">检测器组合</th><th style="text-align:left">处理时长 (秒)</th><th style="text-align:left">检测场景数</th><th style="text-align:left">帧率 (fps)</th></tr></thead><tbody><tr><td style="text-align:left"><code>Config_Default_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">MultiDetector</td><td style="text-align:left">433.7327</td><td style="text-align:left">214</td><td style="text-align:left">60.00</td></tr><tr><td style="text-align:left"><code>Config_Default_GPU</code></td><td style="text-align:left">GPU (请求)</td><td style="text-align:left">MultiDetector</td><td style="text-align:left">411.5587</td><td style="text-align:left">214</td><td style="text-align:left">60.00</td></tr><tr><td style="text-align:left"><code>Config_ContentDetectorOnly_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector</td><td style="text-align:left">400.2969</td><td style="text-align:left">164</td><td style="text-align:left">60.00</td></tr></tbody></table><h4 id="主要结论">主要结论</h4><ol><li><p>GPU 加速在 macOS 上的表现:</p><ul><li>当请求 GPU 解码时 (<code>Config_Default_GPU</code>)，即使 PySceneDetect 日志显示回退到标准的 <code>VideoStreamCv2</code> 后端 (而非 <code>VideoStreamCv2Cuda</code>)，处理速度相比纯 CPU 解码 (<code>Config_Default_CPU</code>) 仍有约 5% 的提升 (从 433.73 秒降至 411.56 秒)。</li><li>这表明在 macOS 上，<code>VideoStreamCv2</code> 可能间接利用了系统级的硬件加速框架 (如 AVFoundation/VideoToolbox) 进行视频解码。</li><li>需要注意的是，这种提升幅度可能不如在具有专用 NVIDIA GPU 和正确配置 CUDA 的环境中使用 <code>VideoStreamCv2Cuda</code> 时显著。</li></ul></li><li><p>检测器选择对性能和结果的显著影响:</p><ul><li>仅使用 <code>ContentDetector</code> (<code>Config_ContentDetectorOnly_CPU</code>) 的配置速度最快，处理时长为 400.30 秒。</li><li>与使用 <code>MultiDetector</code> 的 CPU 配置 (<code>Config_Default_CPU</code>) 相比，速度提升了约 7.7% (快了约 33 秒)。</li><li>然而，仅使用 <code>ContentDetector</code> 时，检测到的场景数从 214 个减少到 164 个，表明牺牲了一定的检测全面性。这需要在处理效率和检测结果的完整性之间进行权衡。</li></ul></li><li><p>PySceneDetect 后端行为:</p><ul><li>测试日志中出现 <code>Backend None not available. Trying another backend: opencv</code>，表明 PySceneDetect 在尝试使用一个（可能是用户配置的或库优选的）后端失败后，成功回退到了 OpenCV 后端 (<code>VideoStreamCv2</code>)。这对于理解实际的解码路径和排查配置问题非常重要。</li></ul></li><li><p>库的兼容性提示:</p><ul><li>日志中 <code>AdaptiveDetector</code> 相关的警告 <code>min_delta_hsv is deprecated, use min_content_val instead.</code> 提示需要更新配置文件中的参数，以确保与 PySceneDetect 库的持续兼容性和最佳实践。</li></ul></li></ol><h3 id="windows-测试结果">windows 测试结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">D:\pythonProject\venv1\Scripts\python.exe D:\pythonProject\scene-detect-split1\src\tests\benchmark_scene_detector.py </span><br><span class="line">2025-05-30 14:11:57.528 | INFO     | config.config:initialize_settings:147 - Configuration successfully loaded from: D:\pythonProject\scene-detect-split1\src\run\config.ini</span><br><span class="line">2025-05-30 14:11:57.529 | INFO     | __main__:&lt;module&gt;:118 - Configuration loaded from: D:\pythonProject\scene-detect-split1\src\run\config.ini</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:&lt;module&gt;:210 - </span><br><span class="line">===== Processing Video: Z:\样例\CG渲染样例\建筑家园\建筑家园-02.mp4 =====</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_CPU ---</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:11:57.869 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 14:11:57.870 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:11:58.075 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:45.990 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:45.990 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results\profile_建筑家园_02_Config_Default_CPU.prof</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 288.2435 seconds</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_Default_GPU ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: True</span><br><span class="line">2025-05-30 14:16:46.113 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">2025-05-30 14:16:46.147 | WARNING  | video.scene_detector:detect_scenes:93 - [MainThread] VideoStreamCv2Cuda not available. Using CPU for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:16:46.242 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:16:46.243 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:16:46.243 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:35.982 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:35.982 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:20:36.101 | INFO     | __main__:run_detection_benchmark:76 - Profiling data saved to: profiling_results\profile_建筑家园_02_Config_Default_GPU.prof</span><br><span class="line">2025-05-30 14:20:36.101 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 229.9882 seconds</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:&lt;module&gt;:214 - --- Running with Configuration: Config_ContentDetectorOnly_CPU ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:50 - --- Benchmarking: 建筑家园-02.mp4 ---</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:51 - Detector Setup: ContentDetector</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | __main__:run_detection_benchmark:52 - Using GPU for OpenCV decode: False</span><br><span class="line">2025-05-30 14:20:36.102 | INFO     | video.scene_detector:detect_scenes:69 - [MainThread] Starting detect_scenes for &#x27;建筑家园-02.mp4&#x27;</span><br><span class="line">Backend None not available.</span><br><span class="line">Trying another backend: opencv</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:99 - [MainThread] Video &#x27;建筑家园-02.mp4&#x27; opened with VideoStreamCv2.</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:126 - [MainThread] Configured detector type: ContentDetector for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:20:36.194 | INFO     | video.scene_detector:detect_scenes:133 - [MainThread] Effective global min_scene_len (frames) for detectors: 15 for &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:24:23.153 | INFO     | video.scene_detector:detect_scenes:302 - [MainThread] SceneManager detected 159 scenes in &#x27;建筑家园-02.mp4&#x27;.</span><br><span class="line">2025-05-30 14:24:23.153 | INFO     | video.scene_detector:detect_scenes:334 - [MainThread] Final 159 scenes for &#x27;建筑家园-02.mp4&#x27; after adjustments.</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:83 - Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:85 - Detected Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:86 - Detected Frame Rate: 60.00 fps</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:87 - Processing Time: 227.1770 seconds</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:run_detection_benchmark:90 - --- Benchmark End ---</span><br><span class="line">2025-05-30 14:24:23.278 | INFO     | __main__:&lt;module&gt;:236 - </span><br><span class="line"></span><br><span class="line">===== Benchmark Summary =====</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:238 - </span><br><span class="line">Video: 建筑家园-02.mp4</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_CPU             | Duration: 288.2435s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_Default_GPU             | Duration: 229.9882s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:240 -   Config: Config_ContentDetectorOnly_CPU | Duration: 227.1770s | Scenes: 159</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:242 - </span><br><span class="line">To analyze .prof files, use a tool like &#x27;snakeviz&#x27; or Python&#x27;s pstats module.</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:243 - Example: python -m pstats profiling_results/your_profile_file.prof</span><br><span class="line">2025-05-30 14:24:23.280 | INFO     | __main__:&lt;module&gt;:244 - Then in pstats shell: sort cumulative, stats 20</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Windows-平台场景检测性能测试总结">Windows 平台场景检测性能测试总结</h4><p>测试视频: <code>建筑家园-02.mp4</code> (60fps)<br>测试日期: 2025-05-30<br>测试平台: Windows</p><h5 id="关键测试数据-2">关键测试数据</h5><table><thead><tr><th style="text-align:left">测试配置</th><th style="text-align:left">解码方式</th><th style="text-align:left">检测器设置</th><th style="text-align:left">处理时长 (秒)</th><th style="text-align:left">检测场景数</th></tr></thead><tbody><tr><td style="text-align:left"><code>Config_Default_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector*</td><td style="text-align:left">288.2435</td><td style="text-align:left">159</td></tr><tr><td style="text-align:left"><code>Config_Default_GPU</code></td><td style="text-align:left">GPU (请求)</td><td style="text-align:left">ContentDetector*</td><td style="text-align:left">229.9882</td><td style="text-align:left">159</td></tr><tr><td style="text-align:left"><code>Config_ContentDetectorOnly_CPU</code></td><td style="text-align:left">CPU</td><td style="text-align:left">ContentDetector</td><td style="text-align:left">227.1770</td><td style="text-align:left">159</td></tr></tbody></table><ul><li>重要: 日志显示所有配置（包括 <code>Config_Default_CPU</code> 和 <code>Config_Default_GPU</code>）的 <code>Detector Setup</code> 均为 <code>ContentDetector</code>。这表明 <code>benchmark_scene_detector.py</code> 中的这些 “Default” 配置可能错误地仅指定了 <code>ContentDetector</code>，而不是 <code>config.ini</code> 中定义的 <code>MultiDetector</code>。因此，以下分析基于所有测试实际上都只使用了 <code>ContentDetector</code>。</li></ul><h5 id="主要结论-2">主要结论</h5><ol><li><p>GPU 加速请求在 Windows 上的表现 (当 CUDA 后端不可用时):</p><ul><li>当请求 GPU 解码时 (<code>Config_Default_GPU</code>)，日志明确指出 <code>VideoStreamCv2Cuda not available. Using CPU...</code>。最终视频流通过标准的 <code>VideoStreamCv2</code> 后端由 CPU 完成解码。</li><li>尽管如此，<code>Config_Default_GPU</code> (229.99 秒) 仍然比 <code>Config_Default_CPU</code> (288.24 秒) 快了约 58.25 秒，性能提升约 20.2%。</li><li>这可能归因于 Windows 平台上 OpenCV 的 CPU 解码后端（如 Media Foundation 或 DirectShow）在特定路径或针对某些视频格式时，相比纯粹的 CPU 路径有更优化的表现，或者系统资源调度差异。</li></ul></li><li><p><code>ContentDetectorOnly_CPU</code> 作为最快配置:</p><ul><li><code>Config_ContentDetectorOnly_CPU</code> (227.18 秒) 是所有配置中最快的，符合预期。</li><li>它与 <code>Config_Default_GPU</code> (实际也是 ContentDetector + CPU 解码) 的性能差异较小 (约 2.8 秒)，可能在测量误差范围内。</li></ul></li><li><p>PySceneDetect 后端回退:</p><ul><li>日志清晰展示了当优选后端（如 CUDA）不可用时，PySceneDetect 回退到标准 OpenCV (<code>VideoStreamCv2</code>) 的行为。</li></ul></li><li><p>与 macOS 测试的对比 (针对同一视频，但检测器配置可能不同):</p><ul><li>在 Windows 上仅使用 <code>ContentDetector</code> (CPU) 处理此视频 (约 227-288 秒) 比之前在 macOS 上使用 <code>MultiDetector</code> (CPU) (约 433 秒) 要快。如果 macOS 也仅用 <code>ContentDetector</code> (约 400 秒)，Windows 仍然更快。这可能反映了操作系统底层视频处理框架的效率差异。</li><li>在“请求GPU但回退到CPU”的情况下，Windows 平台显示出相对更大的性能提升 (约 20.2%)，而 macOS 平台 (针对 <code>MultiDetector</code>) 约为 5%。</li></ul></li></ol><h5 id="关键问题点与后续行动建议">关键问题点与后续行动建议</h5><ol><li><p>核实并修正 <code>benchmark_scene_detector.py</code> 中的测试配置:</p><ul><li>首要任务: 确保 <code>Config_Default_CPU</code> 和 <code>Config_Default_GPU</code> 配置正确地使用了您期望的 <code>MultiDetector</code> 设置（从 <code>config.ini</code> 的 <code>[SceneDetectorSetup]</code> 加载）。如果当前它们被错误地指向了仅 <code>ContentDetector</code>，那么对 <code>MultiDetector</code> 的性能评估是不准确的。</li></ul></li><li><p>彻底排查 <code>VideoStreamCv2Cuda not available</code> 问题:</p><ul><li>检查 OpenCV-Python 版本 (确保是为 Windows 编译的、包含 CUDA 支持的版本)。</li><li>检查 CUDA Toolkit 和 cuDNN 的安装与兼容性。</li><li>检查 系统环境变量 (如 <code>PATH</code>, <code>CUDA_PATH</code>)。</li><li>检查 NVIDIA 驱动程序版本。</li><li>运行项目中的 <code>cuda_available_verify.py</code> 脚本获取直接反馈。</li></ul></li><li><p>在 CUDA 成功启用后重新进行基准测试:</p><ul><li>只有当 <code>VideoStreamCv2Cuda</code> 能够成功加载和使用时，才能真正评估 GPU 对视频解码的加速效果。</li><li>届时，重点对比 <code>MultiDetector</code> 配置下 CPU 与 GPU (CUDA) 的性能。</li></ul></li><li><p>分析 <code>.prof</code> 文件:</p><ul><li>对于修正配置后的 <code>MultiDetector</code> 测试，使用 <code>snakeviz</code> 分析 <code>.prof</code> 文件。</li><li>关注视频 I/O (<code>cv2.VideoCapture</code> 的 <code>retrieve</code> 和 <code>grab</code> 方法) 和各个子检测器在 CPU 与 GPU 配置下的耗时。</li></ul></li><li><p>继续测试帧降采样:</p><ul><li>无论 CUDA 是否成功启用，如果视频 I/O 依然是主要瓶颈，帧降采样 (<code>frame_skip</code> 和 <code>downscale_factor</code>) 都是至关重要的优化策略。</li></ul></li></ol><h2 id="后续分析建议">后续分析建议</h2><ul><li>深入剖析 <code>.prof</code> 文件: 使用 <code>snakeviz</code> 或 <code>pstats</code> 分析 <code>MultiDetector</code> 配置下各具体检测器的耗时，以精确定位性能瓶颈。</li><li>测试帧降采样: 鉴于当前处理时间较长，强烈建议测试帧降采样 (<code>frame_skip</code> 或 <code>downscale_factor</code>) 对长视频处理效率的影响。</li><li>参数调优: 针对 <code>MultiDetector</code> 中的各个检测器，细致调整其参数，寻找性能与准确度的最佳平衡点。</li><li>多样化测试: 使用更多不同类型和长度的视频进行测试，以验证当前结论的普适性。</li></ul><h4 id="测试结果如图">测试结果如图</h4><h5 id="macOS平台测试结果图示">macOS平台测试结果图示</h5><ul><li>cpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/cpu_prof.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_prof.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/cpu_profile_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_profile_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>gpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/gpu_prof.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_prof.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/gpu_prof_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_prof_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><h5 id="window平台测试结果图示">window平台测试结果图示</h5><ul><li>cpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/cpu_win_pro.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_win_pro.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/cpu_win_pro_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/cpu_win_pro_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><ul><li>gpu</li></ul><p><img src="/2025/05/30/scene-detect-benchmark/gpu_win_pro.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_win_pro.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><img src="/2025/05/30/scene-detect-benchmark/gpu_win_pro_1.png" class="lazyload placeholder" data-srcset="/2025/05/30/scene-detect-benchmark/gpu_win_pro_1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;场景检测性能优化方向与测试方法&lt;/h1&gt;
&lt;h2 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;本指南旨在提供一套系统化的方法，用于验证和分析视频处理项目的效率，特别是针对场景检测模块的性能。通过收集关键性能指标 (KPIs)&lt;br&gt;
和剖析代码执行，我们可以识别性能瓶</summary>
      
    
    
    
    
    <category term="python" scheme="https://caozhaoqi.github.io/tags/python/"/>
    
  </entry>
  
</feed>
